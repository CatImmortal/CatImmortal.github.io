<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>在Unity中构建AssetBundle补丁包</title>
      <link href="/2023/04/20/assetbundle-build-patch/"/>
      <url>/2023/04/20/assetbundle-build-patch/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间隔壁项目组主程为了能更快速的打包项目里的<strong>AssetBundle</strong>，提了个增加补丁包构建的需求，于是费了几番功夫后便在<a href="https://github.com/CatImmortal/CatAsset">CatAsset</a>中加入了此功能，这篇文章便用来记录此功能的实现思路</p><h1 id="何为补丁包"><a href="#何为补丁包" class="headerlink" title="何为补丁包"></a>何为补丁包</h1><p>首先需要明确几个<strong>AssetBundle</strong>构建相关的概念：</p><ol><li><strong>全量构建</strong>：将所有需要打包的资源提交给Unity的<strong>AssetBundle</strong>构建管线，然后Unity对所有<strong>AssetBundle</strong>全部进行重新构建<strong>（此构建方式很少被使用）</strong></li><li><strong>增量构建</strong>：将所有需要打包的资源提交给Unity的<strong>AssetBundle</strong>构建管线，然后Unity仅对发生了变化的<strong>AssetBundle</strong>进行重新构建<strong>（这是最常见的标准构建方式）</strong></li><li><strong>补丁构建</strong>：仅将发生了变化的资源及其相关资源提交给Unity的<strong>AssetBundle</strong>构建管线，然后由Unity进行<strong>AssetBundle</strong>构建</li></ol><p>所谓<strong>补丁包</strong>，即是补丁构建的产物</p><p>举例来说，若有<strong>资源a、b、c、d被打包为资源包A</strong>，<strong>e、f、g、h被打包为资源包B</strong>（这些资源之间没有依赖关系），且其中资源b发生了变化</p><p>那么在进行<strong>增量构建</strong>时，会将这8个资源全部提交给Unity底层的构建管线，然后Unity会将a、b、c、d所属的资源包A进行重新构建，资源包B则从缓存中复制</p><p>而如果进行的是<strong>补丁构建</strong>，那么只会将发生了变化的资源b提交给Unity单独打包为资源包A_patch，与资源包A、B共存，且后续在加载资源b时只会从A_patch中加载</p><h1 id="补丁构建的优缺点"><a href="#补丁构建的优缺点" class="headerlink" title="补丁构建的优缺点"></a>补丁构建的优缺点</h1><p>补丁构建的优点主要在于：</p><ol><li>资源数量庞大的时候可以很好的加快打包速度，节省时间，减少因为<strong>版本日打包导致的加班风险</strong>，</li><li>在进行资源更新时可以有效降低玩家需要更新的资源大小</li></ol><p>而其缺点则主要是：</p><ol><li>因为补丁包与正式包是共存的，所以会产生一定程度的资源冗余</li><li>补丁资源的计算基于与上一次完整打包（非补丁构建）产生的缓存信息的对比，所以随着变化的资源增多，会提交给Unity的资源数也会增多，构建速度也会逐渐趋近于完整打包的速度，这时需要通过重新进行一次新的完整打包来更新缓存信息</li></ol><h1 id="构建补丁包时要注意的地方"><a href="#构建补丁包时要注意的地方" class="headerlink" title="构建补丁包时要注意的地方"></a>构建补丁包时要注意的地方</h1><p>想要进行补丁包构建，首先需要记录上次完整打包的缓存信息，在CatAsset中是通过记录文件<strong>最后写入时间</strong>实现，但不仅仅是资源文件的最后写入时间，还需要包括资源文件对应的Meta文件的<strong>最后写入时间</strong>才行，否则会导致补丁资源计算出错，因为有些对资源的修改是被反应到Meta文件里的</p><p>另外在计算补丁资源时，不仅是需要判断资源自身是否有变化，还需要考虑它所依赖的资源是否为补丁资源，若它所依赖（直接或间接）的任意一个资源为补丁资源，则此资源也必须视为补丁资源处理（这就意味着<strong>补丁资源具有下游传染性</strong>，会传染给依赖链下游的所有资源），<strong>因为只有在同一批AssetBundle打包的资源之间才能正确进行互相的依赖引用</strong>，否则就会产生<strong>依赖补丁资源的资源，其依赖加载的是旧资源而非新的补丁资源</strong>的问题</p><p>对于补丁资源所依赖的资源，则采用隐式依赖自动包含的机制，不对其进行显式构建，且从补丁资源的依赖列表中移除，以此故意冗余一份相同的依赖资源到补丁资源所在的补丁包中，加载时让Unity自动加载，以保证正式包和补丁包的依赖到相同资源时都能被正确的加载到</p><p>举例来说，假设有依赖链为<strong>D -&gt; C -&gt; B -&gt; A</strong>和<strong>D -&gt; E</strong>，且C为变化的资源，那么最终会将<strong>C以及依赖C的B和A</strong>作为补丁资源，<strong>D作为C的隐式依赖</strong>包含进C的补丁包里，运行时<strong>E依赖的D和C依赖的D会分别在不同的包里</strong>保证E的依赖不丢失（因为在补丁构建后会将资源清单中的旧资源信息删除，保留新的补丁资源信息，以保证能加载到最新的补丁资源）</p><h1 id="构建补丁包的具体步骤"><a href="#构建补丁包的具体步骤" class="headerlink" title="构建补丁包的具体步骤"></a>构建补丁包的具体步骤</h1><p>CatAsset使用SBP进行AssetBundle构建，并自定义了一些构建任务来满足需求</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 构建资源包</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReturnCode <span class="title">BuildBundles</span>(<span class="params">BuildTarget targetPlatform,<span class="built_in">bool</span> isBuildPatch</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          BundleBuildConfigSO config = BundleBuildConfigSO.Instance;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//预处理</span></span><br><span class="line">          <span class="keyword">var</span> preData = <span class="keyword">new</span> BundleBuildPreProcessData</span><br><span class="line">          &#123;</span><br><span class="line">              Config = config,</span><br><span class="line">              TargetPlatform = targetPlatform</span><br><span class="line">          &#125;;</span><br><span class="line">          OnBundleBuildPreProcess(preData);</span><br><span class="line">          </span><br><span class="line">         </span><br><span class="line">          <span class="keyword">if</span> (isBuildPatch)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//检查构建补丁包的缓存文件是否存在</span></span><br><span class="line">              <span class="comment">//若不存在就进行完整资源包构建</span></span><br><span class="line">              <span class="built_in">string</span> manifestPath = EditorUtil.GetCacheManifestPath(config.OutputRootDirectory, targetPlatform);</span><br><span class="line">              <span class="built_in">string</span> assetCacheManifestPath = EditorUtil.GetAssetCacheManifestPath(config.OutputRootDirectory);</span><br><span class="line">              <span class="keyword">if</span> (!File.Exists(manifestPath) || !File.Exists(assetCacheManifestPath))</span><br><span class="line">              &#123;</span><br><span class="line">                  isBuildPatch = <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//准备参数</span></span><br><span class="line">          <span class="built_in">string</span> fullOutputFolder = CreateFullOutputFolder(config, targetPlatform);</span><br><span class="line">          BundleBuildInfoParam buildInfoParam = <span class="keyword">new</span> BundleBuildInfoParam();</span><br><span class="line">          BundleBuildConfigParam configParam = <span class="keyword">new</span> BundleBuildConfigParam(config, targetPlatform,isBuildPatch);</span><br><span class="line">          BundleBuildParameters buildParam = GetSBPParameters(config, targetPlatform, fullOutputFolder);</span><br><span class="line">          BundleBuildContent content = <span class="keyword">new</span> BundleBuildContent();</span><br><span class="line"></span><br><span class="line">          <span class="comment">//添加构建任务</span></span><br><span class="line">          List&lt;IBuildTask&gt; taskList = GetSBPInternalBuildTask(!isBuildPatch);</span><br><span class="line">          taskList.Insert(<span class="number">0</span>,<span class="keyword">new</span> CalculateBundleBuilds());</span><br><span class="line">          taskList.Add(<span class="keyword">new</span> BuildRawBundles());</span><br><span class="line">          taskList.Add(<span class="keyword">new</span> BuildManifest());</span><br><span class="line">          taskList.Add(<span class="keyword">new</span> EncryptBundles());</span><br><span class="line">          taskList.Add(<span class="keyword">new</span> CalculateVerifyInfo());</span><br><span class="line">          <span class="keyword">if</span> (HasOption(config.Options,BundleBuildOptions.AppendHash))</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//附加Hash到包名中</span></span><br><span class="line">              taskList.Add(<span class="keyword">new</span> AppendHash());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (isBuildPatch)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//补丁包需要合并资源清单</span></span><br><span class="line">              taskList.Add(<span class="keyword">new</span> RemoveNonPatchDependency());</span><br><span class="line">              taskList.Add(<span class="keyword">new</span> MergePatchManifest());</span><br><span class="line">          &#125;</span><br><span class="line">          taskList.Add(<span class="keyword">new</span> WriteManifestFile());</span><br><span class="line">          <span class="keyword">if</span> (!isBuildPatch)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//非补丁包 写入缓存</span></span><br><span class="line">              taskList.Add(<span class="keyword">new</span> WriteCacheFile());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (config.IsCopyToReadOnlyDirectory &amp;&amp; config.TargetPlatforms.Count == <span class="number">1</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//需要复制资源包到只读目录下</span></span><br><span class="line">              taskList.Add(<span class="keyword">new</span> CopyToReadOnlyDirectory());</span><br><span class="line">              taskList.Add(<span class="keyword">new</span> WriteManifestFile());</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//开始构建资源包</span></span><br><span class="line">          Stopwatch sw = Stopwatch.StartNew();</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//调用SBP的构建管线</span></span><br><span class="line">          ReturnCode returnCode = ContentPipeline.BuildAssetBundles(buildParam, content,</span><br><span class="line">              <span class="keyword">out</span> IBundleBuildResults result, taskList, buildInfoParam,configParam);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//检查结果</span></span><br><span class="line">          <span class="keyword">if</span> (returnCode == ReturnCode.Success)</span><br><span class="line">          &#123;</span><br><span class="line">              Debug.Log(<span class="string">$&quot;资源包构建成功:<span class="subst">&#123;returnCode&#125;</span>,耗时:<span class="subst">&#123;sw.Elapsed.Hours&#125;</span>时<span class="subst">&#123;sw.Elapsed.Minutes&#125;</span>分<span class="subst">&#123;sw.Elapsed.Seconds&#125;</span>秒&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              Debug.LogError(<span class="string">$&quot;资源包构建未成功:<span class="subst">&#123;returnCode&#125;</span>,耗时:<span class="subst">&#123;sw.Elapsed.Hours&#125;</span>时<span class="subst">&#123;sw.Elapsed.Minutes&#125;</span>分<span class="subst">&#123;sw.Elapsed.Seconds&#125;</span>秒&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">          <span class="comment">//后处理</span></span><br><span class="line">          <span class="keyword">var</span> postData = <span class="keyword">new</span> BundleBuildPostProcessData</span><br><span class="line">          &#123;</span><br><span class="line">              Config = config,</span><br><span class="line">              TargetPlatform = targetPlatform,</span><br><span class="line">              OutputFolder = fullOutputFolder,</span><br><span class="line">              ReturnCode = returnCode,</span><br><span class="line">              Result = result,</span><br><span class="line">          &#125;;</span><br><span class="line">          OnBundleBuildPostProcess(postData);</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">return</span> returnCode;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>总的来说，构建补丁包需要3个步骤：</p><ol><li>在进行完整构建时记录资源缓存信息</li><li>计算补丁资源</li><li>合并资源清单</li></ol><h2 id="生成完整构建时的资源缓存"><a href="#生成完整构建时的资源缓存" class="headerlink" title="生成完整构建时的资源缓存"></a>生成完整构建时的资源缓存</h2><p>资源缓存信息清单的类定义</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> CatAsset.Runtime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CatAsset.Editor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 资源缓存清单</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AssetCacheManifest</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 资源缓存信息</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        [<span class="meta">Serializable</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">struct</span> AssetCacheInfo : IEquatable&lt;AssetCacheInfo&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">long</span> LastWriteTime;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">long</span> MetaLastWriteTime;</span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AssetCacheInfo <span class="title">Create</span>(<span class="params"><span class="built_in">string</span> assetName</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                AssetCacheInfo assetCacheInfo = <span class="keyword">new</span> AssetCacheInfo</span><br><span class="line">                &#123;</span><br><span class="line">                    Name = assetName,</span><br><span class="line">                    LastWriteTime = File.GetLastWriteTime(assetName).Ticks,</span><br><span class="line">                    MetaLastWriteTime =  File.GetLastWriteTime(<span class="string">$&quot;<span class="subst">&#123;assetName&#125;</span>.meta&quot;</span>).Ticks,</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">return</span> assetCacheInfo;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span> ==(AssetCacheInfo a,AssetCacheInfo b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> Equals(a, b);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span> !=(AssetCacheInfo a,AssetCacheInfo b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> !(a == b);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params">AssetCacheInfo other</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> Name == other.Name &amp;&amp; LastWriteTime == other.LastWriteTime &amp;&amp; MetaLastWriteTime == other.MetaLastWriteTime;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> obj <span class="keyword">is</span> AssetCacheInfo other &amp;&amp; Equals(other);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>(<span class="params"></span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">unchecked</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> hashCode = (Name != <span class="literal">null</span> ? Name.GetHashCode() : <span class="number">0</span>);</span><br><span class="line">                    hashCode = (hashCode * <span class="number">397</span>) ^ LastWriteTime.GetHashCode();</span><br><span class="line">                    hashCode = (hashCode * <span class="number">397</span>) ^ MetaLastWriteTime.GetHashCode();</span><br><span class="line">                    <span class="keyword">return</span> hashCode;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 资源清单Json文件名</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">string</span> ManifestJsonFileName = <span class="string">&quot;AssetCacheManifest.json&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">AssetCacheInfo</span>&gt; Caches</span> = <span class="keyword">new</span> List&lt;AssetCacheInfo&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Dictionary&lt;<span class="built_in">string</span>, AssetCacheInfo&gt; <span class="title">GetCacheDict</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Dictionary&lt;<span class="built_in">string</span>, AssetCacheInfo&gt; result = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, AssetCacheInfo&gt;();</span><br><span class="line">            <span class="keyword">foreach</span> (AssetCacheInfo assetCache <span class="keyword">in</span> Caches)</span><br><span class="line">            &#123;</span><br><span class="line">                result.Add(assetCache.Name,assetCache);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如之前提到的，除了资源文件本身的<strong>最后写入时间</strong>外还需要记录Meta文件的<strong>最后写入时间</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> CatAsset.Runtime;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEditor.Build.Pipeline;</span><br><span class="line"><span class="keyword">using</span> UnityEditor.Build.Pipeline.Injector;</span><br><span class="line"><span class="keyword">using</span> UnityEditor.Build.Pipeline.Interfaces;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CatAsset.Editor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 写入缓存文件</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WriteCacheFile</span> : <span class="title">IBuildTask</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">InjectContext(ContextUsage.In)</span>]</span><br><span class="line">        <span class="keyword">private</span> IBundleBuildConfigParam configParam;</span><br><span class="line">        </span><br><span class="line">        [<span class="meta">InjectContext(ContextUsage.In)</span>]</span><br><span class="line">        <span class="keyword">private</span> IManifestParam manifestParam;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">InjectContext(ContextUsage.In)</span>] </span><br><span class="line">        <span class="keyword">private</span> IBundleBuildParameters buildParam;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Version &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> ReturnCode <span class="title">Run</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//复制资源包构建输出结果到缓存文件夹中</span></span><br><span class="line">            <span class="built_in">string</span> folder = EditorUtil.GetBundleCacheFolder(configParam.Config.OutputRootDirectory,</span><br><span class="line">                configParam.TargetPlatform);</span><br><span class="line">            EditorUtil.CreateEmptyDirectory(folder);</span><br><span class="line">            EditorUtil.CopyDirectory(((BundleBuildParameters)buildParam).OutputFolder,folder);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//写入资源缓存清单</span></span><br><span class="line">            folder = EditorUtil.GetAssetCacheManifestFolder(configParam.Config.OutputRootDirectory);</span><br><span class="line">            EditorUtil.CreateEmptyDirectory(folder);</span><br><span class="line">            AssetCacheManifest assetCacheManifest = <span class="keyword">new</span> AssetCacheManifest();</span><br><span class="line">            <span class="keyword">foreach</span> (BundleManifestInfo bundleManifestInfo <span class="keyword">in</span> manifestParam.Manifest.Bundles)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (AssetManifestInfo assetManifestInfo <span class="keyword">in</span> bundleManifestInfo.Assets)</span><br><span class="line">                &#123;</span><br><span class="line">                    AssetCacheManifest.AssetCacheInfo cacheInfo = AssetCacheManifest.AssetCacheInfo.Create(assetManifestInfo.Name);</span><br><span class="line">                    assetCacheManifest.Caches.Add(cacheInfo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">string</span> json = EditorJsonUtility.ToJson(assetCacheManifest,<span class="literal">true</span>);</span><br><span class="line">            <span class="built_in">string</span> path = RuntimeUtil.GetRegularPath(Path.Combine(folder, AssetCacheManifest.ManifestJsonFileName));</span><br><span class="line">            <span class="keyword">using</span> (StreamWriter sw = <span class="keyword">new</span> StreamWriter(path))</span><br><span class="line">            &#123;</span><br><span class="line">                sw.Write(json);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> ReturnCode.Success;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了记录资源<strong>最后写入时间</strong>外，还需要将完整构建产出的资源包复制到资源包缓存目录下，用于在补丁构建后进行合并形成最终的完整资源包输出</p><h2 id="计算补丁资源"><a href="#计算补丁资源" class="headerlink" title="计算补丁资源"></a>计算补丁资源</h2><p>补丁资源的计算大致由以下步骤组成：</p><ol><li>判断自身是否变化</li><li>判断自身依赖的资源是否为补丁资源</li></ol><p>判断【资源是否变化】的步骤则为：</p><ol><li>是否为新资源</li><li>是否为变化的旧资源</li><li>是否为被移动到新包里的旧资源</li></ol><p>具体代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> CatAsset.Runtime;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEditor.Build.Pipeline;</span><br><span class="line"><span class="keyword">using</span> UnityEditor.Build.Pipeline.Injector;</span><br><span class="line"><span class="keyword">using</span> UnityEditor.Build.Pipeline.Interfaces;</span><br><span class="line"><span class="keyword">using</span> UnityEditor.Build.Pipeline.Utilities;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> Debug = UnityEngine.Debug;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CatAsset.Editor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 计算资源包构建信息</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CalculateBundleBuilds</span> : <span class="title">IBuildTask</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Version &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        [<span class="meta">InjectContext(ContextUsage.In)</span>] </span><br><span class="line">        <span class="keyword">private</span> IBundleBuildParameters buildParam;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">InjectContext(ContextUsage.InOut)</span>] </span><br><span class="line">        <span class="keyword">private</span> IBundleBuildInfoParam buildInfoParam;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">InjectContext(ContextUsage.In)</span>] </span><br><span class="line">        <span class="keyword">private</span> IBundleBuildConfigParam configParam;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">InjectContext(ContextUsage.In)</span>] </span><br><span class="line">        <span class="keyword">private</span> IBuildCache buildCache;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">InjectContext(ContextUsage.InOut)</span>] </span><br><span class="line">        <span class="keyword">private</span> IBundleBuildContent content;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">InjectContext(ContextUsage.InOut)</span>] </span><br><span class="line">        <span class="keyword">private</span> IBuildContent content2;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ReturnCode <span class="title">Run</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            BundleBuildConfigSO config = configParam.Config;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!configParam.IsBuildPatch)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//构建完整资源包</span></span><br><span class="line">                buildInfoParam = <span class="keyword">new</span> BundleBuildInfoParam(config.GetAssetBundleBuilds(), config.GetNormalBundleBuilds(),</span><br><span class="line">                    config.GetRawBundleBuilds());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//构建补丁资源包</span></span><br><span class="line">                Stopwatch sw = Stopwatch.StartNew();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">var</span> clonedConfig = <span class="keyword">new</span> PatchAssetCalculateHelper().Calculate(config, configParam.TargetPlatform);</span><br><span class="line"></span><br><span class="line">                sw.Stop();</span><br><span class="line">                Debug.Log(<span class="string">$&quot;计算补丁资源耗时:<span class="subst">&#123;sw.Elapsed.TotalSeconds:<span class="number">0.00</span>&#125;</span>秒&quot;</span>);</span><br><span class="line">                </span><br><span class="line">                buildInfoParam = <span class="keyword">new</span> BundleBuildInfoParam(clonedConfig.GetAssetBundleBuilds(),</span><br><span class="line">                    clonedConfig.GetNormalBundleBuilds(),</span><br><span class="line">                    clonedConfig.GetRawBundleBuilds());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ((BundleBuildParameters)buildParam).SetBundleBuilds(buildInfoParam.NormalBundleBuilds);</span><br><span class="line">            content = <span class="keyword">new</span> BundleBuildContent(buildInfoParam.AssetBundleBuilds);</span><br><span class="line">            content2 = content;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ReturnCode.Success;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> CatAsset.Runtime;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CatAsset.Editor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 补丁资源计算辅助类</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PatchAssetCalculateHelper</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//上游依赖记录</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Dictionary</span>&lt;<span class="title">string</span>, <span class="title">List</span>&lt;<span class="title">string</span>&gt;&gt; upStreamDict</span> = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, List&lt;<span class="built_in">string</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//资源名 -&gt; 本次构建时所属的资源包名</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Dictionary</span>&lt;<span class="title">string</span>, <span class="title">string</span>&gt; assetToBundle</span> = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//资源名 -&gt; 上次完整构建时所属的资源包名</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Dictionary</span>&lt;<span class="title">string</span>, <span class="title">string</span>&gt; cacheAssetToBundle</span> = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line">                </span><br><span class="line">        <span class="comment">//读取上次完整构建时的资源缓存清单</span></span><br><span class="line">        <span class="keyword">private</span> AssetCacheManifest assetCacheManifest;</span><br><span class="line">                </span><br><span class="line">        <span class="comment">//资源名 -&gt; 上次完整构建时的资源缓存信息</span></span><br><span class="line">        <span class="keyword">private</span> Dictionary&lt;<span class="built_in">string</span>, AssetCacheManifest.AssetCacheInfo&gt; assetCacheDict;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//资源名 -&gt; 当前资源缓存信息</span></span><br><span class="line">        <span class="keyword">private</span> Dictionary&lt;<span class="built_in">string</span>, AssetCacheManifest.AssetCacheInfo&gt; curAssetCacheDict =</span><br><span class="line">            <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, AssetCacheManifest.AssetCacheInfo&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//资源名 -&gt; 是否已变化</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Dictionary</span>&lt;<span class="title">string</span>, <span class="title">bool</span>&gt; assetChangeStateDict</span> = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">bool</span>&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//资源名 -&gt; 是否为补丁资源</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Dictionary</span>&lt;<span class="title">string</span>, <span class="title">bool</span>&gt; assetPatchStateDict</span> = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">bool</span>&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> BundleBuildConfigSO <span class="title">Calculate</span>(<span class="params">BundleBuildConfigSO config, BuildTarget buildTarget</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            assetCacheManifest = ReadAssetCache(config);</span><br><span class="line">            assetCacheDict = assetCacheManifest.GetCacheDict();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//深拷贝一份构建配置进行操作</span></span><br><span class="line">            BundleBuildConfigSO clonedConfig = Object.Instantiate(config);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//获取依赖</span></span><br><span class="line">            GetDependencyChain(config);</span><br><span class="line">                </span><br><span class="line">            <span class="comment">//读取上次完整构建时的资源包信息</span></span><br><span class="line">            ReadCachedManifest(config,buildTarget);</span><br><span class="line">                </span><br><span class="line">            <span class="comment">//计算补丁资源</span></span><br><span class="line">            CalPatchAsset(config, clonedConfig);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> clonedConfig;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//省略...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 计算补丁资源</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CalPatchAsset</span>(<span class="params">BundleBuildConfigSO config, BundleBuildConfigSO clonedConfig</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = clonedConfig.Bundles.Count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> bundle = clonedConfig.Bundles[i];</span><br><span class="line"></span><br><span class="line">                <span class="comment">//此资源包是否全部资源都是补丁资源</span></span><br><span class="line">                <span class="built_in">bool</span> isAllPatch = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> j = bundle.Assets.Count - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> asset = bundle.Assets[j];</span><br><span class="line">                    index++;</span><br><span class="line">                    EditorUtility.DisplayProgressBar(<span class="string">$&quot;计算补丁资源&quot;</span>, <span class="string">$&quot;<span class="subst">&#123;asset.Name&#125;</span>&quot;</span>, index / (config.AssetCount * <span class="number">1.0f</span>));</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">bool</span> isPatch = IsPatchAsset(asset.Name);</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (isPatch)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Debug.Log(<span class="string">$&quot;发现补丁资源:<span class="subst">&#123;asset.Name&#125;</span>&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//不是补丁资源 移除掉</span></span><br><span class="line">                        bundle.Assets.RemoveAt(j);</span><br><span class="line">                        isAllPatch = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bundle.Assets.Count &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//是补丁包</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (!isAllPatch)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//有部分资源不是补丁资源 需要改名 否则直接用正式包的名字了</span></span><br><span class="line">                        <span class="keyword">var</span> part = bundle.BundleName.Split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                        bundle.BundleName = <span class="string">$&quot;<span class="subst">&#123;part[<span class="number">0</span>]&#125;</span>_patch.<span class="subst">&#123;part[<span class="number">1</span>]&#125;</span>&quot;</span>;</span><br><span class="line">                        bundle.BundleIdentifyName =</span><br><span class="line">                            BundleBuildInfo.GetBundleIdentifyName(bundle.DirectoryName, bundle.BundleName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//不是补丁包 需要移除</span></span><br><span class="line">                    clonedConfig.Bundles.RemoveAt(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            EditorUtility.ClearProgressBar();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 是否为补丁资源</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">IsPatchAsset</span>(<span class="params"><span class="built_in">string</span> assetName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//0.已经计算过状态了</span></span><br><span class="line">            <span class="keyword">if</span> (assetPatchStateDict.TryGetValue(assetName, <span class="keyword">out</span> <span class="built_in">bool</span> isPatch))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> isPatch;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//1.自身是否已变化</span></span><br><span class="line">            isPatch = IsChangedAsset(assetName);</span><br><span class="line">            <span class="keyword">if</span> (isPatch)</span><br><span class="line">            &#123;</span><br><span class="line">                assetPatchStateDict.Add(assetName,<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//2.此资源依赖的上游资源是否为补丁资源</span></span><br><span class="line">            <span class="comment">//位于上游的补丁资源，其补丁性会传染给依赖链下游的所有资源</span></span><br><span class="line">            <span class="keyword">if</span> (upStreamDict.TryGetValue(assetName, <span class="keyword">out</span> <span class="keyword">var</span> upStreamList))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="built_in">string</span> upStream <span class="keyword">in</span> upStreamList)</span><br><span class="line">                &#123;</span><br><span class="line">                    isPatch = IsPatchAsset(upStream);</span><br><span class="line">                    <span class="keyword">if</span> (isPatch)</span><br><span class="line">                    &#123;</span><br><span class="line">                        assetPatchStateDict.Add(assetName,<span class="literal">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//补丁性不传染给依赖链上游资源</span></span><br><span class="line">            <span class="comment">//而是通过隐式依赖自动包含机制 故意冗余一份 使得补丁资源的依赖和它本身在一个资源包内</span></span><br><span class="line">            <span class="comment">//以防止正式包的资源 依赖到 补丁包依赖的资源 时 丢失依赖</span></span><br><span class="line">            <span class="comment">//这样就会在正式包和补丁包里各包含一份相同的依赖资源 保证正式包依赖不丢失</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//假设有D -&gt; C -&gt; B -&gt; A 和 D -&gt; E 的依赖链，且C为变化的资源</span></span><br><span class="line">            <span class="comment">//那么最终会将C以及依赖C的B和A作为补丁资源，D作为C的隐式依赖包含进C的补丁包里</span></span><br><span class="line">            <span class="comment">//运行时 E依赖的D 和 C依赖的D 会分别在不同的包里 保证E依赖不丢失</span></span><br><span class="line">            </span><br><span class="line">            assetPatchStateDict.Add(assetName,<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 是否为已变化的资源</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">IsChangedAsset</span>(<span class="params"><span class="built_in">string</span> assetName</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//0.已经计算过状态了</span></span><br><span class="line">            <span class="keyword">if</span> (assetChangeStateDict.TryGetValue(assetName, <span class="keyword">out</span> <span class="built_in">bool</span> isPatch))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> isPatch;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1.新资源 </span></span><br><span class="line">            <span class="keyword">if</span> (!assetCacheDict.TryGetValue(assetName, <span class="keyword">out</span> <span class="keyword">var</span> assetCache))</span><br><span class="line">            &#123;</span><br><span class="line">                assetChangeStateDict.Add(assetName, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.变化的旧资源</span></span><br><span class="line">            <span class="keyword">if</span> (!curAssetCacheDict.TryGetValue(assetName, <span class="keyword">out</span> <span class="keyword">var</span> curAssetCache))</span><br><span class="line">            &#123;</span><br><span class="line">                curAssetCache = AssetCacheManifest.AssetCacheInfo.Create(assetName);</span><br><span class="line">                curAssetCacheDict.Add(assetName, curAssetCache);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curAssetCache != assetCache)</span><br><span class="line">            &#123;</span><br><span class="line">                assetChangeStateDict.Add(assetName, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.被移动到新包的旧资源</span></span><br><span class="line">            <span class="keyword">if</span> (assetToBundle[assetName] != cacheAssetToBundle[assetName])</span><br><span class="line">            &#123;</span><br><span class="line">                assetChangeStateDict.Add(assetName, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//未变化</span></span><br><span class="line">            assetChangeStateDict.Add(assetName, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会在完整构建的资源列表基础上，移除所有非补丁资源，以及不包含补丁资源的资源包，以此形成用于最终补丁构建的资源列表</p><p>另外值得一提的是，为了降低补丁包带来的复杂度与资源冗余，CatAsset规定了每个正式包最多只会有一个补丁包，同时如果某个补丁包包含了正式包的所有资源，则此补丁包会自动转正为正式包</p><h2 id="合并资源清单"><a href="#合并资源清单" class="headerlink" title="合并资源清单"></a>合并资源清单</h2><p>在构建补丁包完成后，需要将新的补丁资源包与上一次完整构建时输出的资源包进行合并，以得到最终输出的完整资源包与资源清单</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> CatAsset.Runtime;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEditor.Build.Pipeline;</span><br><span class="line"><span class="keyword">using</span> UnityEditor.Build.Pipeline.Injector;</span><br><span class="line"><span class="keyword">using</span> UnityEditor.Build.Pipeline.Interfaces;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CatAsset.Editor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 合并补丁包资源清单</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MergePatchManifest</span> : <span class="title">IBuildTask</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">InjectContext(ContextUsage.In)</span>]</span><br><span class="line">        <span class="keyword">private</span> IBundleBuildParameters buildParam;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">InjectContext(ContextUsage.In)</span>]</span><br><span class="line">        <span class="keyword">private</span> IBundleBuildConfigParam configParam;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">InjectContext(ContextUsage.InOut)</span>]</span><br><span class="line">        <span class="keyword">private</span> IManifestParam manifestParam;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;inheritdoc /&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Version =&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;inheritdoc /&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ReturnCode <span class="title">Run</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> config = configParam.Config;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> bundleCacheFolder = EditorUtil.GetBundleCacheFolder(config.OutputRootDirectory, configParam.TargetPlatform);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//本次补丁包构建的资源</span></span><br><span class="line">            HashSet&lt;<span class="built_in">string</span>&gt; patchAssets = <span class="keyword">new</span> HashSet&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">            <span class="keyword">foreach</span> (BundleManifestInfo bundleManifestInfo <span class="keyword">in</span> manifestParam.Manifest.Bundles)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (AssetManifestInfo assetManifestInfo <span class="keyword">in</span> bundleManifestInfo.Assets)</span><br><span class="line">                &#123;</span><br><span class="line">                    patchAssets.Add(assetManifestInfo.Name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//修改资源清单 移除重复资源</span></span><br><span class="line">            <span class="built_in">string</span> path = RuntimeUtil.GetRegularPath(Path.Combine(bundleCacheFolder, CatAssetManifest.ManifestJsonFileName));</span><br><span class="line">            CatAssetManifest cachedManifest = CatAssetManifest.DeserializeFromJson(File.ReadAllText(path));</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = cachedManifest.Bundles.Count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                BundleManifestInfo bundleManifestInfo = cachedManifest.Bundles[i];</span><br><span class="line">                <span class="keyword">if</span> (bundleManifestInfo.BundleName == RuntimeUtil.BuiltInShaderBundleName)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//跳过内置Shader资源包</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> j = bundleManifestInfo.Assets.Count - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//删掉已经在补丁包中的资源信息</span></span><br><span class="line">                    AssetManifestInfo assetManifestInfo = bundleManifestInfo.Assets[j];</span><br><span class="line">                    <span class="keyword">if</span> (patchAssets.Contains(assetManifestInfo.Name))</span><br><span class="line">                    &#123;</span><br><span class="line">                        bundleManifestInfo.Assets.RemoveAt(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bundleManifestInfo.Assets.Count == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//删掉所有资源都在补丁包里的资源包</span></span><br><span class="line">                    cachedManifest.Bundles.RemoveAt(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//合并资源包</span></span><br><span class="line">            <span class="built_in">string</span> outputFolder = ((BundleBuildParameters)buildParam).OutputFolder;</span><br><span class="line">            <span class="keyword">foreach</span> (BundleManifestInfo bundleManifestInfo <span class="keyword">in</span> cachedManifest.Bundles)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> sourcePath = RuntimeUtil.GetRegularPath(Path.Combine(bundleCacheFolder, bundleManifestInfo.RelativePath));</span><br><span class="line">                <span class="built_in">string</span> destPath = RuntimeUtil.GetRegularPath(Path.Combine(outputFolder,bundleManifestInfo.RelativePath));</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(bundleManifestInfo.Directory))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> fullDirectory = RuntimeUtil.GetRegularPath(Path.Combine(outputFolder,bundleManifestInfo.Directory));</span><br><span class="line">                    <span class="keyword">if</span> (!Directory.Exists(fullDirectory))</span><br><span class="line">                    &#123;</span><br><span class="line">                        Directory.CreateDirectory(fullDirectory);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                File.Copy(sourcePath,destPath);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//合并补丁包资源清单与缓存资源清单</span></span><br><span class="line">            cachedManifest.Bundles.AddRange(manifestParam.Manifest.Bundles);</span><br><span class="line">            manifestParam = <span class="keyword">new</span> ManifestParam(cachedManifest, manifestParam.WriteFolder);</span><br><span class="line">            </span><br><span class="line">          </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> ReturnCode.Success;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此操作会将在原来被缓存的资源清单中存在的补丁资源， 以及所有资源都是补丁资源的资源包从原资源清单中移除，然后与补丁构建产生的资源清单合并，最终得到一份新的资源清单用于正确的初始化资源信息</p><p>以之前的例子来说，补丁构建产生的资源清单只会包含A_patch和资源b的信息，并且会将原资源清单中的资源b信息移除，然后将二者进行合并以得到新的资源清单</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年终总结</title>
      <link href="/2022/12/31/2022-year-end-summary/"/>
      <url>/2022/12/31/2022-year-end-summary/</url>
      
        <content type="html"><![CDATA[<p>晃晃悠悠又是一年过去了，这个2022年可谓是让我难以忘怀的一年</p><p>大事的话主要还是2件吧</p><p>首先是来到上海后没多久就经历了长达2个月的封城（4-6月），期间过的那叫一个惨（也在群里诞生了不少我的梗），实在难以想象在2022年的中国一线城市居然还能过上在对明天能不能有饭吃这点上担惊受怕的生活，而且直到现在都没见有什么大老虎因为封城被清算，实在感觉蚌埠住。</p><p>然后就是到了8月初，在经历了一个月的加班后遭遇了裁员（不过有N+1大礼包拿还是挺爽的），果然大加班=大毕业，想想当时满怀希望跳槽到上海的我还是挺让人感慨的。</p><p>被裁员后休息了2个月左右，虽然是家里蹲状态，但期间保持了从7月就开始健身锻炼的习惯，肌肉量增加了不少。也完成了对CatJson和CatAsset的V2版本的开发以及相关文章的写作，最后在国庆期间回了躺老家相亲，当然结果就是没有结果(计划了蛮久的三国杀复刻也决定暂且搁置了)。</p><p>在面试了好几家后（有一说一面试真的累死人）决定平薪去了杭州，在公司附近10分钟路程的地方租了个70平大豪斯，而价格也就比之前在上海住合租单间高个几百块而已，真是爽到不行。到了杭州后，在以往的哑铃训练之外，因为购入了Pico4，也新增了VR拳击的训练项目，还吃了两个月的魔芋米面，终于把腹肌也搞出来一点了。</p><p>新公司负责的工作内容也比较让我满意，不同于之前一直都是用狗屎Lua做系统开发，在新公司目前主要负责了资源框架的开发，这让CatAsset又进行了一波非常大的迭代，甚至可以认为是V3版了。此外就是基于HybridCLR的C#热更新（终于不用吃Lua这口屎了）和行为树AI的开发（按照命名习惯定名为了CatBehaviour，后续也会开源这个行为树插件并撰写相关技术文章）。</p><p>到了年底，政策突然就放开了，接着就是认识的一大堆人开始陆续阳了，而我可能幸运一直撑到现在还是阴的（代价就是别人都居家摸鱼两周了我还得像个嗨奴一样天天去公司上班），最后成为了公司仅剩的7个没阳过的人之一。</p><p>2022年还有一件有点意义的事，就是在年初参与了一个Vsinger同人音游企划的开发，不过整体进度是比较缓慢的，而且人员专业程度与参与度也比较差，导致我现在对这个企划能否顺利完成的看法是较为悲观的。</p><p>2022年的总结就写到这吧，关于2023年的规划，首先就是别再被毕业了，然后继续迭代维护那几个开源项目，最后嘛，就还是尽量能多去研究点Gameplay相关的内容吧（虽然去年就这么说，但今年还是屁成果都拿不出来），希望明年能整个动作游戏demo出来吧。</p><p>至于感情方面就随缘吧，我也算看开了，明年大概率又是母胎单身的一年。</p><p>哦对了希望明年也能坚持住健身的习惯，让肌肉量变得更多一些。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 年终总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UnitySBP打包SpriteAtlas图集时的纹理冗余Bug</title>
      <link href="/2022/11/26/sbp-spriteatlas-bug/"/>
      <url>/2022/11/26/sbp-spriteatlas-bug/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在使用SpriteAtlas时，通常会将include in build勾选，然后将SpriteAtlas的所有散图打包进同一个AssetBundle中（但图集本身不打包），最终打包出的AssetBundle会包含图集Texture+所有散图的Sprite</p><p>假设有图片G0、G1、G2、G3被打包进了同一个AssetBundle中，并且归属于同一个SpriteAtlas，那么此AssetBundle所包含的资源便如下：</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/SBPSpriteAtlasBug/SBPSpriteAtlasBug_01.png"></p><p>而在没有SpriteAtlas的情况下，则是这样的：</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/SBPSpriteAtlasBug/SBPSpriteAtlasBug_02.png"></p><p>可以看出2个AssetBundle的文件体积差距并不大，其主要差异在其中包含的资源上</p><p>那么是什么导致这样的差异呢？</p><p>这里就需要提及在反复打包测试后得出的， Unity处理SpriteAtlas时的2个重要规则了：</p><ol><li>在图片被打包时，如果此图片属于某个SpriteAtlas，那么Unity就<strong>只会打包此图片的Sprite，而不会打包Texture</strong>，因为在加载此图片时，得实际从SpriteAtlas的Texture中进行加载</li><li>如果<strong>勾选了SpriteAtlas的include in build，那么会建立起散图对SpriteAtlas的隐式依赖</strong>，后续在打包图片时就会按照Unity的自动依赖收集机制决定SpriteAtlas是进入安装包还是进入AssetBundle，这样Unity就可以在需要加载散图时自动找到对应的SpriteAtlas（否则就需要使用者自行做late binding处理）。而且Unity会自动<strong>修正因为通过隐式依赖进入AssetBundle中的SpriteAtlas冗余</strong>（但是在老版本中因为Bug导致没有这个修正，从而造成SpriteAtlas在AssetBundle中的多份冗余）</li></ol><h1 id="SBP处理SpriteAtlas的Bug"><a href="#SBP处理SpriteAtlas的Bug" class="headerlink" title="SBP处理SpriteAtlas的Bug"></a>SBP处理SpriteAtlas的Bug</h1><p>然而可惜的是，在Unity的SBP中（可编程构建管线），第1个规则并没有生效，于是就形成了SBP与Builtin构建管线的结果不一致现象</p><p>通过SBP对上面相同资源的打包结果如下：</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/SBPSpriteAtlasBug/SBPSpriteAtlasBug_03.png"></p><p>可以看到散图的Texture也一并被打包了，最终造成<strong>纹理的双倍冗余</strong></p><p>在反复测试后，发现只有单独打包SpriteAtlas而不打包散图的情况下，才能避免纹理冗余：</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/SBPSpriteAtlasBug/SBPSpriteAtlasBug_04.png"></p><p>但这么做的弊端就是上层使用者无法直接从AssetBundle中手动加载散图，必须先加载SpriteAtlas，然后再从SpriteAtlas中手动加载散图才行，最终破坏了原本上层使用者对于SpriteAtlas的<strong>“无感知”体验优势</strong>，而想恢复这个优势就必须自行在资源框架层进行额外处理</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>在发现这个Bug后，便先试图反馈到Unity官方，但是即使反馈成功也不知道何时会进行修复，所以只能先自己动手解决Bug了</p><p>思路也比较简单，得益于SBP高度可定制的构建流程，<strong>只需要在散图AssetBundle的内容生成后——文件写入前这个时机，通过插入自定义的BuildTask，将冗余出来的散图纹理从中删掉即可</strong>，具体代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> 修复SBP构建包含图集散图的资源包时，发生散图纹理冗余的Bug</span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FixSpriteAtlasBug</span> : <span class="title">IBuildTask</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;inheritdoc /&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">int</span> Version =&gt; <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">      [<span class="meta">InjectContext</span>]</span><br><span class="line">      IBundleWriteData writeDataParam;</span><br><span class="line">      </span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;inheritdoc /&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> ReturnCode <span class="title">Run</span>(<span class="params"></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          BundleWriteData writeData = (BundleWriteData)writeDataParam;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//所有图集散图的guid集合</span></span><br><span class="line">          HashSet&lt;GUID&gt; spriteGuids = <span class="keyword">new</span>  HashSet&lt;GUID&gt;();</span><br><span class="line"></span><br><span class="line">          <span class="comment">//遍历资源包里的资源 记录其中图集的散图guid</span></span><br><span class="line">          <span class="keyword">foreach</span> (<span class="keyword">var</span> pair <span class="keyword">in</span> writeData.FileToObjects)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">foreach</span> (ObjectIdentifier objectIdentifier <span class="keyword">in</span> pair.Value)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="built_in">string</span> path = AssetDatabase.GUIDToAssetPath(objectIdentifier.guid);</span><br><span class="line">                  Object asset = AssetDatabase.LoadAssetAtPath&lt;Object&gt;(path);</span><br><span class="line">                  <span class="keyword">if</span> (asset <span class="keyword">is</span> SpriteAtlas)</span><br><span class="line">                  &#123;</span><br><span class="line">                      List&lt;<span class="built_in">string</span>&gt; spritePaths = EditorUtil.GetDependencies(path, <span class="literal">false</span>);</span><br><span class="line">                      <span class="keyword">foreach</span> (<span class="built_in">string</span> spritePath <span class="keyword">in</span> spritePaths)</span><br><span class="line">                      &#123;</span><br><span class="line">                          GUID spriteGuild = AssetDatabase.GUIDFromAssetPath(spritePath);</span><br><span class="line">                          spriteGuids.Add(spriteGuild);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//将writeData.FileToObjects包含的图集散图的texture删掉 避免冗余</span></span><br><span class="line">          <span class="keyword">foreach</span> (<span class="keyword">var</span> pair <span class="keyword">in</span> writeData.FileToObjects)</span><br><span class="line">          &#123;</span><br><span class="line">              List&lt;ObjectIdentifier&gt; objectIdentifiers = pair.Value;</span><br><span class="line">              <span class="keyword">for</span> (<span class="built_in">int</span> i = objectIdentifiers.Count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">              &#123;</span><br><span class="line">                  ObjectIdentifier objectIdentifier = objectIdentifiers[i];</span><br><span class="line">                  <span class="keyword">if</span> (spriteGuids.Contains(objectIdentifier.guid))</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="keyword">if</span> (objectIdentifier.localIdentifierInFile == <span class="number">2800000</span>)</span><br><span class="line">                      &#123;</span><br><span class="line">                          <span class="comment">//删除图集散图的冗余texture</span></span><br><span class="line">                          objectIdentifiers.RemoveAt(i);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">return</span> ReturnCode.Success;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 获取SBP内置的构建任务</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;IBuildTask&gt; <span class="title">GetSBPInternalBuildTask</span>(<span class="params"></span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//...省略</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// Packing</span></span><br><span class="line">         buildTasks.Add(<span class="keyword">new</span> GenerateBundlePacking());</span><br><span class="line">         buildTasks.Add(<span class="keyword">new</span> FixSpriteAtlasBug());  <span class="comment">//这里插入一个修复SBP图集Bug的任务</span></span><br><span class="line">         buildTasks.Add(<span class="keyword">new</span> UpdateBundleObjectLayout());</span><br><span class="line">         buildTasks.Add(<span class="keyword">new</span> GenerateBundleCommands());</span><br><span class="line">         buildTasks.Add(<span class="keyword">new</span> GenerateSubAssetPathMaps());</span><br><span class="line">         buildTasks.Add(<span class="keyword">new</span> GenerateBundleMaps());</span><br><span class="line">         buildTasks.Add(<span class="keyword">new</span> PostPackingCallback());</span><br><span class="line"></span><br><span class="line">         <span class="comment">//...省略</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> buildTasks;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p><strong>注意：此修复的限制在于，同一个SpriteAtlas的的所有散图必须被打包进同一个AssetBundle，并且如果SpriteAtlas没有勾选include in build，也必须和它所包含的散图在同一个AssetBundle中</strong></p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
          <category> 踩坑记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CatAsset开发总结：Runtime篇</title>
      <link href="/2022/09/04/catasset-dev-summary-with-runtime/"/>
      <url>/2022/09/04/catasset-dev-summary-with-runtime/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要用于总结<a href="https://github.com/CatImmortal/CatAsset">CatAsset</a>在Runtime部分的设计思路</p><p>代码结构如下：</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatAssetDevSummaryWithRuntime/CatAssetDevSummaryWithRuntime_01.png"></p><p>CatJson：包含用于进行Json序列化与反序列化的代码</p><p>Database：包含清单信息与运行时信息的数据结构</p><p>Extensions：包含扩展代码</p><p>Misc：包含各类杂项代码</p><p>Pool：包含游戏对象池与引用池代码</p><p>TaskSystem：包含支持CatAsset Runtime核心功能运转的任务系统代码</p><p>Updatable：包含用于可更新模式下的版本检查器与资源组更新器代码</p><h1 id="资源清单与运行时信息"><a href="#资源清单与运行时信息" class="headerlink" title="资源清单与运行时信息"></a>资源清单与运行时信息</h1><h2 id="资源清单"><a href="#资源清单" class="headerlink" title="资源清单"></a>资源清单</h2><p><strong>资源清单（CatAssetManifest）</strong>记录了在<strong>Editor</strong>下构建出的所有资源包（<code>BundleManifest</code>）及其中资源（<code>AssetManifest</code>）的相关信息</p><p>对于内置资源而言只有通过<code>CatAssetManifest</code>能够读取到相关信息的，才是可被CatAsset管理的</p><h2 id="运行时信息"><a href="#运行时信息" class="headerlink" title="运行时信息"></a>运行时信息</h2><p>对应<code>BundleManifest</code>和<code>AssetManifest</code>，有<code>BundleRuntimeInfo</code>和<code>AssetRuntimeInfo</code>，用于保存在游戏运行中产生的相关行为的信息，如<strong>资源实例、引用计数</strong>等</p><h1 id="任务系统"><a href="#任务系统" class="headerlink" title="任务系统"></a>任务系统</h1><p>CatAsset的Runtime中大部分核心功能都是基于<strong>任务系统（TaskSystem）</strong>实现的，此系统主要用于解决下列异步运行相关需求：</p><ul><li><strong>异步运行间的依赖等待</strong></li><li><strong>异步运行到一半需要取消</strong></li><li><strong>目标相同的异步运行的合并</strong></li><li><strong>异步运行频率的限制</strong></li><li><strong>异步运行的优先级</strong></li></ul><p>诸如<strong>加载、卸载、更新</strong>等操作都封装为了对应的<strong>任务（Task）</strong>，被放置于<strong>任务组（TaskGroup）</strong>中，由<strong>任务运行器（TaskRunner）</strong>根据<strong>优先级</strong>对<strong>TaskGroup</strong>进行管理</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatAssetDevSummaryWithRuntime/CatAssetDevSummaryWithRuntime_07.png"></p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p><strong>任务（Task）</strong>是<strong>TaskSystem</strong>中实际的逻辑运行者，从抽象基类<code>BaseTask</code>、接口<code>ITask</code>派生</p><p>接口<code>ITask</code>定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 任务接口</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ITask</span> : <span class="title">IReference</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 持有者</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    TaskRunner Owner &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 全局id</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="built_in">int</span> GUID &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 名称</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 状态</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    TaskState State &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 进度</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="built_in">float</span> Progress &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 已合并任务数量</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MergedTaskCount &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 合并任务</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MergeTask</span>(<span class="params">ITask task</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 运行任务</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span>(<span class="params"></span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 轮询任务</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 取消任务</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Cancel</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h3><p><strong>任务状态（TaskState）</strong>表示此<code>Task</code>的内部运行情况，其定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> 任务状态</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">enum</span> TaskState</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 空闲</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       Free,</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 等待中</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       Waiting,</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 运行中</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       Running,</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 已结束</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       Finished,</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通常来说</p><ul><li>未开始运行的<code>Task</code>为<strong>Free</strong>状态</li><li>需要等待其他<code>Task</code>运行才能开始运行的<code>Task</code>为<strong>Waiting</strong>状态</li><li>正在运行的<code>Task</code>为<strong>Running</strong>状态</li><li>运行结束的<code>Task</code>为<strong>Finished</strong>状态</li></ul><h3 id="任务合并"><a href="#任务合并" class="headerlink" title="任务合并"></a>任务合并</h3><p>对于同名的<code>Task</code>，<strong>TaskSystem</strong>会将其放入到已有<code>Task</code>的<code>MergedTaskList</code>中，已有<code>Task</code>运行结束后会将运行结果回调给<code>MergedTaskList</code>中的所有<code>Task</code></p><h3 id="任务取消"><a href="#任务取消" class="headerlink" title="任务取消"></a>任务取消</h3><p><code>Task</code>被创建后会获得一个全局唯一的<code>GUID</code>，对于支持取消操作的<code>Task</code>，可通过此<code>GUID</code>进行取消，被取消的<code>Task</code>即便运行结束了也不会回调给使用者运行结果</p><h2 id="任务运行器与任务组"><a href="#任务运行器与任务组" class="headerlink" title="任务运行器与任务组"></a>任务运行器与任务组</h2><h3 id="任务运行器"><a href="#任务运行器" class="headerlink" title="任务运行器"></a>任务运行器</h3><p><strong>任务运行器（TaskRunner）</strong>是所有<code>Task</code>运行的起点</p><p><code>TaskRunner</code>在初始化时会按照预定义的<strong>任务优先级（TaskPriority）</strong>去创建对应优先级的<strong>任务组（TaskGroup）</strong>，并按照优先级去轮询<code>TaskGroup</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> 任务优先级</span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">enum</span> TaskPriority</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 非常低</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      VeryLow = <span class="number">0</span>,</span><br><span class="line">      </span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 低</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      Low = <span class="number">1</span>,</span><br><span class="line">      </span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 中</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      Middle = <span class="number">2</span>,</span><br><span class="line">      </span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 高</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      Height = <span class="number">3</span>,</span><br><span class="line">      </span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 非常高</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      VeryHeight = <span class="number">4</span>,</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TaskRunner</span>(<span class="params"></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//优先级数量</span></span><br><span class="line">          <span class="built_in">int</span> priorityNum = Enum.GetNames(<span class="keyword">typeof</span>(TaskPriority)).Length;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; priorityNum; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//按优先级创建任务组</span></span><br><span class="line">              taskGroups.Add(<span class="keyword">new</span> TaskGroup((TaskPriority)i));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="任务组"><a href="#任务组" class="headerlink" title="任务组"></a>任务组</h3><p><strong>任务组（TaskGroup）</strong>中保存了以此<code>TaskGroup</code>对应优先级来运行的<code>Task</code>对象，会在每次<code>Task</code>运行后，根据<code>Task</code>的<code>State</code>来决定是否增加当前运行中的任务计数</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 运行任务组</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Run</span>(<span class="params"></span>)</span></span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">         <span class="built_in">int</span> index = nextRunningTaskIndex;</span><br><span class="line">         nextRunningTaskIndex++;</span><br><span class="line">         </span><br><span class="line">         ITask task = runningTasks[index];</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span> (task.State == TaskState.Free)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="comment">//运行空闲状态的任务</span></span><br><span class="line">                 task.Run();</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">//轮询任务</span></span><br><span class="line">             task.Update();</span><br><span class="line">         &#125;</span><br><span class="line">         catch (Exception e)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="comment">//任务出现异常 视为任务结束处理</span></span><br><span class="line">             task.State = TaskState.Finished;</span><br><span class="line">             <span class="keyword">throw</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">finally</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">switch</span> (task.State)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">case</span> TaskState.Finished:</span><br><span class="line">                     <span class="comment">//任务运行结束 需要删除</span></span><br><span class="line">                     waitRemoveTasks.Add(index);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">             &#125;;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">switch</span> (task.State)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">case</span> TaskState.Running:</span><br><span class="line">             <span class="keyword">case</span> TaskState.Finished:</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="频率限制"><a href="#频率限制" class="headerlink" title="频率限制"></a>频率限制</h3><p><code>TaskRunner</code>中定义了单帧最大任务运行数量，在每次<code>Update</code>时会根据<code>TaskGroup</code>返回结果来统计当前帧运行中的任务数量，如果达到了限制数量就会停止对<code>TaskGroup</code>的运行</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 轮询任务运行器</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//当前运行任务次数</span></span><br><span class="line">          <span class="built_in">int</span> curRanCount = <span class="number">0</span>;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">for</span> (<span class="built_in">int</span> i = taskGroups.Count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">          &#123;</span><br><span class="line">              TaskGroup <span class="keyword">group</span> = taskGroups[i];</span><br><span class="line">              </span><br><span class="line">              <span class="keyword">group</span>.PreRun();</span><br><span class="line"></span><br><span class="line">              <span class="keyword">while</span> (curRanCount &lt; MaxRunCount &amp;&amp; <span class="keyword">group</span>.CanRun)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">if</span> (<span class="keyword">group</span>.Run())</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="comment">//Run调用返回true 意味着需要增加curRanCount</span></span><br><span class="line">                      curRanCount++;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              </span><br><span class="line">              <span class="keyword">group</span>.PostRun();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h1 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h1><h2 id="资源类别的判断"><a href="#资源类别的判断" class="headerlink" title="资源类别的判断"></a>资源类别的判断</h2><p>在<a href="http://cathole.top/2022/09/01/catasset-dev-summary-with-editor/">CatAsset开发总结：Editor篇</a>中提及过3种支持的资源类别：</p><ol><li><strong>内置资源包资源</strong></li><li><strong>内置原生资源</strong></li><li><strong>外置原生资源</strong></li></ol><p>CatAsset的<code>LoadAsse&lt;T&gt;</code>接口统一了3种类别的资源加载，使用者在加载资源时无需关心其所加载的资源的具体类别</p><p>内部判断资源类别的代码如下</p><h3 id="编辑器资源模式"><a href="#编辑器资源模式" class="headerlink" title="编辑器资源模式"></a>编辑器资源模式</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 获取编辑器资源模式下的资源类别</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AssetCategory <span class="title">GetAssetCategoryWithEditorMode</span>(<span class="params"><span class="built_in">string</span> assetName, Type assetType</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span> (assetName.StartsWith(<span class="string">&quot;Assets/&quot;</span>))</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="comment">//资源名以Assets/开头</span></span><br><span class="line">             <span class="keyword">if</span> (<span class="keyword">typeof</span>(UnityEngine.Object).IsAssignableFrom(assetType) || assetType == <span class="keyword">typeof</span>(<span class="built_in">object</span>))</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="comment">//以UnityEngine.Object及其派生类型或object为加载类型 </span></span><br><span class="line">                 <span class="comment">//都视为内置资源包资源进行加载</span></span><br><span class="line">                 <span class="keyword">return</span> AssetCategory.InternalBundleAsset;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="comment">//否则视为内置原生资源加载</span></span><br><span class="line">                 <span class="keyword">return</span> AssetCategory.InternalRawAsset;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="comment">//资源名不以Assets/开头 视为外置原生资源加载</span></span><br><span class="line">             <span class="keyword">return</span> AssetCategory.ExternalRawAsset;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>（注意：因为编辑器资源模式下无法准确判断以<strong>Assets/<strong>开头的路径加载资源时，是要加载</strong>内置资源包资源</strong>还是加载<strong>内置原生资源</strong>，所以只能规定当加载类型为<code>UnityEngine.Object</code>及其派生类型或<code>object</code>类型时视为内置资源包资源加载，不过这并不影响最终加载结果）</p><h3 id="非编辑器资源模式"><a href="#非编辑器资源模式" class="headerlink" title="非编辑器资源模式"></a>非编辑器资源模式</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 获取资源类别</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AssetCategory <span class="title">GetAssetCategory</span>(<span class="params"><span class="built_in">string</span> assetName</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (!assetName.StartsWith(<span class="string">&quot;Assets/&quot;</span>) &amp;&amp; !assetName.StartsWith(<span class="string">&quot;Packages/&quot;</span>))</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//资源名不以Assets/ 和 Packages/开头 是外置原生资源</span></span><br><span class="line">              <span class="keyword">return</span> AssetCategory.ExternalRawAsset;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          AssetRuntimeInfo assetRuntimeInfo = CatAssetDatabase.GetAssetRuntimeInfo(assetName);</span><br><span class="line">          <span class="keyword">if</span> (assetRuntimeInfo == <span class="literal">null</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              Debug.LogError(<span class="string">$&quot;GetAssetCategory调用失败，资源<span class="subst">&#123;assetName&#125;</span>的AssetRuntimeInfo为空&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">default</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (assetRuntimeInfo.BundleManifest.IsRaw)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//内置原生资源</span></span><br><span class="line">              <span class="keyword">return</span> AssetCategory.InternalRawAsset;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//内置资源包资源</span></span><br><span class="line">          <span class="keyword">return</span> AssetCategory.InternalBundleAsset;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="资源的加载"><a href="#资源的加载" class="headerlink" title="资源的加载"></a>资源的加载</h2><p>在得到资源类别后就可以进行后续的加载行为了</p><h3 id="编辑器资源模式-1"><a href="#编辑器资源模式-1" class="headerlink" title="编辑器资源模式"></a>编辑器资源模式</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">AssetCategory category;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">            <span class="keyword">if</span> (IsEditorMode)</span><br><span class="line">            &#123;</span><br><span class="line">                category = Util.GetAssetCategoryWithEditorMode(assetName, <span class="keyword">typeof</span>(T));</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">object</span> asset;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (category == AssetCategory.InternalBundleAsset)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//加载资源包资源</span></span><br><span class="line">                        Type assetType = <span class="keyword">typeof</span>(T);</span><br><span class="line">                        <span class="keyword">if</span> (assetType == <span class="keyword">typeof</span>(<span class="built_in">object</span>))</span><br><span class="line">                        &#123;</span><br><span class="line">                            assetType = <span class="keyword">typeof</span>(Object);</span><br><span class="line">                        &#125;</span><br><span class="line">                        asset = UnityEditor.AssetDatabase.LoadAssetAtPath(assetName,assetType);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;   </span><br><span class="line">                        <span class="comment">//加载原生资源</span></span><br><span class="line">                        <span class="keyword">if</span> (category == AssetCategory.ExternalRawAsset)</span><br><span class="line">                        &#123;</span><br><span class="line">                            assetName = Util.GetReadWritePath(assetName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    </span><br><span class="line">                        asset = File.ReadAllBytes(assetName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                catch (Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                    callback?.Invoke(<span class="literal">false</span>, <span class="literal">default</span>,<span class="literal">default</span>, userdata);</span><br><span class="line">                    <span class="keyword">throw</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                LoadAssetResult result = <span class="keyword">new</span> LoadAssetResult(asset, category);</span><br><span class="line">                callback?.Invoke(<span class="literal">true</span>, result.GetAsset&lt;T&gt;(),result, userdata);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">default</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>无论加载何种类别资源，最终都被封装进了<strong>资源加载结果（LoadAssetResult）</strong>中，并通过<code>result.GetAsset&lt;T&gt;</code>接口将其回调给使用者</p><h4 id="资源加载结果"><a href="#资源加载结果" class="headerlink" title="资源加载结果"></a>资源加载结果</h4><p><strong>资源加载结果（LoadAssetResult）</strong>是CatAsset对3种类别资源的统一封装，其代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> 资源加载结果</span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">struct</span> LoadAssetResult</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 已加载的原始资源实例</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">private</span> <span class="built_in">object</span> asset;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 资源类别</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> AssetCategory Category &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">LoadAssetResult</span>(<span class="params"><span class="built_in">object</span> asset, AssetCategory category</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">this</span>.asset = asset;</span><br><span class="line">          Category = category;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 获取已加载的原始资源实例</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">GetAsset</span>(<span class="params"></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">return</span> asset;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 获取已加载的指定类型资源实例</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> T <span class="title">GetAsset</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (asset == <span class="literal">null</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">default</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          Type type = <span class="keyword">typeof</span>(T);</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span> (type == <span class="keyword">typeof</span>(<span class="built_in">object</span>))</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span> (T)asset;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">switch</span> (Category)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">case</span> AssetCategory.InternalBundleAsset:</span><br><span class="line">                  <span class="keyword">if</span> (<span class="keyword">typeof</span>(UnityEngine.Object).IsAssignableFrom(type))</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="keyword">return</span> (T) asset;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                  &#123;</span><br><span class="line">                      Debug.LogError(<span class="string">$&quot;LoadAssetResult.GetAsset&lt;T&gt;调用失败，资源类别为<span class="subst">&#123;Category&#125;</span>，但是T为<span class="subst">&#123;type&#125;</span>&quot;</span>);</span><br><span class="line">                      <span class="keyword">return</span> <span class="literal">default</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              </span><br><span class="line">              <span class="keyword">case</span> AssetCategory.InternalRawAsset:</span><br><span class="line">              <span class="keyword">case</span> AssetCategory.ExternalRawAsset:</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (type == <span class="keyword">typeof</span>(<span class="built_in">byte</span>[]))</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="keyword">return</span> (T)asset;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  CustomRawAssetConverter converter = CatAssetManager.GetCustomRawAssetConverter(type);</span><br><span class="line">                  <span class="keyword">if</span> (converter == <span class="literal">null</span>)</span><br><span class="line">                  &#123;</span><br><span class="line">                      Debug.LogError(<span class="string">$&quot;LoadAssetResult.GetAsset&lt;T&gt;调用失败，没有注册类型<span class="subst">&#123;type&#125;</span>的CustomRawAssetConverter&quot;</span>);</span><br><span class="line">                      <span class="keyword">return</span> <span class="literal">default</span>;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="built_in">object</span> convertedAsset = converter((<span class="built_in">byte</span>[])asset);</span><br><span class="line">                  <span class="keyword">return</span> (T) convertedAsset;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          </span><br><span class="line">          <span class="keyword">return</span> <span class="literal">default</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>LoadAssetResult</code>的主要功能就是在调用<code>GetAsset&lt;T&gt;</code>时根据资源类别和指定的类型进行不同处理：</p><ol><li>如果指定类型为<code>object</code>，直接返回原始资源实例</li><li>如果资源类别为<strong>内置资源包资源</strong>，并且指定类型为<code>UnityEngine.Object</code>及其派生类型，则按指定类型返回原始资源实例，否则报错（因为资源包资源只能以<code>UnityEngine.Object</code>及其派生类型加载）</li><li>如果资源类别为<strong>内置/外置原生资源</strong>，并且指定类型为<code>byte[]</code>，直接返回原始资源实例（因为原生资源都是按照<code>byte[]</code>加载的），否则使用已注册的<strong>自定义原生资源转换器（CustomRawAssetConverter）</strong>将<code>byte[]</code>转换为指定类型并返回</li></ol><h4 id="自定义原生资源转换器"><a href="#自定义原生资源转换器" class="headerlink" title="自定义原生资源转换器"></a>自定义原生资源转换器</h4><p>想要统一对3种类别资源的使用，重点就在于<strong>统一资源包资源与原生资源的使用</strong>，在加载调用代码保持不变的情况下，即使所加载的资源从资源包资源变成了内置/外置原生资源，也能保证后续逻辑的正常运行</p><p>比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> assetName = ???;</span><br><span class="line">CatAssetManager.LoadAsset&lt;Sprite&gt;(assetName, <span class="literal">null</span>, callback);</span><br></pre></td></tr></table></figure><p>CatAsset所保证的即是无论上述代码中的<code>assetName</code>表示一个内置资源包资源，还是表示一个内置/外置原生资源，<code>callback</code>中的逻辑都无需关心这件事，而只需要处理加载得到的<code>Sprite</code>对象</p><p>想要做到这点就需要使用<strong>自定义原生资源转换器（CustomRawAssetConverter）</strong>，其是一个委托类型，将<code>byte[]</code>转换为<code>object</code>，定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 自定义原生资源转换方法的原型</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">object</span> <span class="title">CustomRawAssetConverter</span>(<span class="params"><span class="built_in">byte</span>[] bytes</span>)</span>;</span><br></pre></td></tr></table></figure><p>CatAsset默认提供了对<code>Texture2D</code>、<code>Sprite</code>、<code>TextAsset</code>的转换器：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">CatAssetManager</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RegisterCustomRawAssetConverter(<span class="keyword">typeof</span>(Texture2D),(bytes =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Texture2D texture2D = <span class="keyword">new</span> Texture2D(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        texture2D.LoadImage(bytes);</span><br><span class="line">        <span class="keyword">return</span> texture2D;</span><br><span class="line">    &#125;));</span><br><span class="line">    </span><br><span class="line">    RegisterCustomRawAssetConverter(<span class="keyword">typeof</span>(Sprite),(bytes =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Texture2D texture2D = <span class="keyword">new</span> Texture2D(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        texture2D.LoadImage(bytes);</span><br><span class="line">        Sprite sp = Sprite.Create(texture2D, <span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, texture2D.width, texture2D.height), Vector2.zero);</span><br><span class="line">        <span class="keyword">return</span> sp;</span><br><span class="line">    &#125;));</span><br><span class="line">    </span><br><span class="line">    RegisterCustomRawAssetConverter(<span class="keyword">typeof</span>(TextAsset),(bytes =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> text = Encoding.UTF8.GetString(bytes);</span><br><span class="line">        TextAsset textAsset = <span class="keyword">new</span> TextAsset(text);</span><br><span class="line">        <span class="keyword">return</span> textAsset;</span><br><span class="line">    &#125;));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非编辑器资源模式-1"><a href="#非编辑器资源模式-1" class="headerlink" title="非编辑器资源模式"></a>非编辑器资源模式</h3><p>在非编辑器资源模式下会根据资源类别使用不同的<strong>Task</strong>处理加载任务</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">category = Util.GetAssetCategory(assetName);</span><br><span class="line"><span class="keyword">if</span> (category == AssetCategory.ExternalRawAsset)</span><br><span class="line">&#123;</span><br><span class="line">    CatAssetDatabase.TryCreateExternalRawAssetRuntimeInfo(assetName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (category)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> AssetCategory.None:</span><br><span class="line">        callback?.Invoke(<span class="literal">false</span>, <span class="literal">default</span>,<span class="literal">default</span>, userdata);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> AssetCategory.InternalBundleAsset:</span><br><span class="line">        <span class="comment">//加载内置资源包资源</span></span><br><span class="line">        LoadBundleAssetTask&lt;T&gt; loadBundleAssetTask = LoadBundleAssetTask&lt;T&gt;.Create(loadTaskRunner, assetName, userdata, callback);</span><br><span class="line">        loadTaskRunner.AddTask(loadBundleAssetTask, priority);</span><br><span class="line">        <span class="keyword">return</span> loadBundleAssetTask.GUID;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> AssetCategory.InternalRawAsset:</span><br><span class="line">    <span class="keyword">case</span> AssetCategory.ExternalRawAsset:</span><br><span class="line">        <span class="comment">//加载原生资源</span></span><br><span class="line">        LoadRawAssetTask&lt;T&gt; loadRawAssetTask = LoadRawAssetTask&lt;T&gt;.Create(loadTaskRunner,assetName,category,userdata,callback);</span><br><span class="line">        loadTaskRunner.AddTask(loadRawAssetTask, priority);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loadRawAssetTask.GUID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在加载<strong>外置原生资源</strong>时，会尝试为此外置原生资源创建对应的清单信息和运行时信息，以进行统一管理</p><h4 id="资源包资源加载任务"><a href="#资源包资源加载任务" class="headerlink" title="资源包资源加载任务"></a>资源包资源加载任务</h4><p>**资源包资源加载任务(LoadBundleAssetTask)**是所有<code>Task</code>中最为复杂的，其将整个加载过程分为了6个阶段进行处理：</p><ol><li><strong>BundleLoading（资源包加载中）</strong></li><li><strong>BundleLoaded（资源包加载结束）</strong></li><li><strong>DependenciesLoading（依赖资源加载中）</strong></li><li><strong>DependenciesLoaded（依赖资源加载结束）</strong></li><li><strong>AssetLoading（资源加载中）</strong></li><li><strong>AssetLoaded（资源加载结束）</strong></li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (loadBundleAssetState)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> LoadBundleAssetState.BundleLoading:</span><br><span class="line">            <span class="comment">//1.资源包加载中</span></span><br><span class="line">            CheckStateWithBundleLoading();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> LoadBundleAssetState.BundleLoaded:</span><br><span class="line">            <span class="comment">//2.资源包加载结束，开始加载依赖资源</span></span><br><span class="line">            CheckStateWithBundleLoaded();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> LoadBundleAssetState.DependenciesLoading:</span><br><span class="line">            <span class="comment">//3.依赖资源加载中</span></span><br><span class="line">            CheckStateWithDependenciesLoading();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> LoadBundleAssetState.DependenciesLoaded:</span><br><span class="line">            <span class="comment">//4.依赖资源加载结束，开始加载主资源</span></span><br><span class="line">            CheckStateWithDependenciesLoaded();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> LoadBundleAssetState.AssetLoading:</span><br><span class="line">            <span class="comment">//5.检查主资源是否加载结束</span></span><br><span class="line">            CheckStateWithAssetLoading();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> LoadBundleAssetState.AssetLoaded:</span><br><span class="line">            <span class="comment">//6.主资源加载结束，检查是否加载成功</span></span><br><span class="line">            CheckStateWithAssetLoaded();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原生资源加载任务"><a href="#原生资源加载任务" class="headerlink" title="原生资源加载任务"></a>原生资源加载任务</h4><p>无论是内置还是外置的原生资源，都统一通过<strong>原生资源加载任务（LoadRawAssetTask）</strong>进行处理</p><p>由于原生资源无需处理资源包与依赖资源的加载，所以实现也比较简单，只被划分为了2个阶段：</p><ol><li><strong>Loading（资源加载中）</strong></li><li><strong>Loaded（资源加载结束）</strong></li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (loadRawAssetState)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> LoadRawAssetState.Loading:</span><br><span class="line">            <span class="comment">//加载中</span></span><br><span class="line">            CheckStateWithLoading();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> LoadRawAssetState.Loaded:</span><br><span class="line">            <span class="comment">//加载结束</span></span><br><span class="line">            CheckStateWithLoaded();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="资源卸载"><a href="#资源卸载" class="headerlink" title="资源卸载"></a>资源卸载</h1><p>资源的卸载需要调用<code>UnloadAsset</code>接口传入原始资源实例，并且<strong>卸载要与加载成对的调用</strong>，资源才能被正确卸载</p><h2 id="引用计数规则"><a href="#引用计数规则" class="headerlink" title="引用计数规则"></a>引用计数规则</h2><p>CatAsset通过引用计数来管理资源的卸载，其计数规则如下：</p><ul><li>每次调用<code>LoadAsset</code>或<code>UnloadAsset</code>时，将目标资源的引用计数+1或-1</li><li>当1个资源的引用计数从0变为1或从1变为0时，其直接依赖的资源的引用计数+1或-1</li></ul><p>举例来说，假设有<strong>资源A依赖B，B依赖C</strong>，那么调用1次<code>LoadAsset(A)</code>后的引用计数状态为：</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatAssetDevSummaryWithRuntime/CatAssetDevSummaryWithRuntime_02.png"></p><p>再调用2次<code>LoadAsset(A)</code></p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatAssetDevSummaryWithRuntime/CatAssetDevSummaryWithRuntime_03.png"></p><p>最后调用1次<code>LoadAsset(B)</code></p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatAssetDevSummaryWithRuntime/CatAssetDevSummaryWithRuntime_04.png"></p><p>现在开始按照加载调用的次数来调用卸载</p><p>调用3次<code>UnloadAsset(A)</code></p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatAssetDevSummaryWithRuntime/CatAssetDevSummaryWithRuntime_05.png"></p><p>由于A的引用计数变为了0，导致B的引用计数被-1</p><p>再调用1次<code>UnloadAsset(B)</code></p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatAssetDevSummaryWithRuntime/CatAssetDevSummaryWithRuntime_06.png"></p><p>由于B的引用计数变为了0，导致C的引用计数被-1，此时A、B、C的引用计数都正确归0了</p><h3 id="为什么不在每次加载或卸载资源时，都增加或减少目标资源所有依赖资源的引用计数？"><a href="#为什么不在每次加载或卸载资源时，都增加或减少目标资源所有依赖资源的引用计数？" class="headerlink" title="为什么不在每次加载或卸载资源时，都增加或减少目标资源所有依赖资源的引用计数？"></a>为什么不在每次加载或卸载资源时，都增加或减少目标资源所有依赖资源的引用计数？</h3><p>这样做也是可以的</p><p>目前的计数规则方案采取了<strong>【 主资源通过依赖加载，只对其直接依赖资源最多贡献1个引用计数】</strong>的原则</p><p>目的在于可以通过将1个资源的引用计数减去它被依赖加载的次数，得到它被主动加载的次数，从而方便查出一些因为使用者没有成对调用加载/卸载接口导致的资源无法被卸载的问题</p><p>用上面的例子来说，B的引用计数为2，因为被依赖加载的次数为1，两者相减就知道了B被主动加载的次数为1</p><h2 id="资源包资源的卸载"><a href="#资源包资源的卸载" class="headerlink" title="资源包资源的卸载"></a>资源包资源的卸载</h2><p>每当资源包资源的引用计数从0变为1或从1变为0时，就会从此资源所在资源包的<strong>使用中资源记录（UsedAssets）</strong>添加或删除</p><p>而当资源包的<code>UsedAssets</code>为空时，就会通过<strong>资源包卸载任务（UnloadBundleTask）</strong>开始卸载倒计时</p><p>在倒计时过程中，如果<code>UsedAssets</code>不为空，会马上结束<code>Task</code>的运行，反之则会在倒计时结束后，通过<code>AssetBundle.Unload(true)</code>来将资源包及其中已加载的资源<strong>真正的从内存中删除</strong></p><h2 id="原生资源的卸载"><a href="#原生资源的卸载" class="headerlink" title="原生资源的卸载"></a>原生资源的卸载</h2><p>对于原生资源而言，由于加载的只是<code>byte[]</code>对象，所以卸载也只是将缓存的<code>byte[]</code>对象引用置空而已</p><h1 id="资源更新"><a href="#资源更新" class="headerlink" title="资源更新"></a>资源更新</h1><h2 id="资源版本检查"><a href="#资源版本检查" class="headerlink" title="资源版本检查"></a>资源版本检查</h2><p>要进行资源的更新，需要先通过读取资源清单文件以进行版本检查</p><p>CatAsset通过检查<strong>只读区、读写区、远端</strong>三方的资源清单进行版本对比</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 检查版本</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CheckVersion</span>(<span class="params">OnVersionChecked callback</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isChecking)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    isChecking = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    onVersionChecked = callback;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//进行只读区 读写区 远端三方的资源清单检查</span></span><br><span class="line">    <span class="built_in">string</span> readOnlyManifestPath = Util.GetReadOnlyPath(Util.ManifestFileName);</span><br><span class="line">    <span class="built_in">string</span> readWriteManifestPath = Util.GetReadWritePath(Util.ManifestFileName);</span><br><span class="line">    <span class="built_in">string</span> remoteManifestPath = Util.GetRemotePath(Util.ManifestFileName);</span><br><span class="line">    </span><br><span class="line">    CatAssetManager.CheckUpdatableManifest(readOnlyManifestPath,CheckReadOnlyManifest);</span><br><span class="line">    CatAssetManager.CheckUpdatableManifest(readWriteManifestPath,CheckReadWriteManifest);</span><br><span class="line">    CatAssetManager.CheckUpdatableManifest(remoteManifestPath, CheckRemoteManifest);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在三方资源清单都读取到后，会为资源清单里记录的每一条资源清单信息建立对应的<strong>检查信息（CheckInfo）</strong>，并将资源清单信息赋值到此<code>CheckInfo</code>中</p><p>以检查只读区资源清单的回调方法为例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 检查只读区资源清单</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CheckReadOnlyManifest</span>(<span class="params"><span class="built_in">bool</span> success, UnityWebRequest uwr, <span class="built_in">object</span> userdata</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        isReadOnlyLoaded = <span class="literal">true</span>;</span><br><span class="line">        RefreshCheckInfos();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CatAssetManifest manifest = JsonParser.ParseJson&lt;CatAssetManifest&gt;(uwr.downloadHandler.text);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (BundleManifestInfo item <span class="keyword">in</span> manifest.Bundles)</span><br><span class="line">    &#123;</span><br><span class="line">        CheckInfo checkInfo = GetOrAddCheckInfo(item.RelativePath);</span><br><span class="line">        checkInfo.ReadOnlyInfo = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isReadOnlyLoaded = <span class="literal">true</span>;</span><br><span class="line">    RefreshCheckInfos();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在三方资源清单都读取完毕后，就会开始刷新<code>CheckInfo</code>的<strong>版本检查状态（CheckState）</strong>，然后根据<code>CheckState</code>进行后续处理</p><h3 id="版本检查状态"><a href="#版本检查状态" class="headerlink" title="版本检查状态"></a>版本检查状态</h3><p>CatAsset中定义了4种版本检查状态：</p><ol><li><strong>NeedUpdate（需要更新）</strong></li><li><strong>InReadWrite（最新版本存在于读写区）</strong></li><li><strong>InReadOnly（最新版本存在于只读区）</strong></li><li><strong>Disuse（已废弃）</strong></li></ol><p>其计算规则如下：</p><ol><li>如果此资源包不存在远端信息，则<code>State</code>为<code>Disuse</code>，并需要删除读写区那份</li><li>如果此资源包存在只读区信息，且和远端信息一致，则<code>State</code>为<code>InReadOnly</code>，并需要删除读写区那份</li><li>如果此资源包存在读写区信息，且和远端信息一致，则<code>State</code>为<code>InReadWrite</code></li><li>如果此资源包存在远端信息，但本地不存在，或本地信息与远端不一致，则<code>State</code>为<code>NeedUpdate</code>，并需要删除读写区那份</li></ol><p>具体代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> 版本检查信息</span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CheckInfo</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 资源包名</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">      </span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 版本检查状态</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> CheckState State;</span><br><span class="line">      </span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 是否需要删除此资源包存在于读写区的文件</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">bool</span> NeedRemove;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//此资源包的三方资源清单信息</span></span><br><span class="line">      <span class="keyword">public</span> BundleManifestInfo ReadOnlyInfo;</span><br><span class="line">      <span class="keyword">public</span> BundleManifestInfo ReadWriteInfo;</span><br><span class="line">      <span class="keyword">public</span> BundleManifestInfo RemoteInfo;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">CheckInfo</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          Name = name;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 刷新资源版本检查状态</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RefreshState</span>(<span class="params"></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (RemoteInfo == <span class="literal">null</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//此资源包不存在远端 需要删掉读写区那份（如果存在）</span></span><br><span class="line">              State = CheckState.Disuse;</span><br><span class="line">              NeedRemove = ReadWriteInfo != <span class="literal">null</span>;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (ReadOnlyInfo != <span class="literal">null</span> &amp;&amp; ReadOnlyInfo.Equals(RemoteInfo))</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//此资源包最新版本存在于只读区 需要删掉读写区那份（如果存在）</span></span><br><span class="line">              State = CheckState.InReadOnly;</span><br><span class="line">              NeedRemove = ReadWriteInfo != <span class="literal">null</span>;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (ReadWriteInfo != <span class="literal">null</span> &amp;&amp; ReadWriteInfo.Equals(RemoteInfo))</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//此资源包最新版本存在于读写区</span></span><br><span class="line">              State = CheckState.InReadWrite;</span><br><span class="line">              NeedRemove = <span class="literal">false</span>;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//此资源包存在于远端，但本地不是最新版本或本地不存在，需要删掉读写区那份（如果存在）并更新</span></span><br><span class="line">          State = CheckState.NeedUpdate;</span><br><span class="line">          NeedRemove = ReadWriteInfo != <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="刷新资源组与更新器信息"><a href="#刷新资源组与更新器信息" class="headerlink" title="刷新资源组与更新器信息"></a>刷新资源组与更新器信息</h2><p>在计算过CheckInfo的CheckState后，会根据CheckState刷新此资源的资源组信息（GroupInfo）及此资源的资源组更新器（GroupUpdater）</p><p>规则如下：</p><ol><li>对于<code>State</code>不为<code>Disuse</code>的资源，会添加到资源组的远端资源包信息中</li><li>如果<code>State</code>为<code>NeedUpdate</code>，会添加到对应的资源组更新器中</li><li>如果<code>State</code>为<code>InReadWrite</code>或<code>InReadOnly</code>，会添加到资源组的本地资源包信息中</li><li>如果此资源需要删除，则会从读写区删除，并重新生成读写区资源清单文件</li></ol><p>具体代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 刷新资源检查信息</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RefreshCheckInfos</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isReadOnlyLoaded || !isReadWriteLoaded || !isRemoteLoaded)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//三方资源清单未加载完毕</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要更新的所有资源包的数量与长度</span></span><br><span class="line">    <span class="built_in">int</span> totalCount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">long</span> totalLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> needGenerateReadWriteManifest = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (KeyValuePair&lt;<span class="built_in">string</span>,CheckInfo&gt; pair <span class="keyword">in</span> checkInfoDict)</span><br><span class="line">    &#123;</span><br><span class="line">        CheckInfo checkInfo = pair.Value;</span><br><span class="line">        checkInfo.RefreshState();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkInfo.State != CheckState.Disuse)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//添加资源组的远端资源包信息</span></span><br><span class="line">            GroupInfo groupInfo = CatAssetDatabase.GetOrAddGroupInfo(checkInfo.RemoteInfo.Group);</span><br><span class="line">            groupInfo.AddRemoteBundle(checkInfo.RemoteInfo.RelativePath);</span><br><span class="line">            groupInfo.RemoteCount++;</span><br><span class="line">            groupInfo.RemoteLength += checkInfo.RemoteInfo.Length;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> (checkInfo.State)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> CheckState.NeedUpdate:</span><br><span class="line">                <span class="comment">//需要更新</span></span><br><span class="line">                totalCount++;</span><br><span class="line">                totalLength += checkInfo.RemoteInfo.Length;</span><br><span class="line"></span><br><span class="line">                GroupUpdater groupUpdater = CatAssetUpdater.GetOrAddGroupUpdater(checkInfo.RemoteInfo.Group);</span><br><span class="line">                groupUpdater.AddUpdateBundle(checkInfo.RemoteInfo);</span><br><span class="line">                groupUpdater.TotalCount++;</span><br><span class="line">                groupUpdater.TotalLength += checkInfo.RemoteInfo.Length;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> CheckState.InReadWrite:</span><br><span class="line">                <span class="comment">//不需要更新 最新版本存在于读写区</span></span><br><span class="line">                </span><br><span class="line">                GroupInfo groupInfo = CatAssetDatabase.GetOrAddGroupInfo(checkInfo.ReadWriteInfo.Group);</span><br><span class="line">                groupInfo.AddLocalBundle(checkInfo.ReadWriteInfo.RelativePath);</span><br><span class="line">                groupInfo.LocalCount++;</span><br><span class="line">                groupInfo.LocalLength += checkInfo.ReadWriteInfo.Length;</span><br><span class="line">                </span><br><span class="line">                CatAssetDatabase.InitRuntimeInfo(checkInfo.ReadWriteInfo,<span class="literal">true</span>);</span><br><span class="line">                CatAssetUpdater.AddReadWriteManifestInfo(checkInfo.ReadWriteInfo);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> CheckState.InReadOnly:</span><br><span class="line">                <span class="comment">//不需要更新 最新版本存在于只读区</span></span><br><span class="line"></span><br><span class="line">                groupInfo = CatAssetDatabase.GetOrAddGroupInfo(checkInfo.ReadOnlyInfo.Group);</span><br><span class="line">                groupInfo.AddLocalBundle(checkInfo.ReadOnlyInfo.RelativePath);</span><br><span class="line">                groupInfo.LocalCount++;</span><br><span class="line">                groupInfo.LocalLength += checkInfo.ReadOnlyInfo.Length;</span><br><span class="line">                </span><br><span class="line">                CatAssetDatabase.InitRuntimeInfo(checkInfo.ReadOnlyInfo,<span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkInfo.NeedRemove)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//需要删除读写区的那份</span></span><br><span class="line">            Debug.Log(<span class="string">$&quot;删除读写区资源:<span class="subst">&#123;checkInfo.Name&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="built_in">string</span> path = Util.GetReadWritePath(checkInfo.Name);</span><br><span class="line">            File.Delete(path);</span><br><span class="line"></span><br><span class="line">            needGenerateReadWriteManifest = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needGenerateReadWriteManifest)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//删除过读写区资源 需要重新生成读写区资源清单</span></span><br><span class="line">        CatAssetUpdater.GenerateReadWriteManifest();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用版本检查完毕回调</span></span><br><span class="line">    VersionCheckResult result = <span class="keyword">new</span> VersionCheckResult(<span class="built_in">string</span>.Empty,totalCount, totalLength);</span><br><span class="line">    onVersionChecked?.Invoke(result);</span><br><span class="line">        </span><br><span class="line">    Clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="资源的更新"><a href="#资源的更新" class="headerlink" title="资源的更新"></a>资源的更新</h2><p>资源更新是以资源组为单位进行的，在启动<strong>资源组更新器（GroupUpdater）</strong>后，会根据此资源组需要更新的资源创建<strong>资源包下载任务（DownloadBundleTask）</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 更新资源组</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">UpdateGroup</span>(<span class="params">OnBundleUpdated callback</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (State != GroupUpdaterState.Free)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//非空闲状态 不处理</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    State = GroupUpdaterState.Running;</span><br><span class="line">    <span class="keyword">foreach</span> (BundleManifestInfo info <span class="keyword">in</span> updateBundles)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建下载文件的任务</span></span><br><span class="line">        <span class="built_in">string</span> localFilePath = Util.GetReadWritePath(info.RelativePath);</span><br><span class="line">        <span class="built_in">string</span> downloadUri = Path.Combine(CatAssetUpdater.UpdateUriPrefix, info.RelativePath);</span><br><span class="line">        CatAssetManager.DownloadBundle(<span class="keyword">this</span>,info,downloadUri,localFilePath,onBundleDownloaded);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    onBundleUpdated = callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 下载资源包</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DownloadBundle</span>(<span class="params">GroupUpdater groupUpdater, BundleManifestInfo info,<span class="built_in">string</span> downloadUri,<span class="built_in">string</span> localFilePath,DownloadBundleCallback callback</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DownloadBundleTask task =</span><br><span class="line">        DownloadBundleTask.Create(downloadTaskRunner, downloadUri, info, groupUpdater, downloadUri, localFilePath, callback);</span><br><span class="line">    downloadTaskRunner.AddTask(task,TaskPriority.Height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="资源包下载任务"><a href="#资源包下载任务" class="headerlink" title="资源包下载任务"></a>资源包下载任务</h3><p><strong>资源包下载任务（DownloadBundleTask）</strong>通过<code>UnityWebRequest</code>和<code>DownloadHandlerFile</code>实现了低GC的文件下载，并且在启动时会通过检查本地已下载文件的字节长度进行断点续传操作</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (groupUpdater.State == GroupUpdaterState.Paused)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//处理下载暂停 暂停只对还未开始执行的下载任务有效</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始位置</span></span><br><span class="line">    <span class="built_in">int</span> startLength = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先检查本地是否已存在临时下载文件</span></span><br><span class="line">    <span class="keyword">if</span> (File.Exists(localTempFilePath))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (FileStream fs = File.OpenWrite(localTempFilePath))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//检查已下载的字节数</span></span><br><span class="line">            fs.Seek(<span class="number">0</span>, SeekOrigin.End);</span><br><span class="line">            startLength = (<span class="built_in">int</span>)fs.Length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    UnityWebRequest uwr = <span class="keyword">new</span> UnityWebRequest(downloadUri);</span><br><span class="line">    <span class="keyword">if</span> (startLength &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//处理断点续传</span></span><br><span class="line">        uwr.SetRequestHeader(<span class="string">&quot;Range&quot;</span>, <span class="string">$&quot;bytes=&#123;&#123;<span class="subst">&#123;startLength&#125;</span>&#125;&#125;-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    uwr.downloadHandler = <span class="keyword">new</span> DownloadHandlerFile(localTempFilePath, startLength &gt; <span class="number">0</span>);</span><br><span class="line">    op = uwr.SendWebRequest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重试与校验"><a href="#重试与校验" class="headerlink" title="重试与校验"></a>重试与校验</h3><p>在下载失败后会尝试重新下载</p><p>如果下载成功了会先校验文件长度，若长度相同再校验MD5值，校验失败则会删除下载文件并尝试重新下载</p><p>校验都通过后会认为下载成功，并回调结果给使用者</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//被暂停了</span></span><br><span class="line">        State = TaskState.Free;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!op.webRequest.isDone)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//下载中</span></span><br><span class="line">        State = TaskState.Running;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (op.webRequest.result == UnityWebRequest.Result.ConnectionError || op.webRequest.result == UnityWebRequest.Result.ProtocolError)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//下载失败 重试</span></span><br><span class="line">        <span class="keyword">if</span> (RetryDownload())</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">$&quot;下载失败准备重试：<span class="subst">&#123;Name&#125;</span>,错误信息：<span class="subst">&#123;op.webRequest.error&#125;</span>，当前重试次数：<span class="subst">&#123;retriedCount&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//重试次数达到上限 通知失败</span></span><br><span class="line">            Debug.LogError(<span class="string">$&quot;重试次数达到上限：<span class="subst">&#123;Name&#125;</span>,错误信息：<span class="subst">&#123;op.webRequest.error&#125;</span>，当前重试次数：<span class="subst">&#123;retriedCount&#125;</span>&quot;</span>);</span><br><span class="line">            State = TaskState.Finished;</span><br><span class="line">            onFinished?.Invoke(<span class="literal">false</span> ,bundleManifestInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下载成功 开始校验</span></span><br><span class="line">    <span class="comment">//先对比文件长度</span></span><br><span class="line">    FileInfo fi = <span class="keyword">new</span> FileInfo(localTempFilePath);</span><br><span class="line">    <span class="built_in">bool</span> isVerify = fi.Length == bundleManifestInfo.Length;</span><br><span class="line">    <span class="keyword">if</span> (isVerify)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//文件长度对得上 再校验MD5</span></span><br><span class="line">        <span class="built_in">string</span> md5 = Util.GetFileMD5(localTempFilePath);</span><br><span class="line">        isVerify = md5 == bundleManifestInfo.MD5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isVerify)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//校验失败 删除临时下载文件 尝试重新下载</span></span><br><span class="line">        File.Delete(localTempFilePath);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (RetryDownload())</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">$&quot;校验失败准备重试：<span class="subst">&#123;Name&#125;</span>，当前重试次数：<span class="subst">&#123;retriedCount&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//重试次数达到上限 通知失败</span></span><br><span class="line">            Debug.LogError(<span class="string">$&quot;重试次数达到上限：<span class="subst">&#123;Name&#125;</span>，当前重试次数：<span class="subst">&#123;retriedCount&#125;</span>&quot;</span>);</span><br><span class="line">            State = TaskState.Finished;</span><br><span class="line">            onFinished?.Invoke(<span class="literal">false</span> ,bundleManifestInfo);</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//校验成功</span></span><br><span class="line">    State = TaskState.Finished;</span><br><span class="line">            </span><br><span class="line">    <span class="comment">//将临时下载文件覆盖到正式文件上</span></span><br><span class="line">    <span class="keyword">if</span> (File.Exists(localFilePath))</span><br><span class="line">    &#123;</span><br><span class="line">        File.Delete(localFilePath);</span><br><span class="line">    &#125;</span><br><span class="line">    File.Move(localTempFilePath, localFilePath);</span><br><span class="line">    onFinished?.Invoke(<span class="literal">true</span>,bundleManifestInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重新生成读写区资源清单"><a href="#重新生成读写区资源清单" class="headerlink" title="重新生成读写区资源清单"></a>重新生成读写区资源清单</h3><p>在<code>GroupUpdater</code>的<code>OnBundleDownloaded</code>回调被调用时，会刷新自身保存的已下载资源信息，并且在所有资源下载完毕或已下载字节数达到要求后，重新生成读写区资源清单</p><p>而如果都成功更新完了，就会将自身移除掉，否则将会等待下一次启动更新器</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 资源包下载完毕的回调</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnBundleDownloaded</span>(<span class="params"><span class="built_in">bool</span> success, BundleManifestInfo info</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    callbackCount++;</span><br><span class="line">    <span class="keyword">if</span> (callbackCount == TotalCount)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//所有需要下载的资源包都回调过 就将状态改为Free</span></span><br><span class="line">        <span class="comment">//若此时有下载失败的资源包，导致UpdatedCount &lt; TotalCount，则可通过重新启动此Updater来进行下载</span></span><br><span class="line">        State = GroupUpdaterState.Free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BundleUpdateResult result;</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="string">$&quot;更新<span class="subst">&#123;info.RelativePath&#125;</span>失败&quot;</span>);</span><br><span class="line">        result = <span class="keyword">new</span> BundleUpdateResult(<span class="literal">false</span>,info.RelativePath,<span class="keyword">this</span>);</span><br><span class="line">        onBundleUpdated?.Invoke(result);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateBundles.Remove(info);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//刷新已下载资源信息</span></span><br><span class="line">    UpdatedCount++;</span><br><span class="line">    UpdatedLength += info.Length;</span><br><span class="line">    deltaUpdatedLength += info.Length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将下载好的资源包的运行时信息添加到CatAssetDatabase中</span></span><br><span class="line">    CatAssetDatabase.InitRuntimeInfo(info, <span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//刷新读写区资源信息列表</span></span><br><span class="line">    CatAssetUpdater.AddReadWriteManifestInfo(info);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//刷新资源组本地资源信息</span></span><br><span class="line">    GroupInfo groupInfo = CatAssetDatabase.GetOrAddGroupInfo(info.Group);</span><br><span class="line">    groupInfo.AddLocalBundle(info.RelativePath);</span><br><span class="line">    groupInfo.LocalCount++;</span><br><span class="line">    groupInfo.LocalLength += info.Length;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bool</span> allDownloaded = UpdatedCount &gt;= TotalCount;</span><br><span class="line">    <span class="keyword">if</span> (allDownloaded || deltaUpdatedLength &gt;= generateManifestLength)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//资源下载完毕 或者已下载字节数达到要求 就重新生成一次读写区资源清单</span></span><br><span class="line">        deltaUpdatedLength = <span class="number">0</span>;</span><br><span class="line">        CatAssetUpdater.GenerateReadWriteManifest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (allDownloaded)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//该组资源都更新完毕，可以删掉updater了</span></span><br><span class="line">        CatAssetUpdater.RemoveGroupUpdater(GroupName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用外部回调</span></span><br><span class="line">    result = <span class="keyword">new</span> BundleUpdateResult(<span class="literal">true</span>,info.RelativePath,<span class="keyword">this</span>);</span><br><span class="line">    onBundleUpdated?.Invoke(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
          <category> 开发总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CatAsset开发总结：Editor篇</title>
      <link href="/2022/09/01/catasset-dev-summary-with-editor/"/>
      <url>/2022/09/01/catasset-dev-summary-with-editor/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要用于总结<a href="https://github.com/CatImmortal/CatAsset">CatAsset</a>在Editor部分的设计思路</p><p>代码结构如下：</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatAssetDevSummaryWithEditor/CatAssetDevSummaryWithEditor_01.png"></p><ul><li>BuildInfo：包含用于保存资源构建相关信息的数据结构</li><li>BuidPipeline：包含基于ScriptableBuildPipeline的资源构建管线实现</li><li>Config：包含与资源构建相关的配置</li><li>Misc：包含循环依赖分析器、冗余资源分析器与一些工具类的代码</li><li>Rule：包含应用于资源目录的构建规则的接口与实现</li><li>Window：包含资源包构建窗口与运行时信息窗口的编辑器窗口类代码</li></ul><h1 id="构建信息"><a href="#构建信息" class="headerlink" title="构建信息"></a>构建信息</h1><p>构建信息分为2种：</p><ol><li><code>AssetBuildInfo</code>（资源构建信息）</li><li><code>BundBuildInfo</code>（资源包构建信息）</li></ol><p><code>AssetBuildInfo</code>表示单个资源的构建信息：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> 资源构建信息</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">   [<span class="meta">Serializable</span>]</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AssetBuildInfo</span> : <span class="title">IComparable</span>&lt;<span class="title">AssetBuildInfo</span>&gt;,<span class="title">IEquatable</span>&lt;<span class="title">AssetBuildInfo</span>&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 资源名</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 资源类型名</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">string</span> TypeName;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> Type type;</span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 资源类型</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">public</span> Type Type =&gt; type ??= AssetDatabase.GetMainAssetTypeAtPath(Name);</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 资源文件长度</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">long</span> Length;</span><br><span class="line">      </span><br><span class="line">       <span class="comment">//省略...</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>BundleBuildInfo</code>用于表示资源包级别的构建信息：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> 资源包构建信息</span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">  [<span class="meta">Serializable</span>]</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BundleBuildInfo</span> : <span class="title">IComparable</span>&lt;<span class="title">BundleBuildInfo</span>&gt;,<span class="title">IEquatable</span>&lt;<span class="title">BundleBuildInfo</span>&gt;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 相对路径</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">string</span> RelativePath;</span><br><span class="line">      </span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 目录名</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">string</span> DirectoryName;</span><br><span class="line">      </span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 资源包名</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">string</span> BundleName;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 资源组</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">string</span> Group;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 是否为原生资源包</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">bool</span> IsRaw;</span><br><span class="line">      </span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 总资源长度</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">long</span> AssetsLength;</span><br><span class="line">      </span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 资源构建信息列表</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">List</span>&lt;<span class="title">AssetBuildInfo</span>&gt; Assets</span> = <span class="keyword">new</span> List&lt;AssetBuildInfo&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 获取用于构建资源包的AssetBundleBuild</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> AssetBundleBuild <span class="title">GetAssetBundleBuild</span>(<span class="params"></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          AssetBundleBuild bundleBuild = <span class="keyword">new</span> AssetBundleBuild</span><br><span class="line">          &#123;</span><br><span class="line">              assetBundleName = RelativePath</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          List&lt;<span class="built_in">string</span>&gt; assetNames = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">          <span class="keyword">foreach</span> (AssetBuildInfo assetBuildInfo <span class="keyword">in</span> Assets)</span><br><span class="line">          &#123;</span><br><span class="line">              assetNames.Add(assetBuildInfo.Name);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          bundleBuild.assetNames = assetNames.ToArray();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> bundleBuild;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//省略...</span></span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line">      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>BuildBundleInfo</code>除了保存必要的构建信息外，还提供了从资源构建信息中生成用于构建<code>AssetBundle</code>的<code>AssetBundleBuild</code>的接口</p><h1 id="资源类别"><a href="#资源类别" class="headerlink" title="资源类别"></a>资源类别</h1><p><code>BundleBuildInfo</code>中有一个<strong>IsRaw</strong>字段来区分当前<strong>Bundle</strong>是否为原生资源的<strong>Bundle</strong></p><p>这里需要引入对资源类别的划分，CatAsset通过2个维度划分了3种资源类别：</p><table><thead><tr><th></th><th>内置资源（通过CatAsset构建）</th><th>外置资源（不通过CatAsset构建）</th></tr></thead><tbody><tr><td>资源包资源（需要构建为AssetBundle的资源）</td><td>内置资源包资源</td><td></td></tr><tr><td>原生资源（直接使用本体的资源）</td><td>内置原生资源</td><td>外置原生资源</td></tr></tbody></table><p>CatAsset的Runtime接口统一了这3种类别资源的使用，使用者在使用资源时只需要路径符合规范，无需关心具体资源类别</p><h2 id="为什么没有外置资源包资源这一类别？"><a href="#为什么没有外置资源包资源这一类别？" class="headerlink" title="为什么没有外置资源包资源这一类别？"></a>为什么没有外置资源包资源这一类别？</h2><p>如果一个<strong>AssetBundle</strong>不是通过CatAsset进行构建的，那么是无法对其进行统一管理的</p><h2 id="Mod资源是哪一种类别？"><a href="#Mod资源是哪一种类别？" class="headerlink" title="Mod资源是哪一种类别？"></a>Mod资源是哪一种类别？</h2><p>如果要为游戏提供Mod功能，那么对于Mod资源的处理可以使用2种方案：</p><p>1.基于外置原生资源的方案：将Mod资源限制在图片、文本、音频等可以直接从二进制构造的资源类型，Mod开发者将编辑好的资源文件本体直接放入读写区内，此方案优点是Mod开发门槛低，上手简单，但缺点是支持的资源类型少</p><p>2.基于导入内置资源包的方案：Mod开发者通过Unity编辑好资源后，使用CatAsset进行资源包构建，然后通过CatAsset提供的从外部导入资源包接口（详见<a href="http://cathole.top/2022/08/30/catasset-guide/">CatAsset使用教程</a>中<strong>导入外部的资源包</strong>一节）来将Mod资源包信息导入<code>CatAssetManager</code>中，以实现对Mod资源的加载，此方案缺点是Mod开发门槛高，上手略微复杂，但优点是支持全部的资源类型</p><h1 id="资源目录与构建规则"><a href="#资源目录与构建规则" class="headerlink" title="资源目录与构建规则"></a>资源目录与构建规则</h1><p>要想生成构建信息，就需要通过指定<strong>资源目录</strong>与其所使用的<strong>构建规则</strong>进行</p><p>构建规则接口<code>IBundleBuildRule</code>定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 资源包构建规则接口</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IBundleBuildRule</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 此规则所构建的是否为原生资源包</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="built_in">bool</span> IsRaw &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取使用此规则构建的资源包构建信息列表</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function">List&lt;BundleBuildInfo&gt; <span class="title">GetBundleList</span>(<span class="params">BundleBuildDirectory bundleBuildDirectory</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前CatAsset内置了4种构建规则：</p><ol><li><code>NAssetToNBundle</code>（将指定目录下所有资源分别构建为一个资源包）</li><li><code>NAssetToNRawBundle</code>（将指定目录下所有资源分别构建为一个原生资源包）</li><li><code>NAssetToOneBundle</code>（将指定目录下所有资源构建为一个资源包）</li><li><code>NAssetToOneBundleWithTopDirectory</code>（将指定目录下所有一级子目录各自使用<code>NAssetToOneBundle</code>规则进行构建）</li></ol><h2 id="原生资源的特殊性"><a href="#原生资源的特殊性" class="headerlink" title="原生资源的特殊性"></a>原生资源的特殊性</h2><p>对于原生资源而言，其不会被加入到<strong>AssetBundle</strong>的构建中，而是直接使用其资源文件本体并以二进制格式加载，所以也就不存在一个物理意义上的资源包文件</p><p>但是为了方便进行统一管理，CatAsset会在构建原生资源时，为其虚拟一个<code>BundleBuildInfo</code>，并将<strong>BundleName</strong>设置为此原生资源的文件名：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> assetsDir = Util.FullNameToAssetName(file.Directory.FullName); <span class="comment">//Assets/xxx</span></span><br><span class="line">                  <span class="built_in">string</span> directoryName = assetsDir.Substring(assetsDir.IndexOf(<span class="string">&quot;/&quot;</span>) + <span class="number">1</span>); <span class="comment">//去掉Assets/</span></span><br><span class="line">                  <span class="built_in">string</span> bundleName;</span><br><span class="line">                  <span class="keyword">if</span> (!isRaw)</span><br><span class="line">                  &#123; </span><br><span class="line">                      bundleName = file.Name.Replace(<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;_&#x27;</span>).ToLower() + <span class="string">&quot;.bundle&quot;</span>; </span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="comment">//直接以文件名作为原生资源包名</span></span><br><span class="line">                      bundleName = file.Name;</span><br><span class="line">                  &#125;</span><br><span class="line">                  </span><br><span class="line">                  BundleBuildInfo bundleBuildInfo =</span><br><span class="line">                      <span class="keyword">new</span> BundleBuildInfo(directoryName,bundleName, <span class="keyword">group</span>, isRaw);</span><br></pre></td></tr></table></figure><p>也因此，1个原生资源包的<code>BundleBuildInfo</code>固定只会包含1个原生资源的<code>AssetBuildInfo</code></p><p><em>（可以理解为原生资源 = 原生资源包）</em></p><h1 id="生成构建信息"><a href="#生成构建信息" class="headerlink" title="生成构建信息"></a>生成构建信息</h1><p>在指定好资源目录与构建规则后，即可生成构建信息，生成后的构建信息被保存在<strong>BundleBuildConfig.asset</strong>文件中</p><p>CatAsset将构建信息的生成分为6个步骤：</p><ol><li><p><strong>初始化资源包构建规则</strong></p></li><li><p><strong>根据构建规则初始化资源包构建信息</strong></p></li><li><p><strong>将隐式依赖转为显式构建资源</strong></p></li><li><p><strong>冗余资源分析</strong></p></li><li><p><strong>分割场景资源包中的非场景资源</strong></p></li><li><p><strong>初始化原生资源包构建信息</strong></p></li></ol><h2 id="初始化资源包构建规则"><a href="#初始化资源包构建规则" class="headerlink" title="初始化资源包构建规则"></a>初始化资源包构建规则</h2><p>此步骤通过反射来创建已实现的构建规则对象</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 初始化资源包构建规则字典</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitRuleDict</span>(<span class="params"></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          Type[] types = <span class="keyword">typeof</span>(BundleBuildConfigSO).Assembly.GetTypes();</span><br><span class="line">          <span class="keyword">foreach</span> (Type type <span class="keyword">in</span> types)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span> (!type.IsInterface &amp;&amp; <span class="keyword">typeof</span>(IBundleBuildRule).IsAssignableFrom(type) &amp;&amp;</span><br><span class="line">                  !ruleDict.ContainsKey(type.Name))</span><br><span class="line">              &#123;</span><br><span class="line">                  IBundleBuildRule rule = (IBundleBuildRule) Activator.CreateInstance(type);</span><br><span class="line">                  ruleDict.Add(type.Name, rule);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="根据构建规则初始化资源包构建信息"><a href="#根据构建规则初始化资源包构建信息" class="headerlink" title="根据构建规则初始化资源包构建信息"></a>根据构建规则初始化资源包构建信息</h2><p>此步骤通过在资源目录上调用对应构建规则，以获得初始的<code>BundleBuildInfo</code>列表</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 根据构建规则获取初始的资源包构建信息列表</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitBundleBuildInfo</span>(<span class="params"><span class="built_in">bool</span> isRaw</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; Directories.Count; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              BundleBuildDirectory bundleBuildDirectory = Directories[i];</span><br><span class="line"></span><br><span class="line">              IBundleBuildRule rule = ruleDict[bundleBuildDirectory.BuildRuleName];</span><br><span class="line">              <span class="keyword">if</span> (rule.IsRaw == isRaw)</span><br><span class="line">              &#123;</span><br><span class="line">                  List&lt;BundleBuildInfo&gt; bundles = rule.GetBundleList(bundleBuildDirectory);</span><br><span class="line">                  Bundles.AddRange(bundles);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><em>（此步骤不初始化原生资源包的构建信息）</em></p><h2 id="将隐式依赖转为显式构建资源"><a href="#将隐式依赖转为显式构建资源" class="headerlink" title="将隐式依赖转为显式构建资源"></a>将隐式依赖转为显式构建资源</h2><p><strong>隐式依赖</strong>：若资源A依赖资源B，资源A出现在初始资源包构建信息列表中但是资源B没有，那么就称资源B为资源A的隐式依赖</p><p>因为CatAsset Runtime部分的依赖管理是基于<strong>Asset</strong>的（关于此方面的探讨见<a href="http://cathole.top/2021/10/29/dependency-manage-compare/">Unity资源框架设计中不同级别依赖管理的对比</a>），所有<strong>依赖Asset</strong>都要通过框架加载，所以必须在这一个步骤中将隐式依赖都找出来，和依赖其的资源一并构建进同一个资源包中</p><h2 id="冗余资源分析"><a href="#冗余资源分析" class="headerlink" title="冗余资源分析"></a>冗余资源分析</h2><p>在上述步骤中，如果资源A、B同时隐式依赖资源C，并且A、B并未被构建进同一个资源包中，那么C就会被分别构建进A和B所在的资源包中，从而产生资源冗余的问题</p><p>此步骤便会将冗余资源单独构建进额外创建的冗余资源包中</p><p>由于CatAsset的卸载机制是基于资源包的卸载（只会在资源包卸载时才会真正将从此资源包中加载的资源从内存中删除），所以会尽量按照冗余资源间的关联性进行资源包划分，以保证冗余资源及依赖其的资源在生命周期上的一致性</p><p>举例来说</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatAssetDevSummaryWithEditor/CatAssetDevSummaryWithEditor_02.png"></p><p>在上图中，冗余资源X、Y会被划分为同一个资源包，Z则是另一个资源包</p><p>具体做法为遍历所有冗余资源，从被遍历的每一个冗余资源出发去搜索其他所有可达冗余资源（如果在之前已被搜索过则忽略），搜索结束后将所有记录到的冗余资源划分为同一个冗余资源包</p><h2 id="分割场景资源包中的非场景资源"><a href="#分割场景资源包中的非场景资源" class="headerlink" title="分割场景资源包中的非场景资源"></a>分割场景资源包中的非场景资源</h2><p>在将隐式依赖转换为显式构建资源后，可能出现场景资源和非场景资源被放进了同一个资源包的情况</p><p>而这是Unity不允许的，会在构建资源包时报错，所以需要在此步骤将其拆开</p><h2 id="初始化原生资源包构建信息"><a href="#初始化原生资源包构建信息" class="headerlink" title="初始化原生资源包构建信息"></a>初始化原生资源包构建信息</h2><p>如果出现普通资源包中的资源依赖原生资源（一般来说很少出现这种情况），那么需要冗余一份原生资源到普通资源包中，因为本质上原生资源是不从<strong>AssetBundle</strong>加载的，只作为二进制数据被加载，所以依赖加载是无效的</p><p>这里将原生资源包的构建放到最后处理，这样通过前面的隐式依赖转换为显式构建资源这一步骤就可以达成原生资源在依赖它的普通资源包中的冗余了</p><h1 id="循环依赖分析"><a href="#循环依赖分析" class="headerlink" title="循环依赖分析"></a>循环依赖分析</h1><p>CatAsset提供了基于资源的与基于资源包的循环依赖分析功能</p><p>做法也很简单，通过对资源/资源包的依赖进行深度搜索，在搜索过程中记录当前依赖链，如果出现重复记录则意味着依赖链是环状的，也就是出现了循环依赖</p><h1 id="资源构建管线"><a href="#资源构建管线" class="headerlink" title="资源构建管线"></a>资源构建管线</h1><p>CatAsset的资源构建管线基于ScriptableBuildPipeline实现</p><h2 id="默认构建任务"><a href="#默认构建任务" class="headerlink" title="默认构建任务"></a>默认构建任务</h2><p>在SBP原有的Task基础，增加了自定义的Task：</p><ol><li><code>BuildRawBundles</code>（构建原生资源包）</li><li><code>BuildManifest</code>（构建资源清单）</li><li><code>WriteManifestFile</code>（写入资源清单文件）</li><li><code>CopyToReadOnlyDirectory</code>（复制指定资源组的资源到只读目录下）</li></ol><p>执行顺序为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加构建任务</span></span><br><span class="line">         IList&lt;IBuildTask&gt; taskList = DefaultBuildTasks.Create(DefaultBuildTasks.Preset.AssetBundleCompatible);</span><br><span class="line">         taskList.Add(<span class="keyword">new</span> BuildRawBundles());</span><br><span class="line">         taskList.Add(<span class="keyword">new</span> BuildManifest());</span><br><span class="line">         taskList.Add(<span class="keyword">new</span> WriteManifestFile());</span><br><span class="line">         <span class="keyword">if</span> (bundleBuildConfig.IsCopyToReadOnlyDirectory &amp;&amp; bundleBuildConfig.TargetPlatforms.Count == <span class="number">1</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="comment">//需要复制资源包到只读目录下</span></span><br><span class="line">             taskList.Add(<span class="keyword">new</span> CopyToReadOnlyDirectory());</span><br><span class="line">             taskList.Add(<span class="keyword">new</span> WriteManifestFile());</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><h3 id="BuildRawBundles"><a href="#BuildRawBundles" class="headerlink" title="BuildRawBundles"></a>BuildRawBundles</h3><p>此Task直接将原生资源复制到指定路径之下</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历原生资源包列表</span></span><br><span class="line">            <span class="keyword">foreach</span> (BundleBuildInfo rawBundleBuildInfo <span class="keyword">in</span> rawBundleBuilds)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> rawAssetName = rawBundleBuildInfo.Assets[<span class="number">0</span>].Name;</span><br><span class="line">                <span class="built_in">string</span> rawBundleDirectory = Path.Combine(directory, rawBundleBuildInfo.DirectoryName.ToLower());</span><br><span class="line">                <span class="keyword">if</span> (!Directory.Exists(rawBundleDirectory))</span><br><span class="line">                &#123;</span><br><span class="line">                    Directory.CreateDirectory(rawBundleDirectory);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">string</span> targetFileName = Path.Combine(directory, rawBundleBuildInfo.RelativePath);</span><br><span class="line">                File.Copy(rawAssetName, targetFileName); <span class="comment">//直接将原生资源复制过去</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h3 id="BuildManifest"><a href="#BuildManifest" class="headerlink" title="BuildManifest"></a>BuildManifest</h3><p>此Task负责创建出<code>CatAssetManifest</code>对象并将其传递到构建管线的后续环节</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 构建资源清单</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BuildManifest</span> : <span class="title">IBuildTask</span></span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">InjectContext(ContextUsage.Out)</span>] </span><br><span class="line">    <span class="keyword">private</span> IManifestParam manifestParam;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;inheritdoc /&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Version =&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;inheritdoc /&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnCode <span class="title">Run</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> outputFolder = ((BundleBuildParameters) buildParam).OutputFolder;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建资源清单</span></span><br><span class="line">        CatAssetManifest manifest = <span class="keyword">new</span> CatAssetManifest</span><br><span class="line">        &#123;</span><br><span class="line">            GameVersion = Application.version,</span><br><span class="line">            ManifestVersion = configParam.Config.ManifestVersion,</span><br><span class="line">            Bundles = <span class="keyword">new</span> List&lt;BundleManifestInfo&gt;(),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">        manifestParam = <span class="keyword">new</span> ManifestParam(manifest,outputFolder);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ReturnCode.Success;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WriteManifestFile"><a href="#WriteManifestFile" class="headerlink" title="WriteManifestFile"></a>WriteManifestFile</h3><p>此Task负责将CatAssetManifest对象写入到指定路径下</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> writePath = manifestParam.WritePath;</span><br><span class="line">            CatAssetManifest manifest = manifestParam.Manifest;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">//写入清单文件json</span></span><br><span class="line">            <span class="built_in">string</span> json = CatJson.JsonParser.ToJson(manifest);</span><br><span class="line">            <span class="keyword">using</span> (StreamWriter sw = <span class="keyword">new</span> StreamWriter(Path.Combine(writePath, CatAsset.Runtime.Util.ManifestFileName)))</span><br><span class="line">            &#123;</span><br><span class="line">                sw.Write(json);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h3 id="CopyToReadOnlyDirectory"><a href="#CopyToReadOnlyDirectory" class="headerlink" title="CopyToReadOnlyDirectory"></a>CopyToReadOnlyDirectory</h3><p>此Task负责将指定资源组的资源复制到只读区内，并生成仅包含被复制的资源信息的CatAssetManifest并写入只读区内</p><h2 id="仅构建原生资源包"><a href="#仅构建原生资源包" class="headerlink" title="仅构建原生资源包"></a>仅构建原生资源包</h2><p>CatAsset的资源构建管线提供了仅构建原生资源包的功能</p><p>此时因为不涉及<strong>AssetBundle</strong>的构建，所以不会使用SBP提供的Task</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加构建任务</span></span><br><span class="line">         IList&lt;IBuildTask&gt; taskList = <span class="keyword">new</span> List&lt;IBuildTask&gt;();</span><br><span class="line">         taskList.Add(<span class="keyword">new</span> BuildRawBundles());</span><br><span class="line">         taskList.Add(<span class="keyword">new</span> BuildManifest());</span><br><span class="line">         taskList.Add(<span class="keyword">new</span> MergeManifestAndBundles());</span><br><span class="line">         taskList.Add(<span class="keyword">new</span> WriteManifestFile());</span><br><span class="line">         <span class="keyword">if</span> (bundleBuildConfig.IsCopyToReadOnlyDirectory &amp;&amp; bundleBuildConfig.TargetPlatforms.Count == <span class="number">1</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="comment">//需要复制资源包到只读目录下</span></span><br><span class="line">             taskList.Add(<span class="keyword">new</span> CopyToReadOnlyDirectory());</span><br><span class="line">             taskList.Add(<span class="keyword">new</span> WriteManifestFile());</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>与默认构建任务不同的是，多了一个<strong>MergeManifestAndBundles</strong>（合并资源清单与资源包）任务</p><h3 id="MergeManifestAndBundles"><a href="#MergeManifestAndBundles" class="headerlink" title="MergeManifestAndBundles"></a>MergeManifestAndBundles</h3><p>此任务会将前一个版本的<strong>AssetBundle</strong>资源包和当前被构建的原生资源包合并输出到指定目录下（资源清单也会被同时合并），保证每次构建后得到的都是完整资源包输出</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
          <category> 开发总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CatAsset使用教程</title>
      <link href="/2022/08/30/catasset-guide/"/>
      <url>/2022/08/30/catasset-guide/</url>
      
        <content type="html"><![CDATA[<h1 id="资源构建"><a href="#资源构建" class="headerlink" title="资源构建"></a>资源构建</h1><h2 id="指定资源目录"><a href="#指定资源目录" class="headerlink" title="指定资源目录"></a>指定资源目录</h2><p>CatAsset基于<strong>资源目录</strong>与<strong>构建规则</strong>以进行批量资源构建，所以构建资源的第一步便是指定资源目录</p><p>操作方法为：<strong>右键目录-添加为资源包构建目录</strong></p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatAssetGuide/CatAssetGuide_01.png"></p><p>点击上方工具栏<strong>CatAsset-打开资源包构建窗口</strong></p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatAssetGuide/CatAssetGuide_02.png"></p><p>点击<strong>构建目录</strong>页签，即可看到此目录的信息</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatAssetGuide/CatAssetGuide_03.png"></p><h2 id="选择构建规则"><a href="#选择构建规则" class="headerlink" title="选择构建规则"></a>选择构建规则</h2><p><strong>构建规则</strong>决定了此目录下所有资源文件会按照什么样的方式去构建成为资源包</p><p>点击<code>NAssetToOneBundle</code>处的下拉按钮展开下拉列表，选择<strong>构建规则</strong></p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatAssetGuide/CatAssetGuide_04.png"></p><p>CatAsset默认提供了5种<strong>构建规则</strong>：</p><ol><li><code>NAssetToNBundle</code>（将指定目录下所有资源分别构建为一个资源包）</li><li><code>NAssetToNRawBundle</code>（将指定目录下所有资源分别构建为一个原生资源包）</li><li><code>NAssetToOneBundle</code>（将指定目录下所有资源构建为一个资源包）</li><li><code>SecondDirectoryBasedNAssetToOneBundle</code>（将指定目录下所有二级子目录各自使用<code>NAssetToOneBundle</code>规则进行构建）</li><li><code>TopDirectoryBasedNAssetToOneBundle</code>（将指定目录下所有一级子目录各自使用<code>NAssetToOneBundle</code>规则进行构建）</li></ol><h3 id="如何扩展构建规则？"><a href="#如何扩展构建规则？" class="headerlink" title="如何扩展构建规则？"></a>如何扩展构建规则？</h3><p>只需要通过自定义类实现<code>IBundleBuildRule</code>接口即可</p><h3 id="为什么没有NAssetToOneRawBundle？"><a href="#为什么没有NAssetToOneRawBundle？" class="headerlink" title="为什么没有NAssetToOneRawBundle？"></a>为什么没有NAssetToOneRawBundle？</h3><p>因为原生资源不使用<strong>AssetBundle</strong>进行构建，原生资源包只是被虚拟出来方便进行统一管理的，实际上并不存在对应的资源包文件，所以也不存在一个原生资源包内有多个原生资源的情况，对于原生资源而言，资源文件即是资源包文件</p><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>此处等价于在搜索栏输入的filter，如<strong>t:prefab</strong>表示此资源目录只会构建预制体资源</p><h2 id="正则筛选"><a href="#正则筛选" class="headerlink" title="正则筛选"></a>正则筛选</h2><p>在正则一栏中输入正则表达式，即可仅将<strong>资源路径（以Assets/开头）匹配此表达式</strong>的资源纳入构建范围内</p><h2 id="资源组"><a href="#资源组" class="headerlink" title="资源组"></a>资源组</h2><p>资源组设置用于可更新模式下更新资源，组名相同的资源目录所构建的资源包会被视为同一个资源组，<strong>单机模式下可忽略此项设置</strong></p><h3 id="压缩设置"><a href="#压缩设置" class="headerlink" title="压缩设置"></a>压缩设置</h3><p>此处用于设置此资源目录所构建的AssetBundle的压缩格式</p><h3 id="加密设置"><a href="#加密设置" class="headerlink" title="加密设置"></a>加密设置</h3><p>此处用于设置此资源目录所构建的AssetBundle的加密方式</p><p><em>注意：WebGL平台下不会对资源进行加密，所以此设置无效</em></p><h2 id="预览资源包"><a href="#预览资源包" class="headerlink" title="预览资源包"></a>预览资源包</h2><p>切换分页到<strong>资源包预览</strong>，点击<strong>刷新</strong>即可预览到构建后的资源包的内容</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatAssetGuide/CatAssetGuide_05.png"></p><p><strong>BundleRes/Chapter1.bundle</strong>部分即是此资源包在构建后的，相对于只读区/读写区的路径</p><p><strong>资源数</strong>表示此资源包内的资源数量</p><p><strong>预估长度</strong>表示此资源包内的资源文件长度总和（因此并不表示此资源包在构建后的文件长度，因为在进行预览时并未实际构建出此资源包）</p><h3 id="预览资源"><a href="#预览资源" class="headerlink" title="预览资源"></a>预览资源</h3><p>点击<strong>资源包预览</strong>条目左侧的三角形，即可展开资源列表，查看资源相关信息</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatAssetGuide/CatAssetGuide_07.png"></p><p><strong>Assets/BundleRes/Chapter1/B1.prefab</strong>为此资源的加载路径</p><h3 id="循环依赖检测"><a href="#循环依赖检测" class="headerlink" title="循环依赖检测"></a>循环依赖检测</h3><p>点击<strong>检测资源循环依赖</strong>与<strong>检测资源包循环依赖</strong>即可在编辑器下检查相关循环依赖问题</p><p><strong>准确预估贴图大小</strong>选项若勾选即会按照贴图资源受压缩特使影响的实际大小进行预估长度，但在贴图资源数量多时会拖慢刷新速度</p><h3 id="冗余分析"><a href="#冗余分析" class="headerlink" title="冗余分析"></a>冗余分析</h3><p>CatAsset会自动将冗余资源按照其关联划分为多个冗余资源包</p><h2 id="设定构建配置"><a href="#设定构建配置" class="headerlink" title="设定构建配置"></a>设定构建配置</h2><p>在预览完成后，切换分页到<strong>构建配置</strong>，可进行相关设置</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatAssetGuide/CatAssetGuide_08.png"></p><h3 id="构建设置"><a href="#构建设置" class="headerlink" title="构建设置"></a>构建设置</h3><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatAssetGuide/CatAssetGuide_16.png"></p><p>构建设置分为3种：</p><ol><li><em>WriteLinkXML</em>：会通过SBP在资源包构建完成后自动生成link.xml文件到输出目录</li><li><em>ForceRebuild</em>：强制全量构建</li><li><em>AppendMD5</em>：在资源包名上附加MD5值</li></ol><h3 id="资源包全局压缩设置与资源包全局加密设置"><a href="#资源包全局压缩设置与资源包全局加密设置" class="headerlink" title="资源包全局压缩设置与资源包全局加密设置"></a>资源包全局压缩设置与资源包全局加密设置</h3><p>这两处设置分别用于决定全局的压缩与加密设置，此外每个资源目录还可决定自身独立的压缩与加密设置</p><p><em>注意：原生资源的压缩设置无效</em></p><h3 id="最终输出目录"><a href="#最终输出目录" class="headerlink" title="最终输出目录"></a>最终输出目录</h3><p>资源包在构建完成后的最终输出目录为：<strong>资源包构建输出根目录/资源包构建平台/资源清单版本号/<strong>，如</strong>Library/AssetBundlesOutput/StandaloneWindows/1</strong></p><p><em>资源清单CatAssetManifest.json和CatAssetManifest.data也会被写入到此目录下</em></p><h3 id="构建补丁资源包"><a href="#构建补丁资源包" class="headerlink" title="构建补丁资源包"></a>构建补丁资源包</h3><p>当勾选<strong>构建补丁资源包</strong>时，CatAsset会自行检查发生了变化的资源及其相关资源，然后将这些资源进行单独构建以此提升构建资源包的速度，新的补丁资源包会以原资源包名附加_patch后缀的形式存在，一个正式资源包只会有一个对应的补丁资源包</p><p><em>第一次需要先完整构建资源包生成缓存文件后，才能进行构建补丁资源包</em></p><p><em>由于补丁资源是通过与上一次完整构建的缓存进行对比计算出的，所以随着变化的资源增多，构建补丁资源的速度也会逐渐接近构建完整资源包的速度，此时就需要重新进行一次完整构建</em></p><p><em>当一个资源包里的所有资源都发生了变化时，构建出的补丁资源包就会转为正式资源包以完全替换旧的资源包，此时将不再具有_patch后缀</em></p><h1 id="资源的加载与卸载"><a href="#资源的加载与卸载" class="headerlink" title="资源的加载与卸载"></a>资源的加载与卸载</h1><h2 id="运行前的准备"><a href="#运行前的准备" class="headerlink" title="运行前的准备"></a>运行前的准备</h2><p>在运行前，需要先将<strong>CatAssetComponent</strong>挂载至游戏物体上</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatAssetGuide/CatAssetGuide_10.png"></p><p>或者通过项目中自定义的Manager来进行CatAssetManager.Update的调用</p><h2 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h2><p>CatAsset提供了2种运行模式</p><ul><li>PackageOnly（单机模式，仅使用安装包内的资源）</li><li>Updatable（可更新模式）</li></ul><p><em>后续将以单机模式为例</em></p><h2 id="资源清单检查"><a href="#资源清单检查" class="headerlink" title="资源清单检查"></a>资源清单检查</h2><p>单机模式下，在加载资源前需要先进行资源清单检查，才能正确初始化<code>CatAssetManager</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CatAssetManager.CheckVersion(OnVersionChecked onVersionChecked)</span><br></pre></td></tr></table></figure><p>回调以<code>VersionCheckResult</code>为参数，包含了是否检查成功的信息</p><h2 id="编辑器资源模式"><a href="#编辑器资源模式" class="headerlink" title="编辑器资源模式"></a>编辑器资源模式</h2><p>若勾选<strong>编辑器资源模式</strong>，即可在不进行资源包构建的前提下快速运行游戏，此时CheckVersion会直接返回</p><h2 id="资源类别"><a href="#资源类别" class="headerlink" title="资源类别"></a>资源类别</h2><p>CatAsset支持3种类别的资源：</p><ol><li>内置资源包资源（在Unity工程中使用CatAsset构建，从AssetBundle中加载的资源，如Prefab、Scene文件等）</li><li>内置原生资源（在Unity工程中使用CatAsset构建，不基于AssetBundle而是直接加载其二进制数据的资源，如DLL、Lua文件等）</li><li>外置原生资源（不使用CatAsset构建，直接从读写区加载其二进制数据的资源，如玩家自定义的图片、文本等）</li></ol><h3 id="导入外部的资源包"><a href="#导入外部的资源包" class="headerlink" title="导入外部的资源包"></a>导入外部的资源包</h3><p>可通过将读写区的外部资源包导入<code>CatAssetManager</code>，以将其视为内置资源包资源加载（这些被导入的资源包必须是通过CatAsset构建出来的，这样才有清单文件），接口为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CatAssetManager.ImportInternalAsset(<span class="built_in">string</span> manifestPath,Action&lt;<span class="built_in">bool</span>&gt; callback,<span class="built_in">string</span> bundleRelativePathPrefix = <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p><code>manifestPath</code>为要导入的资源包的资源清单相对于读写区的路径</p><p><code>callback</code>为导入完毕的回调</p><p><code>bundleRelativePathPrefix</code>为资源包相对于读写区路径的额外前缀，若为null，则加载资源包时的路径为<strong>Application.persistentDataPath/bundleRelativePath</strong>，否则为<strong>Application.persistentDataPath/bundleRelativePathPrefix/bundleRelativePath</strong>，此参数主要用于方便自定义需要导入的资源包的位置</p><p><em>此功能主要用于实现AssetBundle类型的Mod文件加载功能</em></p><h2 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h2><p>在资源清单检查完毕后即可进行资源的加载（<strong>所有加载都是异步的</strong>）</p><p>3类资源（非场景）统一通过以下接口进行加载：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssetHandler&lt;T&gt; handler = CatAssetManager.LoadAssetAsync&lt;T&gt;(<span class="built_in">string</span> assetName, CancellationToken token = <span class="literal">default</span>,TaskPriority priority = TaskPriority.Low)</span><br></pre></td></tr></table></figure><p><strong>assetName</strong>为资源的加载路径，若资源类别为1和2，则是一个**Assets/**开头的路径，若为3，则是1个相对于读写区的路径</p><p><strong>token</strong>用于进行加载的取消操作</p><p><strong>priority</strong>表示此加载任务的优先级</p><h3 id="资源句柄"><a href="#资源句柄" class="headerlink" title="资源句柄"></a>资源句柄</h3><p>调用加载资源的接口后会返回一个表示资源句柄的<code>AssetHandler&lt;T&gt;</code>对象，其封装了对被加载的资源的相关操作，如注册此资源加载结束回调，<code>await handler</code>以等待加载结束，资源是否加载成功以及最重要的获取被加载的资源、卸载句柄等</p><p>可通过注册<code>handler.OnLoaded</code>回调或直接<code>await handler</code>等待加载完成，然后通过<code>handler.Success</code>判断是否加载成功，<code>handler.Asset</code>获取到加载到的资源，或是通过<code>handler.Unload()</code>卸载句柄</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CatAssetManager.LoadAssetAsync&lt;TextAsset&gt;(<span class="string">&quot;Assets/BundleRes/RawText/rawText1.txt&quot;</span>).OnLoaded +=</span><br><span class="line">    handler =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler.IsSuccess)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">$&quot;加载原生资源 文本文件:<span class="subst">&#123;handler.Asset.text&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handler.Unload();</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AssetHandler&lt;TextAsset&gt; handler = <span class="keyword">await</span> CatAssetManager.LoadAssetAsync&lt;TextAsset&gt;(<span class="string">&quot;Assets/BundleRes/RawText/rawText1.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (handler.IsSuccess)</span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(<span class="string">$&quot;加载原生资源 文本文件:<span class="subst">&#123;handler.Asset.text&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">handler.Unload();</span><br></pre></td></tr></table></figure><h3 id="句柄中对资源对象的处理"><a href="#句柄中对资源对象的处理" class="headerlink" title="句柄中对资源对象的处理"></a>句柄中对资源对象的处理</h3><p><code>AssetHandler&lt;T&gt;</code>封装了资源加载结果，包括<strong>原始资源实例</strong>，<strong>资源类别</strong>和用于获取资源的<code>AssetObj</code>,<code>Asset</code>及<code>AssetAs&lt;T&gt;</code></p><p><code>AssetObj</code>表示原始资源实例</p><p><code>Asset</code>表示<code>AssetObj</code>通过<code>AssetAs&lt;T&gt;</code>转换后的结果</p><p><code>AssetAs&lt;T&gt;</code>会根据传入的<code>T</code>类型以及<strong>资源类别</strong>来判断应该返回什么</p><p>其判断规则如下：</p><ol><li>当<code>T</code>为<code>object</code>类型时会直接返回原始资源实例</li><li>当资源类别为原生资源时，如果<code>T</code>为<code>byte[]</code>类型，会直接返回原始资源实例，否则调用转换器将原始资源实例转换为对应类型的资源并返回</li><li>当资源类别为资源包资源时，如果<code>T</code>为<code>UnityEngine.Objec</code>t及其派生类型，会直接返回原始资源实例，否则会报错</li></ol><p><em>通常来说直接使用<code>handler.Asset</code>即可</em></p><h3 id="原生资源的加载"><a href="#原生资源的加载" class="headerlink" title="原生资源的加载"></a>原生资源的加载</h3><p>对于原生资源而言，底层只能加载到<code>byte[]</code>数据</p><p>而为了能够进行统一的加载接口调用，需要将<code>byte[]</code>转换为调用加载接口时指定的类型</p><p>如何进行转换则是由自定义原生资源转换器<code>CustomRawAssetConverter</code>决定</p><p>CatAsset默认提供了3种类型的转换器：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">CatAssetManager</span>(<span class="params"></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          RegisterCustomRawAssetConverter(<span class="keyword">typeof</span>(Texture2D),(bytes =&gt;</span><br><span class="line">          &#123;</span><br><span class="line">              Texture2D texture2D = <span class="keyword">new</span> Texture2D(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">              texture2D.LoadImage(bytes);</span><br><span class="line">              <span class="keyword">return</span> texture2D;</span><br><span class="line">          &#125;));</span><br><span class="line">          </span><br><span class="line">          RegisterCustomRawAssetConverter(<span class="keyword">typeof</span>(Sprite),(bytes =&gt;</span><br><span class="line">          &#123;</span><br><span class="line">              Texture2D texture2D = <span class="keyword">new</span> Texture2D(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">              texture2D.LoadImage(bytes);</span><br><span class="line">              Sprite sp = Sprite.Create(texture2D, <span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, texture2D.width, texture2D.height), Vector2.zero);</span><br><span class="line">              <span class="keyword">return</span> sp;</span><br><span class="line">          &#125;));</span><br><span class="line">          </span><br><span class="line">          RegisterCustomRawAssetConverter(<span class="keyword">typeof</span>(TextAsset),(bytes =&gt;</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">string</span> text = Encoding.UTF8.GetString(bytes);</span><br><span class="line">              TextAsset textAsset = <span class="keyword">new</span> TextAsset(text);</span><br><span class="line">              <span class="keyword">return</span> textAsset;</span><br><span class="line">          &#125;));</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>若要注册自定义的转换器，需要调用</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CatAssetManager.RegisterCustomRawAssetConverter(Type type, CustomRawAssetConverter converter)</span><br></pre></td></tr></table></figure><h3 id="批量资源加载"><a href="#批量资源加载" class="headerlink" title="批量资源加载"></a>批量资源加载</h3><p>CatAsset支持对一组资源进行批量加载的操作，其接口为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BatchAssetHandler handler = CatAssetManager.BatchLoadAssetAsync(List&lt;<span class="built_in">string</span>&gt; assetNames,CancellationToken token = <span class="literal">default</span>, TaskPriority priority = TaskPriority.Low)</span><br></pre></td></tr></table></figure><p><em>支持对3种类别资源的混合批量加载</em></p><p><em>注意：由于在编辑器资源模式下，对原生资源的加载必须显式指定加载类型为byte[]，否则会被判断为内置资源包资源，而批量加载接口无法显式指定加载类型，所以无法在编辑器资源模式下对原生资源进行批量加载操作</em></p><h2 id="资源卸载"><a href="#资源卸载" class="headerlink" title="资源卸载"></a>资源卸载</h2><p>CatAsset采用<strong>基于引用计数的资源卸载</strong>方式，因此在加载资源后需要有与其成对调用的卸载调用才能正确将资源卸载掉，卸载接口为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CatAssetManager.UnloadAsset(AssetHandler handler)</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assethandler.Unload()</span><br></pre></td></tr></table></figure><p><em>可通过<code>BatchAssetHandler.Unload</code>来进行对批量加载到的资源的统一卸载</em></p><p><em>可通过<code>CatAssetManager.UnloadUnusedAssets</code>来立即卸载所有<strong>引用计数为0且可卸载</strong>的资源以及没有资源在使用中的资源包</em></p><h2 id="卸载句柄"><a href="#卸载句柄" class="headerlink" title="卸载句柄"></a>卸载句柄</h2><p>通过<code>handler.Unload()</code>会进行对句柄的卸载，其中会根据句柄当前状态进行处理：</p><ol><li>若当前句柄无效，则不做处理</li><li>若当前资源加载中，则取消加载</li><li>若当前资源加载成功，则进行对资源的卸载</li><li>若当前资源加载失败，则仅释放句柄</li></ol><h2 id="场景管理"><a href="#场景管理" class="headerlink" title="场景管理"></a>场景管理</h2><p>对于场景的加载与卸载使用与非场景资源不同的接口，分别为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SceneHandler handler = CatAssetManager.LoadSceneAsync(<span class="built_in">string</span> sceneName,CancellationToken token = <span class="literal">default</span>, TaskPriority priority = TaskPriority.Low)</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CatAssetManager.UnloadScene(SceneHandler scene)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sceneHandler.Unload()</span><br></pre></td></tr></table></figure><h2 id="资源生命周期绑定"><a href="#资源生命周期绑定" class="headerlink" title="资源生命周期绑定"></a>资源生命周期绑定</h2><p>考虑到手动调用卸载可能产生的不便性与易错漏性，可通过资源绑定接口将资源的生命周期与游戏物体/场景的生命周期进行绑定以实现自动卸载</p><p>绑定后会在游戏物体销毁时/场景卸载时自动对被绑定的资源句柄调用卸载接口</p><p>资源生命周期绑定接口为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CatAssetManager.BindToGameObject(GameObject target, IBindableHandler handler)</span><br><span class="line">CatAssetManager.BindToScene(Scene scene, IBindableHandler handler)</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scene.BindTo(handler)</span><br><span class="line">gameobject.BindTo(handler)</span><br><span class="line"></span><br><span class="line">handler.BindTo(scene)</span><br><span class="line">handler.BindTo(gameObject)</span><br></pre></td></tr></table></figure><h1 id="资源更新"><a href="#资源更新" class="headerlink" title="资源更新"></a>资源更新</h1><p>在运行模式为可更新模式时可以进行资源更新的操作</p><h2 id="设置资源更新Uri前缀"><a href="#设置资源更新Uri前缀" class="headerlink" title="设置资源更新Uri前缀"></a>设置资源更新Uri前缀</h2><p>要进行资源更新，首先需要主动设置<code>CatAssetManager.UpdateUriPrefix</code></p><p>下载资源文件时会以 <strong>UpdateUriPrefix/BundleRelativePath</strong> 为下载地址</p><h2 id="检查资源版本"><a href="#检查资源版本" class="headerlink" title="检查资源版本"></a>检查资源版本</h2><p>进行资源更新前，需要调用检查资源版本的接口</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CatAssetManager.CheckVersion(OnVersionChecked onVersionChecked)</span><br></pre></td></tr></table></figure><h2 id="获取更新器信息"><a href="#获取更新器信息" class="headerlink" title="获取更新器信息"></a>获取更新器信息</h2><p>在资源版本检查完毕后，CatAsset会创建出需要进行更新的资源组所对应的更新器</p><p>此时可以通过<code>CheckVersion</code>传递给回调的<code>VersionCheckResult</code>的<code>GroupUpdaters</code>字段获取到所有需要更新资源的更新器</p><p>或者通过遍历资源组信息列表，获取其对应的更新器来判断其是否有需要更新的资源</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历所有资源组的更新器</span></span><br><span class="line">      List&lt;GroupInfo&gt; groups = CatAssetManager.GetAllGroupInfo();</span><br><span class="line">      <span class="keyword">foreach</span> (GroupInfo groupInfo <span class="keyword">in</span> groups)</span><br><span class="line">      &#123;</span><br><span class="line">          GroupUpdater updater = CatAssetManager.GetGroupUpdater(groupInfo.GroupName);</span><br><span class="line">          <span class="keyword">if</span> (updater != <span class="literal">null</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//存在资源组对应的更新器 就说明此资源组有需要更新的资源</span></span><br><span class="line">              Debug.Log(<span class="string">$&quot;<span class="subst">&#123;groupInfo.GroupName&#125;</span>组的资源需要更新&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><em>在资源组的所有待更新资源都成功更新完毕后，会删除此资源组对应的更新器</em></p><h2 id="更新资源组"><a href="#更新资源组" class="headerlink" title="更新资源组"></a>更新资源组</h2><p>使用更新资源组接口即可开始调用指定资源组的更新器，开始更新资源：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CatAssetManager.UpdateGroup(<span class="built_in">string</span> <span class="keyword">group</span>, BundleUpdatedCallback callback)</span><br></pre></td></tr></table></figure><p><code>BundleUpdatedCallback</code>为资源包更新回调，每次更新完毕一个资源包后都会调用此回调，其定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">BundleUpdatedCallback</span>(<span class="params">BundleUpdateResult result</span>)</span>;</span><br></pre></td></tr></table></figure><p><code>BundleUpdateResult</code>表示资源包更新结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> 资源包更新结果</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> BundleUpdateResult</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 是否更新成功</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="built_in">bool</span> Success;</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 资源包更新器信息</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">readonly</span> UpdateInfo UpdateInfo;</span><br><span class="line">       </span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 此资源包的资源组更新器</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">readonly</span> GroupUpdater Updater;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//省略...</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可从<code>BundleUpdateResult</code>中获取到<code>GroupUpdater</code>，以取得更详细的信息，如资源组名、需要更新的资源包数量/长度、已更新的资源包数量/长度</p><h2 id="暂停-恢复更新"><a href="#暂停-恢复更新" class="headerlink" title="暂停/恢复更新"></a>暂停/恢复更新</h2><p>可通过相关接口暂停/恢复指定资源组更新器的资源更新行为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CatAssetManager.PauseGroupUpdater(<span class="built_in">string</span> <span class="keyword">group</span>)</span><br><span class="line">CatAssetManager.ResumeGroupUpdater(<span class="built_in">string</span> <span class="keyword">group</span>)</span><br></pre></td></tr></table></figure><h1 id="调试分析器"><a href="#调试分析器" class="headerlink" title="调试分析器"></a>调试分析器</h1><p>为了方便进行资源框架相关的调试，CatAsset提供了用于展示运行时信息的调试分析器窗口，点击上方工具栏<strong>CatAsset/打开调试分析器窗口</strong>即可打开</p><p>调试分析器可用于进行<strong>真机调试</strong>，只需要在构建安装包时勾选<strong>developmentBuild</strong>和<strong>Autoconnect Profiler</strong>即可</p><h2 id="通用说明"><a href="#通用说明" class="headerlink" title="通用说明"></a>通用说明</h2><p>通过点击<strong>采样</strong>按钮，即可获取当前帧的分析器信息</p><p>通过滑动Slider或直接输入帧号，可切换到不同帧对应的分析器信息</p><h2 id="资源包信息"><a href="#资源包信息" class="headerlink" title="资源包信息"></a>资源包信息</h2><p>资源包信息窗口提供了<strong>尚在内存中的资源包</strong>的相关信息</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatAssetGuide/CatAssetGuide_12.png"></p><h3 id="文件长度"><a href="#文件长度" class="headerlink" title="文件长度"></a>文件长度</h3><p>其中资源包信息条目的文件长度表示资源包文件的实际长度，资源信息条目的长度表示此资源的原始文件长度</p><h3 id="只显示主动加载的资源"><a href="#只显示主动加载的资源" class="headerlink" title="只显示主动加载的资源"></a>只显示主动加载的资源</h3><p>主动加载：在业务层通过加载接口进行资源加载的行为</p><p>依赖加载：框架层自身通过依赖加载进行资源加载的行为</p><p>若勾选<strong>只显示主动加载的资源</strong>，则会将通过自动依赖加载出的资源的相关信息隐藏，使得开发者能够更专注于那些被主动加载的资源信息</p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>引用计数由主动加载的计数和依赖加载的计数2部分组成</p><p>引用计数的增减规则：</p><ol><li>每一次对资源的主动加载或主动卸载会+1或-1此资源的引用计数</li><li>当资源的引用计数从0增加到1或从1减少为0时，会+1或-1直接依赖资源的引用计数（<strong>也就是说1个资源最多只会对它的所有直接依赖资源贡献1个引用计数</strong>）</li></ol><h3 id="上游与下游"><a href="#上游与下游" class="headerlink" title="上游与下游"></a>上游与下游</h3><p>在依赖链中，若A依赖B，B依赖C，则称</p><p>C是B的上游节点，B是A的上游节点</p><p>A是B的下游节点，B是C的下游节点</p><p>通过点击<strong>查看依赖关系图</strong>按钮，即可查看与当前资源包/资源有直接/间接上下游关系的依赖关系图</p><p><em>引用计数 - 下游节点的数量 = 此资源被主动加载的次数</em></p><h2 id="资源信息"><a href="#资源信息" class="headerlink" title="资源信息"></a>资源信息</h2><p>资源信息窗口提供了<strong>尚在内存中的资源</strong>的相关信息，各列含义大致与资源包信息窗口的一致</p><h2 id="任务信息"><a href="#任务信息" class="headerlink" title="任务信息"></a>任务信息</h2><p>在CatAsset中，如加载、卸载、更新等异步操作都是由内置的任务系统实现的，可通过任务信息窗口查看当前进行中的任务</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatAssetGuide/CatAssetGuide_13.png"></p><h2 id="资源组信息"><a href="#资源组信息" class="headerlink" title="资源组信息"></a>资源组信息</h2><p>此窗口显示与资源组相关的信息</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatAssetGuide/CatAssetGuide_14.png"></p><h2 id="更新器信息"><a href="#更新器信息" class="headerlink" title="更新器信息"></a>更新器信息</h2><p>此窗口显示资源更新相关的信息</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatAssetGuide/CatAssetGuide_15.png"></p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CatJsonV2开发总结</title>
      <link href="/2022/08/17/catjson-v2-dev-summary/"/>
      <url>/2022/08/17/catjson-v2-dev-summary/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>建议在阅读本文之前先阅读<a href="http://cathole.top/2021/12/05/catjson-dev-summary/">CatJson开发总结</a></strong></p><p>在前几天正式发布了<a href="https://github.com/CatImmortal/CatJson">CatJson</a>的V2版本，此版本对旧代码进行了大幅度的重构，使其拥有了更清晰简洁的结构与更方便的扩展性</p><p>代码结构如下：</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatJsonV2DevSummary/CatJsonV2DevSummary_1.png"></p><ul><li>Attributes：包含内置的特性标签，主要用于忽略字段/属性和处理默认值</li><li>Formatter：包含各种类型对应的Json格式化器的实现</li><li>JsonObject：包含通用Json对象与Json值</li><li>Lexer：包含用于读取Json词法单元的Json词法分析器</li><li>MetaData：包含用于反射处理的类型元数据</li><li>Misc：包含各类Util与Helper</li><li>JsonParser.cs：CatJson的序列化/反序列化调用入口</li></ul><h1 id="格式化器"><a href="#格式化器" class="headerlink" title="格式化器"></a>格式化器</h1><p>V2版本相对于V1最大的重构即是将对所有类型的Json序列化/反序列化行为都统一抽象为了<strong>Formatter</strong>进行处理</p><p><code>JsonParser</code>中的相关代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Json解析器</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">JsonParser</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//省略...</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> NullFormatter nullFormatter = <span class="keyword">new</span> NullFormatter();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> EnumFormatter enumFormatter = <span class="keyword">new</span> EnumFormatter();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ArrayFormatter arrayFormatter = <span class="keyword">new</span> ArrayFormatter();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ReflectionFormatter reflectionFormatter = <span class="keyword">new</span> ReflectionFormatter();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> PolymorphicFormatter polymorphicFormatter = <span class="keyword">new</span> PolymorphicFormatter();</span><br><span class="line">        </span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Json格式化器字典</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="title">Dictionary</span>&lt;<span class="title">Type</span>, <span class="title">IJsonFormatter</span>&gt; formatterDict</span> = <span class="keyword">new</span> Dictionary&lt;Type, IJsonFormatter&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//基元类型</span></span><br><span class="line">            &#123;<span class="keyword">typeof</span>(<span class="built_in">bool</span>), <span class="keyword">new</span> BooleanFormatter()&#125;,</span><br><span class="line">            </span><br><span class="line">            &#123;<span class="keyword">typeof</span>(<span class="built_in">byte</span>), <span class="keyword">new</span> ByteFormatter()&#125;,</span><br><span class="line">            &#123;<span class="keyword">typeof</span>(<span class="built_in">sbyte</span>), <span class="keyword">new</span> SByteFormatter()&#125;,</span><br><span class="line">            </span><br><span class="line">            &#123;<span class="keyword">typeof</span>(<span class="built_in">short</span>), <span class="keyword">new</span> Int16Formatter()&#125;,</span><br><span class="line">            &#123;<span class="keyword">typeof</span>(<span class="built_in">ushort</span>), <span class="keyword">new</span> UInt16Formatter()&#125;,</span><br><span class="line">            </span><br><span class="line">            &#123;<span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="keyword">new</span> Int32Formatter()&#125;,</span><br><span class="line">            &#123;<span class="keyword">typeof</span>(<span class="built_in">uint</span>), <span class="keyword">new</span> UInt32Formatter()&#125;,</span><br><span class="line">            </span><br><span class="line">            &#123;<span class="keyword">typeof</span>(<span class="built_in">long</span>), <span class="keyword">new</span> Int64Formatter()&#125;,</span><br><span class="line">            &#123;<span class="keyword">typeof</span>(<span class="built_in">ulong</span>), <span class="keyword">new</span> UInt64Formatter()&#125;,</span><br><span class="line">            </span><br><span class="line">            &#123;<span class="keyword">typeof</span>(<span class="built_in">float</span>), <span class="keyword">new</span> SingleFormatter()&#125;,</span><br><span class="line">            &#123;<span class="keyword">typeof</span>(<span class="built_in">double</span>), <span class="keyword">new</span> DoubleFormatter()&#125;,</span><br><span class="line">            &#123;<span class="keyword">typeof</span>(<span class="built_in">decimal</span>), <span class="keyword">new</span> DecimalFormatter()&#125;,</span><br><span class="line">            </span><br><span class="line">            &#123;<span class="keyword">typeof</span>(<span class="built_in">char</span>), <span class="keyword">new</span> CharFormatter()&#125;,</span><br><span class="line">            &#123;<span class="keyword">typeof</span>(<span class="built_in">string</span>), <span class="keyword">new</span> StringFormatter()&#125;,</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//容器类型</span></span><br><span class="line">            &#123;<span class="keyword">typeof</span>(List&lt;&gt;), <span class="keyword">new</span> ListFormatter()&#125;,</span><br><span class="line">            &#123;<span class="keyword">typeof</span>(Dictionary&lt;,&gt;), <span class="keyword">new</span> DictionaryFormatter()&#125;,</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//Json通用对象类型</span></span><br><span class="line">            &#123;<span class="keyword">typeof</span>(JsonObject), <span class="keyword">new</span> JsonObjectFormatter()&#125;,</span><br><span class="line">            &#123;<span class="keyword">typeof</span>(JsonValue), <span class="keyword">new</span> JsonValueFormatter()&#125;,</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//Unity特有类型</span></span><br><span class="line">            &#123;<span class="keyword">typeof</span>(Hash128), <span class="keyword">new</span> Hash128Formatter()&#125;,</span><br><span class="line">            &#123;<span class="keyword">typeof</span>(Vector2),<span class="keyword">new</span> Vector2Formatter()&#125;,</span><br><span class="line">            &#123;<span class="keyword">typeof</span>(Vector3),<span class="keyword">new</span> Vector3Formatter()&#125;,</span><br><span class="line">            &#123;<span class="keyword">typeof</span>(Vector4),<span class="keyword">new</span> Vector4Formatter()&#125;,</span><br><span class="line">            &#123;<span class="keyword">typeof</span>(Quaternion),<span class="keyword">new</span> QuaternionFormatter()&#125;,</span><br><span class="line">            &#123;<span class="keyword">typeof</span>(Color),<span class="keyword">new</span> ColorFormatter()&#125;,</span><br><span class="line">            &#123;<span class="keyword">typeof</span>(Bounds),<span class="keyword">new</span> BoundsFormatter()&#125;,</span><br><span class="line">            &#123;<span class="keyword">typeof</span>(Rect),<span class="keyword">new</span> RectFormatter()&#125;,</span><br><span class="line">            &#123;<span class="keyword">typeof</span>(Keyframe),<span class="keyword">new</span> KeyFrameFormatter()&#125;,</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//其他</span></span><br><span class="line">            &#123;Type.GetType(<span class="string">&quot;System.RuntimeType,mscorlib&quot;</span>),<span class="keyword">new</span> RuntimeTypeFormatter()&#125;,  <span class="comment">//Type类型的变量其对象一般为RuntimeType类型，但是不能直接typeof(RuntimeType)，只能这样了</span></span><br><span class="line">            &#123;<span class="keyword">typeof</span>(DateTime),<span class="keyword">new</span> DateTimeFormatter()&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 添加自定义的Json格式化器</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddCustomJsonFormatter</span>(<span class="params">Type type, IJsonFormatter formatter</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            formatterDict[type] = formatter;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//省略...</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 将指定类型的对象序列化为Json文本</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InternalToJson</span>(<span class="params"><span class="built_in">object</span> obj, Type type, Type realType = <span class="literal">null</span>, <span class="built_in">int</span> depth = <span class="number">1</span>,<span class="built_in">bool</span> checkPolymorphic = <span class="literal">true</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">             <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!realType.IsGenericType)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (formatterDict.TryGetValue(realType, <span class="keyword">out</span> IJsonFormatter formatter))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//使用通常的formatter处理</span></span><br><span class="line">                    formatter.ToJson(obj,type,realType, depth);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (formatterDict.TryGetValue(realType.GetGenericTypeDefinition(), <span class="keyword">out</span> IJsonFormatter formatter))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//使用泛型类型formatter处理</span></span><br><span class="line">                    formatter.ToJson(obj,type,realType,depth);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FUCK_LUA</span></span><br><span class="line">            <span class="keyword">if</span> (type <span class="keyword">is</span> ILRuntime.Reflection.ILRuntimeType ilrtType &amp;&amp; ilrtType.ILType.IsEnum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//热更层枚举 使用int formatter处理</span></span><br><span class="line">                formatterDict[<span class="keyword">typeof</span>(<span class="built_in">int</span>)].ToJson(obj, type, realType,depth);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">is</span> Enum e)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//使用枚举formatter处理</span></span><br><span class="line">                enumFormatter.ToJson(e, type, realType, depth);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">is</span> Array array)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//使用数组formatter处理</span></span><br><span class="line">                arrayFormatter.ToJson(array,type,realType, depth);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//使用反射formatter处理</span></span><br><span class="line">            reflectionFormatter.ToJson(obj,type,realType,depth);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//省略...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 将Json文本反序列化为指定类型的对象</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="built_in">object</span> <span class="title">InternalParseJson</span>(<span class="params">Type type,Type realType = <span class="literal">null</span>,<span class="built_in">bool</span> checkPolymorphic = <span class="literal">true</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">             <span class="comment">//省略...</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">object</span> result;</span><br><span class="line">            </span><br><span class="line">             <span class="comment">//省略...</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (formatterDict.TryGetValue(realType, <span class="keyword">out</span> IJsonFormatter formatter))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//使用通常的formatter处理</span></span><br><span class="line">                result = formatter.ParseJson(type, realType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (realType.IsGenericType &amp;&amp; formatterDict.TryGetValue(realType.GetGenericTypeDefinition(), <span class="keyword">out</span> formatter))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//使用泛型类型formatter处理</span></span><br><span class="line">                result = formatter.ParseJson(type,realType);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FUCK_LUA</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">is</span> ILRuntime.Reflection.ILRuntimeType ilrtType &amp;&amp; ilrtType.ILType.IsEnum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//热更层枚举 使用int formatter处理</span></span><br><span class="line">                result = formatterDict[<span class="keyword">typeof</span>(<span class="built_in">int</span>)].ParseJson(type, realType);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (realType.IsEnum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//使用枚举formatter处理</span></span><br><span class="line">                result = enumFormatter.ParseJson(type, realType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (realType.IsArray)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//使用数组formatter处理</span></span><br><span class="line">                result = arrayFormatter.ParseJson(type,realType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//使用反射formatter处理</span></span><br><span class="line">                result = reflectionFormatter.ParseJson(type,realType);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">is</span> IJsonParserCallbackReceiver receiver)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//触发序列化结束回调</span></span><br><span class="line">                receiver.OnParseJsonEnd();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Formatter的接口与基类定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> Json格式化器接口</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IJsonFormatter</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 将对象序列化为Json文本</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">ToJson</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, Type type, Type realType, <span class="built_in">int</span> depth</span>)</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 将Json文本反序列化为对象</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="function"><span class="built_in">object</span> <span class="title">ParseJson</span>(<span class="params">Type type, Type realType</span>)</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> Json格式化器基类</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">BaseJsonFormatter</span>&lt;<span class="title">TValue</span>&gt; : <span class="title">IJsonFormatter</span></span><br><span class="line">   &#123;</span><br><span class="line">   </span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;inheritdoc /&gt;</span></span></span><br><span class="line">       <span class="keyword">void</span> IJsonFormatter.ToJson(<span class="built_in">object</span> <span class="keyword">value</span>, Type type, Type realType, <span class="built_in">int</span> depth)</span><br><span class="line">       &#123;</span><br><span class="line">           ToJson((TValue)<span class="keyword">value</span>,type,realType, depth);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;inheritdoc /&gt;</span></span></span><br><span class="line">       <span class="built_in">object</span> IJsonFormatter.ParseJson(Type type, Type realType)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> ParseJson(type,realType);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 将对象序列化为Json文本</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">ToJson</span>(<span class="params">TValue <span class="keyword">value</span>, Type type, Type realType, <span class="built_in">int</span> depth</span>)</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 将Json文本反序列化为对象</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TValue <span class="title">ParseJson</span>(<span class="params">Type type, Type realType</span>)</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>想要定义一个类型的Json序列化/反序列化行为，只需要继承基类，实现<code>ToJson</code>与<code>ParseJson</code>方法，并将其注册到<code>JsonParser</code>中即可</p><p>以<code>Vector3</code>类型为例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> Vector3类型的Json格式化器</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Vector3Formatter</span> : <span class="title">BaseJsonFormatter</span>&lt;<span class="title">Vector3</span>&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;inheritdoc /&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ToJson</span>(<span class="params">Vector3 <span class="keyword">value</span>, Type type, Type realType, <span class="built_in">int</span> depth</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           TextUtil.Append(<span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">           TextUtil.Append(<span class="keyword">value</span>.x.ToString());</span><br><span class="line">           TextUtil.Append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">           TextUtil.Append(<span class="keyword">value</span>.y.ToString());</span><br><span class="line">           TextUtil.Append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">           TextUtil.Append(<span class="keyword">value</span>.z.ToString());</span><br><span class="line">           TextUtil.Append(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;inheritdoc /&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Vector3 <span class="title">ParseJson</span>(<span class="params">Type type, Type realType</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           JsonParser.Lexer.GetNextTokenByType(TokenType.LeftBrace);</span><br><span class="line">           <span class="built_in">float</span> x = JsonParser.Lexer.GetNextTokenByType(TokenType.Number).AsFloat();</span><br><span class="line">           JsonParser.Lexer.GetNextTokenByType(TokenType.Comma);</span><br><span class="line">           <span class="built_in">float</span> y = JsonParser.Lexer.GetNextTokenByType(TokenType.Number).AsFloat();</span><br><span class="line">           JsonParser.Lexer.GetNextTokenByType(TokenType.Comma);</span><br><span class="line">           <span class="built_in">float</span> z = JsonParser.Lexer.GetNextTokenByType(TokenType.Number).AsFloat();</span><br><span class="line">           JsonParser.Lexer.GetNextTokenByType(TokenType.RightBrace);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> Vector3(x,y,z);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看出<code>Vector3Formatter</code>在<code>ToJson</code>中通过写入x，y，z三个值完成序列化，在<code>ParseJson</code>中，通过Lexer提取x，y，z三个数字值完成反序列化</p><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><p>Lexer部分所做的修改较少，主要是将提取数字token的方法返回值从string改为了RangeString</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 扫描数字</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> RangeString <span class="title">ScanNumber</span>(<span class="params"></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">int</span> startIndex = CurIndex;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//第一个字符是0-9或者-</span></span><br><span class="line">          Next();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span> (</span><br><span class="line">              !(CurIndex &gt;= json.Length)&amp;&amp;</span><br><span class="line">              (</span><br><span class="line">              <span class="built_in">char</span>.IsDigit(json[CurIndex]) || json[CurIndex] == <span class="string">&#x27;.&#x27;</span> || json[CurIndex] == <span class="string">&#x27;+&#x27;</span>|| json[CurIndex] == <span class="string">&#x27;-&#x27;</span>|| json[CurIndex] == <span class="string">&#x27;e&#x27;</span>|| json[CurIndex] == <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">              )</span><br><span class="line">          &#123;</span><br><span class="line"></span><br><span class="line">              Next();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">int</span> endIndex = CurIndex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          RangeString rs = <span class="keyword">new</span> RangeString(json, startIndex, endIndex);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> rs;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>之所以做出这样的修改，是因为在V1中，<code>ScanNumber</code>会将扫描出的数字部分字符串给截取出来直接调用<code>ToString</code>，这样不可避免的会产生额外字符串内存分配</p><p>而借助高版本C#的<code>ReadOnlySpan</code>，可以实现一个0内存分配的数字解析</p><p>为了实现这个目标，首先在<code>RangeString</code>中添加对应AsSpan方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ReadOnlySpan&lt;<span class="built_in">char</span>&gt; <span class="title">AsSpan</span>(<span class="params"></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">int</span> length = endIndex - startIndex + <span class="number">1</span>;</span><br><span class="line">          ReadOnlySpan&lt;<span class="built_in">char</span>&gt; span = source.AsSpan(startIndex, length);</span><br><span class="line">          <span class="keyword">return</span> span;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>然后在数字类型的Formatter的<code>ParseJson</code>实现中调用此方法进行解析即可，以<code>Int64Formatter</code>为例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> long类型的Json格式化器</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Int64Formatter</span> : <span class="title">BaseJsonFormatter</span>&lt;<span class="title">long</span>&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;inheritdoc /&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ToJson</span>(<span class="params"><span class="built_in">long</span> <span class="keyword">value</span>, Type type, Type realType, <span class="built_in">int</span> depth</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           TextUtil.Append(<span class="keyword">value</span>.ToString());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;inheritdoc /&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">long</span> <span class="title">ParseJson</span>(<span class="params">Type type, Type realType</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           RangeString rs = JsonParser.Lexer.GetNextTokenByType(TokenType.Number);</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">long</span>.Parse(rs.AsSpan());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>得益于高版本C#中对于大量基础类型的<code>Parse</code>方法对<code>ReadOnlySpan</code>参数的支持，可以简单方便的实现出中间过程中不产生字符串分配的，0GC数字解析</p><p>最后值得一提的是，不仅局限于类型，包括反射处理、多态处理以及null值处理都是通过实现对应的Formatter完成的</p><h1 id="JsonValue"><a href="#JsonValue" class="headerlink" title="JsonValue"></a>JsonValue</h1><p>V2版本对表示Json值的<code>JsonValue</code>添加了以int为参数与以string为参数的索引器，以及大量以对应类型为参数的构造器与隐式转换运算符重载，加强了其易用性</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Json值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">StructLayout(LayoutKind.Explicit)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JsonValue</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">FieldOffset(0)</span>]</span><br><span class="line">    <span class="keyword">public</span> ValueType Type;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">FieldOffset(1)</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> boolean;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">FieldOffset(1)</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> number;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">FieldOffset(8)</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> str;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">FieldOffset(8)</span>]</span><br><span class="line">    <span class="keyword">private</span> List&lt;JsonValue&gt; array;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">FieldOffset(8)</span>]</span><br><span class="line">    <span class="keyword">private</span> JsonObject obj;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">region</span> 构造方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonValue</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Type = ValueType.Null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonValue</span>(<span class="params"><span class="built_in">bool</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Type = ValueType.Boolean;</span><br><span class="line">        boolean = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonValue</span>(<span class="params"><span class="built_in">double</span> d</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Type = ValueType.Number;</span><br><span class="line">        number = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> JsonValue <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Type != ValueType.Array)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">default</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> array[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Type != ValueType.Array)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            array[index] = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> JsonValue <span class="keyword">this</span>[<span class="built_in">string</span> key]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Type != ValueType.Object)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">default</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Type != ValueType.Object)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            obj[key] = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">region</span> 隐式类型转换</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">JsonValue</span>(<span class="params"><span class="built_in">bool</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        JsonValue <span class="keyword">value</span> = <span class="keyword">new</span> JsonValue(b);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">bool</span>(<span class="params">JsonValue <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span>.Type != ValueType.Boolean)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;JsonValue转换bool失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>.boolean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">JsonValue</span>(<span class="params"><span class="built_in">double</span> d</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        JsonValue <span class="keyword">value</span> = <span class="keyword">new</span> JsonValue(d);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">double</span>(<span class="params">JsonValue <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span>.Type != ValueType.Number)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;JsonValue转换double失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>.number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类型元数据"><a href="#类型元数据" class="headerlink" title="类型元数据"></a>类型元数据</h1><p>V2中增加了<code>TypeMetaDataManager</code>和<code>TypeMetaData</code>统一管理类型元数据</p><p><code>TypeMetaData</code>主要用于记录每个类型的字段/属性反射信息，以及相应特性标签信息</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> 类型的反射元数据</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TypeMetaData</span></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 类型信息</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">private</span> Type type;</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 是否序列化此类型下的默认值字段/属性</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">bool</span> IsCareDefaultValue &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 字段信息</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Dictionary</span>&lt;<span class="title">RangeString</span>, <span class="title">FieldInfo</span>&gt; FieldInfos</span> &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> Dictionary&lt;RangeString, FieldInfo&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 属性信息</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Dictionary</span>&lt;<span class="title">RangeString</span>, <span class="title">PropertyInfo</span>&gt; PropertyInfos</span> &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> Dictionary&lt;RangeString, PropertyInfo&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 需要忽略处理的字段/属性名</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">HashSet</span>&lt;<span class="title">string</span>&gt; ignoreMembers</span> = <span class="keyword">new</span> HashSet&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">       </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">TypeMetaData</span>(<span class="params">Type type</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">this</span>.type = type;</span><br><span class="line">           IsCareDefaultValue = Attribute.IsDefined(type, <span class="keyword">typeof</span>(JsonCareDefaultValueAttribute));</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//收集字段信息</span></span><br><span class="line">           FieldInfo[] fis = type.GetFields(TypeMetaDataManager.Flags);</span><br><span class="line">           <span class="keyword">foreach</span> (FieldInfo fi <span class="keyword">in</span> fis)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span> (IsIgnoreMember(fi,fi.Name))</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">               FieldInfos.Add(<span class="keyword">new</span> RangeString(fi.Name), fi);</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//收集属性信息</span></span><br><span class="line">           PropertyInfo[] pis = type.GetProperties(TypeMetaDataManager.Flags);</span><br><span class="line">           <span class="keyword">foreach</span> (PropertyInfo pi <span class="keyword">in</span> pis)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span> (IsIgnoreMember(pi,pi.Name))</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">if</span> (pi.SetMethod != <span class="literal">null</span> &amp;&amp; pi.GetMethod != <span class="literal">null</span> &amp;&amp; pi.Name != <span class="string">&quot;Item&quot;</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">//属性必须同时具有get set 并且不能是索引器item</span></span><br><span class="line">                   PropertyInfos.Add(<span class="keyword">new</span> RangeString(pi.Name),pi);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">         </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 是否需要忽略此字段/属性</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">IsIgnoreMember</span>(<span class="params">MemberInfo mi,<span class="built_in">string</span> name</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (Attribute.IsDefined(mi, <span class="keyword">typeof</span>(JsonIgnoreAttribute)))</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (ignoreMembers.Contains(name))</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 添加需要忽略的成员</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddIgnoreMember</span>(<span class="params"><span class="built_in">string</span> memberName</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           ignoreMembers.Add(memberName);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> type.ToString();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="多态序列化-反序列化"><a href="#多态序列化-反序列化" class="headerlink" title="多态序列化/反序列化"></a>多态序列化/反序列化</h1><p>如果调用<code>ToJson</code>时传入的类型与对象实际类型不一致，就会触发多态序列化将真实类型信息写入，而如果反序列化时能够读取到写入的真实类型信息，就会触发多态反序列化</p><p>在<code>JsonParser</code>中的相关代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Json解析器</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">JsonParser</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 将指定类型的对象序列化为Json文本</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InternalToJson</span>(<span class="params"><span class="built_in">object</span> obj, Type type, Type realType = <span class="literal">null</span>, <span class="built_in">int</span> depth = <span class="number">1</span>,<span class="built_in">bool</span> checkPolymorphic = <span class="literal">true</span></span>)</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (realType == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            realType = TypeUtil.GetType(obj,type);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (checkPolymorphic &amp;&amp; !TypeUtil.TypeEquals(type,realType))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//开启了多态序列化检测</span></span><br><span class="line">            <span class="comment">//并且定义类型和真实类型不一致</span></span><br><span class="line">            <span class="comment">//就要进行多态序列化</span></span><br><span class="line">            polymorphicFormatter.ToJson(obj,type,realType,depth);</span><br><span class="line">            <span class="keyword">return</span>;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 将Json文本反序列化为指定类型的对象</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="built_in">object</span> <span class="title">InternalParseJson</span>(<span class="params">Type type,Type realType = <span class="literal">null</span>,<span class="built_in">bool</span> checkPolymorphic = <span class="literal">true</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (realType == <span class="literal">null</span> &amp;&amp; !ParserHelper.TryParseRealType(type,<span class="keyword">out</span> realType))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//未传入realType并且读取不到realType，就把type作为realType使用</span></span><br><span class="line">            <span class="comment">//这里不能直接赋值type，因为type有可能是一个包装了主工程类型的ILRuntimeWrapperType</span></span><br><span class="line">            <span class="comment">//直接赋值type会导致无法从formatterDict拿到正确的formatter从而进入到reflectionFormatter的处理中</span></span><br><span class="line">            <span class="comment">//realType = type;  </span></span><br><span class="line">            realType = TypeUtil.CheckType(type);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">object</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (checkPolymorphic &amp;&amp; !TypeUtil.TypeEquals(type,realType))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//开启了多态检查并且type和realType不一致</span></span><br><span class="line">            <span class="comment">//进行多态处理</span></span><br><span class="line">            result = polymorphicFormatter.ParseJson(type, realType);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是多态序列化还是反序列化都是通过<code>PolymorphicFormatter</code>来统一处理的，其代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> 处理多态序列化/反序列化的Json格式化器</span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PolymorphicFormatter</span> : <span class="title">IJsonFormatter</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 真实类型key</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">string</span> RealTypeKey = <span class="string">&quot;&lt;&gt;RealType&quot;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 对象Json文本key</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> objectKey = <span class="string">&quot;&lt;&gt;Object&quot;</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;inheritdoc /&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ToJson</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span>, Type type, Type realType, <span class="built_in">int</span> depth</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          TextUtil.AppendLine(<span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">              </span><br><span class="line">          <span class="comment">//写入真实类型</span></span><br><span class="line">          TextUtil.Append(<span class="string">&quot;\&quot;&quot;</span>, depth);</span><br><span class="line">          TextUtil.Append(RealTypeKey);</span><br><span class="line">          TextUtil.Append(<span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">          TextUtil.Append(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">          TextUtil.Append(TypeUtil.GetTypeString(realType));</span><br><span class="line">              </span><br><span class="line">          TextUtil.AppendLine(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">              </span><br><span class="line">          <span class="comment">//写入对象的json文本</span></span><br><span class="line">          TextUtil.Append(<span class="string">&quot;\&quot;&quot;</span>, depth);</span><br><span class="line">          TextUtil.Append(objectKey);</span><br><span class="line">          TextUtil.Append(<span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">          TextUtil.Append(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">          JsonParser.InternalToJson(<span class="keyword">value</span>,type,realType,depth + <span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">              </span><br><span class="line">          TextUtil.AppendLine(<span class="built_in">string</span>.Empty);</span><br><span class="line">          TextUtil.Append(<span class="string">&quot;&#125;&quot;</span>, depth);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;inheritdoc /&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">ParseJson</span>(<span class="params">Type type, Type realType</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         </span><br><span class="line">          <span class="comment">//&#123;</span></span><br><span class="line">          <span class="comment">//&quot;&lt;&gt;RealType&quot;:&quot;xxxx&quot;</span></span><br><span class="line">          <span class="comment">//在进入此方法前，已经将这之前的部分提取掉了</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">//接下来只需要提取下面这部分就行</span></span><br><span class="line">          <span class="comment">//&quot;,&quot;</span></span><br><span class="line">          <span class="comment">//&quot;&lt;&gt;Object&quot;:xxxx</span></span><br><span class="line">          <span class="comment">//&#125;</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">//跳过,</span></span><br><span class="line">          JsonParser.Lexer.GetNextTokenByType(TokenType.Comma);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//跳过&quot;&lt;&gt;Object&quot;</span></span><br><span class="line">          JsonParser.Lexer.GetNextTokenByType(TokenType.String);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//跳过 :</span></span><br><span class="line">          JsonParser.Lexer.GetNextTokenByType(TokenType.Colon);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//读取被多态序列化的对象的Json文本并反序列化</span></span><br><span class="line">          <span class="built_in">object</span> obj = JsonParser.InternalParseJson(type,realType,<span class="literal">false</span>);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//跳过&#125;</span></span><br><span class="line">          JsonParser.Lexer.GetNextTokenByType(TokenType.RightBrace);</span><br><span class="line"></span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">          <span class="keyword">return</span> obj;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>对于多态对象的序列化，会通过一组{}将真实类型信息与多态对象的序列化结果包起来，反序列化时则提取出对应信息即可</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
          <category> 开发总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Json </tag>
            
            <tag> 序列化 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#高级编程：未公开关键字研究</title>
      <link href="/2022/08/04/csharp-undocumented-keyword/"/>
      <url>/2022/08/04/csharp-undocumented-keyword/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>C#语言中存在4个未被文档记录(<strong>Undocumented</strong>)的关键字，在VS、Rider这样的IDE中试图敲出它们时并不会给你任何智能提示，它们分别是：</p><ol><li><strong>__makeref</strong></li><li><strong>__refvalue</strong></li><li><strong>__reftype</strong></li><li><strong>__arglist</strong></li></ol><p>这4个关键字都涉及对IL代码栈数据的直接操作，并且都与<code>TypedReference</code>有关</p><h1 id="TypedReference"><a href="#TypedReference" class="headerlink" title="TypedReference"></a>TypedReference</h1><p>那么<code>TypedReference</code>又是什么东西呢？</p><p>简而言之，<code>TypedReference</code>就是一个包装了对象指针和对象类型的结构体</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CSharpUndocumentedKeyword/CSharpUndocumentedKeyword_1.png"></p><h1 id="makeref"><a href="#makeref" class="headerlink" title="__makeref"></a>__makeref</h1><p>此关键字用于使用指定对象创建引用此对象的<code>TypedReference</code></p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CSharpUndocumentedKeyword/CSharpUndocumentedKeyword_2.png"></p><p>对应的IL代码则是直接使用<code>mkrefany</code>指令创建<code>TypedReference</code>对象</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CSharpUndocumentedKeyword/CSharpUndocumentedKeyword_3.png"></p><h1 id="refvalue"><a href="#refvalue" class="headerlink" title="__refvalue"></a>__refvalue</h1><p>此关键字用于从<code>TypedReference</code>获取对象(类型必须一致或可转换)</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CSharpUndocumentedKeyword/CSharpUndocumentedKeyword_4.png"></p><p>对应的IL代码则是直接使用<code>refanyval</code>指令获取对象</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CSharpUndocumentedKeyword/CSharpUndocumentedKeyword_5.png"></p><p>因为<code>TypedReference</code>保存的是对象指针，所以可以通过对<code>__refvalue</code>赋值来修改<strong>tf</strong>所引用变量的值，以实现引用传递的效果</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CSharpUndocumentedKeyword/CSharpUndocumentedKeyword_6.png"></p><h1 id="reftype"><a href="#reftype" class="headerlink" title="__reftype"></a>__reftype</h1><p>此关键字用于从<code>TypedReference</code>中获取对象类型对应的Type</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CSharpUndocumentedKeyword/CSharpUndocumentedKeyword_7.png"></p><p>对应的IL代码则是直接使用<code>refanytype</code>指令获取Type对象<img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CSharpUndocumentedKeyword/CSharpUndocumentedKeyword_8.png"></p><p>结合<code>__makeref</code>,<code>__reftype</code>,<code>__refvalue</code>即可实现无拆装箱开销的通用参数处理</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CSharpUndocumentedKeyword/CSharpUndocumentedKeyword_9.png"></p><h1 id="arglist"><a href="#arglist" class="headerlink" title="__arglist"></a>__arglist</h1><p>此关键字将不定数量的参数打包传递给方法</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CSharpUndocumentedKeyword/CSharpUndocumentedKeyword_11.png"></p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CSharpUndocumentedKeyword/CSharpUndocumentedKeyword_10.png"></p><p>通过<code>__arglist</code>创建专门用于枚举变长参数列表的<code>ArgIterator</code>，即可对所有参数进行操作</p><p>对应的IL代码则是直接通过<code>vararg</code>将参数打包传入方法中</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CSharpUndocumentedKeyword/CSharpUndocumentedKeyword_12.png"></p><p>相比使用<code>params</code>关键字传递变长参数，<code>__arglist</code>不对类型有限制，不会产生额外的装箱开销，对应的IL指令也更少</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>不过比较遗憾的是，<strong>Unity IL2CPP</strong>并不支持以上关键字与<code>TypedReference</code></p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《垃圾回收的算法与实现》7.增量式垃圾回收</title>
      <link href="/2022/07/02/gc-algorithm-notes-7/"/>
      <url>/2022/07/02/gc-algorithm-notes-7/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>通常非引用计数类型的GC算法都是一次性遍历整个堆执行的，这会造成主线程的严重卡顿（Stop-The-World），这在像游戏这样注重帧率平滑性的程序中是难以接受</p><p>因此人们想出了一种不一次性执行完GC，而是将回收过程分为多次去执行的方法，即增量式回收（incremental GC），增量这个词有慢慢发生变化的意思</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes7/GCAlgorithmNotes7_1.png"></p><h1 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h1><p>顾名思义，这个算法将GC中的对象分为3种颜色：</p><ol><li><strong>白色：还未搜索过的对象</strong></li><li><strong>灰色：正在搜索的对象</strong></li><li><strong>黑色：搜索完毕的对象</strong></li></ol><p>以标记-清除法为例，GC一开始运行，所有从根能到达的对象都会被标记然后堆到栈中，GC只是发现了这样的对象，但还没有搜索完它们，所以这些对象就成了灰色对象</p><p>灰色对象会被依次从栈中取出，其子对象也会被涂成灰色，当其所有子对象都被涂成灰色时，对象就被涂成黑色</p><p>当GC结束时已经不存在灰色对象了，活动对象全部为黑色，垃圾则为白色</p><h1 id="标记-清除法的分割"><a href="#标记-清除法的分割" class="headerlink" title="标记-清除法的分割"></a>标记-清除法的分割</h1><p>如果将GC标记-清除法增量运行会怎么样？</p><p>增量式的GC标记-清除法可分为以下3个阶段：</p><ul><li><strong>根查找阶段</strong></li><li><strong>标记阶段</strong></li><li><strong>清除阶段</strong></li></ul><p>在根查找阶段，把直接从根引用的对象涂成灰色</p><p>在标记阶段查找灰色对象，将其子对象也涂成灰色，查找结束后将灰色对象涂成黑色</p><p>在清除阶段查找堆，将白色对象连接到空闲块，将黑色对象变回白色</p><p>其中在标记阶段和清除阶段会进行增量操作，在进行一定次数的操作后中断阶段</p><h1 id="标记遗漏"><a href="#标记遗漏" class="headerlink" title="标记遗漏"></a>标记遗漏</h1><p>标记阶段的暂停可能带来活动对象的标记遗漏</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes7/GCAlgorithmNotes7_2.png"></p><p>如上图，a是刚刚暂停标记阶段的状态，此时A是黑色，B是灰色，C是白色，等下次继续执行标记阶段时就应该对B进行搜索了</p><p>在暂停后，应用程序将A指向B的引用更新为指向C，然后删除B指向C的引用，就变成了c的状态</p><p>这时候如果重新开始标记阶段，B在经过搜索后变成了黑色，然后尽管此时C是活动对象，但仍然不会对其进行搜索，因为已经搜索过唯一指向C的A了</p><p>像这样单纯将GC标记-清除法进行增量，就会造成对活动对象的遗漏，继而在清除阶段错误回收活动对象</p><p>这种问题的原因在于从黑色对象指向白色对象的指针上，一旦产生这种指针，活动对象就不会被标记，为了防止这种情况，在改写指针时需要进行一些处理，这就是”<strong>写入屏障</strong>“</p><h1 id="写入屏障"><a href="#写入屏障" class="headerlink" title="写入屏障"></a>写入屏障</h1><p>写入屏障的逻辑很简单，只需要在新引用一个对象时进行判断，如果其没有被标记，那么就将其标记后堆到标记栈里，换句话说，如果新引用对象是白色对象，就把它涂成灰色</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes7/GCAlgorithmNotes7_3.png"></p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>增量式垃圾回收不是一口气运行GC，所以不会造成对主线程的瞬间卡顿，适合像游戏这样比起提高吞吐量，更重视缩短最大暂停时间的程序</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>在一轮GC花费的总体时间会相比不增量运行的GC要更久</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
          <category> 学习笔记 </category>
          
          <category> 垃圾回收的算法与实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《垃圾回收的算法与实现》6.分代垃圾回收</title>
      <link href="/2022/06/11/gc-algorithm-notes-6/"/>
      <url>/2022/06/11/gc-algorithm-notes-6/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="对象的年龄"><a href="#对象的年龄" class="headerlink" title="对象的年龄"></a>对象的年龄</h2><p>通过经验总结，人们发现：大部分对象在生成后马上就变成了垃圾，很少有对象能活得很久</p><p>分代垃圾回收利用该经验，引入了“对象年龄”的概念，经过一次GC后活下来的对象年龄为1岁</p><h2 id="新生代对象和老年代对象"><a href="#新生代对象和老年代对象" class="headerlink" title="新生代对象和老年代对象"></a>新生代对象和老年代对象</h2><p>分代垃圾回收中将刚生成的对象称为新生代对象，到达一定年龄的对象则是老年代对象</p><p>前面提过，新生代对象绝大部分都会马上变成内存垃圾，如果只对这些新生代对象执行GC，那么相比对所有对象执行GC就会快很多</p><p>另一方面，也会将存活了一定次数的新生代对象提升为老年代对象</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><h2 id="吞吐量得到改善"><a href="#吞吐量得到改善" class="headerlink" title="吞吐量得到改善"></a>吞吐量得到改善</h2><p>“新生代对象会很快变成垃圾”虽然只是经验之谈，不过还是适用于大多数情况的，以这个原则为前提，新生代GC只将刚生成的对象当成需要GC的对象，就能减少时间的消耗</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><h2 id="在部分程序中会起到反作用"><a href="#在部分程序中会起到反作用" class="headerlink" title="在部分程序中会起到反作用"></a>在部分程序中会起到反作用</h2><p>“新生代对象会很快变成垃圾”并非适用于所有程序，对象会活的很久的程序也很多，对这样的程序执行分代垃圾回收会导致：</p><ol><li>新生代GC所花费的世界增多</li><li>老年代GC频繁运行</li></ol><h1 id="多代垃圾回收"><a href="#多代垃圾回收" class="headerlink" title="多代垃圾回收"></a>多代垃圾回收</h1><p>分代垃圾回收将对象分为新生代和老年代，通过尽量减少从新生代晋升到老年代的对象，来减少在老年代对象上消耗的垃圾回收的世间</p><p>在这个基础上，将对象划分为多代的方法就是多代垃圾回收</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes6/GCAlgorithmNotes6_1.png"></p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
          <category> 学习笔记 </category>
          
          <category> 垃圾回收的算法与实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《垃圾回收的算法与实现》5.保守式GC与精准式GC</title>
      <link href="/2022/06/05/gc-algorithm-notes-5/"/>
      <url>/2022/06/05/gc-algorithm-notes-5/</url>
      
        <content type="html"><![CDATA[<h1 id="保守式GC"><a href="#保守式GC" class="headerlink" title="保守式GC"></a>保守式GC</h1><p>保守式GC指的是“不能识别指针和非指针的GC”</p><h2 id="不明确的根"><a href="#不明确的根" class="headerlink" title="不明确的根"></a>不明确的根</h2><p>在之前提到过，下面这些都属于根（root）</p><ul><li>寄存器</li><li>栈变量</li><li>全局变量</li></ul><p>事实上这些都是不明确的根，即不知道它们是指针还是非指针数据</p><p>以调用栈为例，调用栈里装着栈帧，栈帧里有局部变量和参数的值，这些值即可能是int、double这样的非指针，也可能是void*这样的指针，这些值在GC看来就是一堆位的排列，因此GC无法分辨指针和非指针</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes5/GCAlgorithmNotes5_1.png"></p><h2 id="指针和非指针的识别"><a href="#指针和非指针的识别" class="headerlink" title="指针和非指针的识别"></a>指针和非指针的识别</h2><p>在不明确的根中，GC无法识别指针和非指针，也就是说根中所有所有值都可能是指针，然而这样一来，在GC时就会大量出现指针和被错误识别为指针的指针</p><p>因此保守式GC会检查根，按照下述规则识别指针：</p><ol><li>是不是被正确对齐的值？（32位CPU下为4的倍数，64位下是8的倍数）</li><li>是不是指着堆内？</li><li>是不是指着对象的开头？</li></ol><h2 id="貌似指针的非指针"><a href="#貌似指针的非指针" class="headerlink" title="貌似指针的非指针"></a>貌似指针的非指针</h2><p>偶尔会有非指针和堆里的对象的地址一样，此时GC就无法识别出这个值是非指针，这就是“貌似指针的非指针”</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes5/GCAlgorithmNotes5_2.png"></p><p>在面对这种被错误识别为指针的非指针时，GC就会将其“指向”的对象标记为活动对象，而不进行回收</p><p>像这样，在面对可疑对象时采取保守态度对待，宁可放过不可杀错，所以称其为“保守式GC”</p><h2 id="不明确的数据结构"><a href="#不明确的数据结构" class="headerlink" title="不明确的数据结构"></a>不明确的数据结构</h2><p>当基于不明确的根运行GC时，需要从对象头部获取对象的类型信息</p><p>如果能从对象头的标志中获得类型信息，GC就能识别对象域的值是指针还是非指针</p><p>不过数据结构要是像下面这样，就会变成不明确的数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line"><span class="keyword">long</span> n;</span><br><span class="line"><span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; ambiguous_data;</span><br></pre></td></tr></table></figure><p>ambiguous_data是个union，可能包括指针ptr，或非指针n，如果n是一个“貌似指针的非指针”，那么GC就无法识别出它是否确实是个指针</p><p>当对象具有这样的数据结构时，GC不仅会错误识别不明确的根，也会错误识别于里的值</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>保守式GC的优点在于容易编写语言处理程序，处理程序基本不用在意GC就可以编写代码，程序员即使没有意识到GC的存在，程序自己也会回收垃圾，因此语言处理程序的实现比精准式GC简单</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><h3 id="识别指针和非指针需要付出成本"><a href="#识别指针和非指针需要付出成本" class="headerlink" title="识别指针和非指针需要付出成本"></a>识别指针和非指针需要付出成本</h3><p>识别不明确的根和数据结构的值为指针或非指针时，需要付出额外的成本，而这一成本在精准式GC里是不存在的</p><h3 id="错误识别指针会压迫堆"><a href="#错误识别指针会压迫堆" class="headerlink" title="错误识别指针会压迫堆"></a>错误识别指针会压迫堆</h3><p>在存在貌似指针的非指针时，保守式GC会将其指向的对象视为活动对象，如果此对象还存在大量子对象，那么会被一并当做活动对象而不进行回收，这么做会导致垃圾对象严重压迫堆</p><h3 id="能够使用的GC算法有限"><a href="#能够使用的GC算法有限" class="headerlink" title="能够使用的GC算法有限"></a>能够使用的GC算法有限</h3><p>在不能精准识别指针的环境中，是无法使用GC复制法等需要移动对象的GC算法的</p><p>因为GC复制法在复制对象时，会将根中指针对象的值重写为移动后的新对象的地址，这样可能到把非指针对象也重写了</p><p>此外在对象内重写指针时，也有可能因为不明确的数据结构而重写了非指针，最终导致意想不到的Bug发生</p><h1 id="精准式GC"><a href="#精准式GC" class="headerlink" title="精准式GC"></a>精准式GC</h1><p>精准式GC和保守式GC正好相反，它能识别出指针和非指针</p><h2 id="明确的根"><a href="#明确的根" class="headerlink" title="明确的根"></a>明确的根</h2><p>精准式GC是基于能准确识别指针和非指针的“明确的根”运行的</p><p>创建明确的根的方法很多，但都需要语言处理程序的支持</p><h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p>第一个方法就是打标签（tag），目的是将不明确的根中的指针和非指针区分开来，此处以最基本的低1位法为例</p><p>在32位CPU下，指针是4的倍数，低2位一定是0，可以利用这个特性来识别指针和非指针</p><p>打标签的具体方法如下</p><ol><li>将非指针（int等）左移1位(a &lt;&lt; 1)</li><li>将低1位或1(a | 1)</li></ol><p>需要注意，在对数值打标签时，要注意不要让数据溢出，左移1位如果数据溢出了，就得再变换一个大的数据类型</p><p>用这种方法打标签的话，处理程序的数值就会都是奇数，在进行计算时必须取消标签再运算</p><h2 id="不把寄存器和栈当做根"><a href="#不把寄存器和栈当做根" class="headerlink" title="不把寄存器和栈当做根"></a>不把寄存器和栈当做根</h2><p>还有一种方法就是不把寄存器和栈等不明确的根当做根来用，而在处理程序里创建根</p><p>具体思路就是创建一个明确的根来管理，以其为基础执行GC</p><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><p>精准式GC完全没有保守式GC固有的问题——错误识别指针，它不会认为已经死了的对象还活着，GC后堆里只会留下活动对象</p><p>此外还支持实现GC复制法等需要移动对象的算法，因为它能明确分辨出非指针，即使移动对象，重写根的值，这个对象也不可能是非指针</p><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>当创建精准式GC时，必须得到语言处理程序的支持，因此实现上比保守式GC麻烦</p><p>此外，要创建明确的根必须付出一定的代价，比如打标签后，就必须每次计算都压取消标签，计算完后再重新设置</p><h1 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h1><h2 id="经由句柄引用对象"><a href="#经由句柄引用对象" class="headerlink" title="经由句柄引用对象"></a>经由句柄引用对象</h2><p>保守式GC无法移动对象是以为可能重写了非指针的值</p><p>解决这个问题的办法就是用句柄（handler）来间接引用对象</p><p>从下图中可以看到，根和堆对象之间隔了层句柄，每个堆对象对应一个句柄，句柄持有指向堆对象的指针</p><p>不明确的根里没有指向对象的指针，只有指向句柄的指针</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes5/GCAlgorithmNotes5_3.png"></p><p>只要采用了间接引用，那么即使移动了对象，也不用该写根中的值，只需要改写句柄的值即可</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes5/GCAlgorithmNotes5_4.png"></p><p>而且在对象内没有经由句柄指向别的对象，只有从根引用对象时才会经由句柄</p><p>此外，使用了间接引用的GC仍然是保守式GC，无法分辨指针和非指针</p><h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><p>使用间接引用的情况下有可能实现GC复制法、标记-压缩法等</p><h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><p>因为所有对象都经由句柄间接引用，所以会拉低访问对象内数据的速度</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
          <category> 学习笔记 </category>
          
          <category> 垃圾回收的算法与实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《垃圾回收的算法与实现》4.标记-压缩法</title>
      <link href="/2022/05/28/gc-algorithm-notes-4/"/>
      <url>/2022/05/28/gc-algorithm-notes-4/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>标记-压缩法是将标记-清除法和复制法结合起来的产物，由<strong>标记阶段</strong>和<strong>压缩阶段</strong>组成</p><ul><li>标记阶段：此阶段与标记-清除法提到的标记阶段完全一样</li><li>压缩阶段：此阶段通过数次搜索堆来重新装填活动对象</li></ul><h1 id="Lisp2算法"><a href="#Lisp2算法" class="headerlink" title="Lisp2算法"></a>Lisp2算法</h1><h2 id="对象结构"><a href="#对象结构" class="headerlink" title="对象结构"></a>对象结构</h2><p>Lisp2算法在对象头中定义了一个forwarding指针，其用法和复制法中的用法一致(<a href="http://cathole.top/2022/04/17/gc-algorithm-notes-3/">《垃圾回收的算法与实现》3.复制法</a>)</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes4/GCAlgorithmNotes4_1.png"></p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>假设以下图的堆空间开始GC：</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes4/GCAlgorithmNotes4_2.png"></p><p>首先是<strong>标记阶段</strong>，标记完成后堆空间如下图所示：</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes4/GCAlgorithmNotes4_3.png"></p><p><strong>压缩阶段</strong>结束后的堆空间：</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes4/GCAlgorithmNotes4_4.png"></p><p>在Lisp2算法中，压缩阶段并不会改变对象的排列顺序，只是将它们变得更紧凑了</p><p>压缩阶段由以下3个步骤组成：</p><ol><li>设定forwarding指针</li><li>更新指针</li><li>移动对象</li></ol><h2 id="设定forwarding指针"><a href="#设定forwarding指针" class="headerlink" title="设定forwarding指针"></a>设定forwarding指针</h2><p>在此步骤中，会搜索整个堆，为活动对象设定forwarding指针，将其指向</p><p>预计要移动到的地址</p><p>此步骤结束后的堆空间如下：</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes4/GCAlgorithmNotes4_5.png"></p><h2 id="更新指针"><a href="#更新指针" class="headerlink" title="更新指针"></a>更新指针</h2><p>此步骤首先会更新根节点的指向，使所有root指向root.forwarding，然后会搜索整个堆，使所有指向活动对象的指针都改为指向此指针的forwarding</p><p>此步骤结束后的堆空间如下：</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes4/GCAlgorithmNotes4_5.png"></p><h2 id="移动对象"><a href="#移动对象" class="headerlink" title="移动对象"></a>移动对象</h2><p>此步骤会将所有活动对象移动到forwarding指向的地址处（注意：此时已经是第3次搜索整个堆了）</p><p>此步骤结束后的堆空间如下：</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes4/GCAlgorithmNotes4_6.png"></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><h3 id="可有效利用堆"><a href="#可有效利用堆" class="headerlink" title="可有效利用堆"></a>可有效利用堆</h3><p>标记-压缩法和其他GC算法相比，对堆空间的利用率更高，在防止出现标记-清除法可能导致的内存碎片的情况下，不会出现复制法那样只能利用一半堆空间的情况</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><h3 id="压缩花费成本高"><a href="#压缩花费成本高" class="headerlink" title="压缩花费成本高"></a>压缩花费成本高</h3><p>Lisp2算法的压缩中，必须对整个堆进行3次搜索，因此吞吐量要劣于其他算法</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
          <category> 学习笔记 </category>
          
          <category> 垃圾回收的算法与实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《垃圾回收的算法与实现》3.复制法</title>
      <link href="/2022/04/17/gc-algorithm-notes-3/"/>
      <url>/2022/04/17/gc-algorithm-notes-3/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>GC复制法将堆空间分为两块空间（From和To），当From空间被全部占满时，会将其中的活动对象全部复制到To空间，然后回收From空间，复制完成后会将From和To空间互换</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes3/GCAlgorithmNotes3_1.png"></p><p>复制法下的对象有2个额外的域成员</p><ol><li>tag：用于标记此对象是否已被复制过</li><li>forwarding：用于指向此对象被复制后的新对象。方便将原来指向此的指针指到新对象上</li></ol><h1 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h1><p>假设以下图的堆空间开始GC</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes3/GCAlgorithmNotes3_2.png"></p><p>首先从根出发，将B复制到To空间，将复制后的对象称为B’，此时B的tag被勾选，forwarding也指向了B’</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes3/GCAlgorithmNotes3_3.png"></p><p>接下来把B的子对象A也复制到To空间，这样才算真正意义上复制了B，因为A没有子对象，所以对A的复制也完成了</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes3/GCAlgorithmNotes3_4.png"></p><p>然后复制对象G及其子对象E，虽然B也是G的子对象，但B已经复制过了，只需要将指向B的指针指到B’上就行</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes3/GCAlgorithmNotes3_5.png"></p><p>最后互换From和To，GC就结束了</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><h2 id="优秀的吞吐量"><a href="#优秀的吞吐量" class="headerlink" title="优秀的吞吐量"></a>优秀的吞吐量</h2><p>标记-清除法消耗的吞吐量是搜索活动对象所花费的时间和搜索整体堆所花费的时间</p><p>而复制法只搜索并复制活动对象，所以相比标记-清除法能更快的完成GC，也就是说吞吐量优秀</p><h2 id="可实现高速分配"><a href="#可实现高速分配" class="headerlink" title="可实现高速分配"></a>可实现高速分配</h2><p>复制法不使用空闲链表，因为To分块是一个连续的内存空间，可以直接进行分配，不需要遍历空闲链表然后找分块</p><h2 id="不会发生碎片化"><a href="#不会发生碎片化" class="headerlink" title="不会发生碎片化"></a>不会发生碎片化</h2><p>GC后活动对象都被集中分配在了From空间开头，像这样把对象重新集中，放在堆一段的行为叫做压缩，在复制法每次运行GC后都会执行压缩，因此不会发生碎片化</p><h2 id="与缓存兼容"><a href="#与缓存兼容" class="headerlink" title="与缓存兼容"></a>与缓存兼容</h2><p>在复制法中有引用关系的对象都会被安排在堆里离彼此较接近的位置，使得在CPU读取对象时容易发生缓存命中</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><h2 id="堆使用效率低下"><a href="#堆使用效率低下" class="headerlink" title="堆使用效率低下"></a>堆使用效率低下</h2><p>复制法将堆二等分，通常只能利用其中的一半安排对象，相比能使用整个堆的GC算法而言，可以说这是复制法的一个重大缺陷</p><h2 id="不兼容保守式GC算法"><a href="#不兼容保守式GC算法" class="headerlink" title="不兼容保守式GC算法"></a>不兼容保守式GC算法</h2><p>复制法必须移动对象重写指针，所以与要求不能移动对象的保守式GC不兼容</p><h2 id="递归调用函数"><a href="#递归调用函数" class="headerlink" title="递归调用函数"></a>递归调用函数</h2><p>在复制某个对象时要递归复制其子对象，容易产生栈溢出。为了解决这个问题有人提出了使用迭代进行复制的算法</p><h1 id="多空间复制法"><a href="#多空间复制法" class="headerlink" title="多空间复制法"></a>多空间复制法</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>复制法最大的缺点就是只能利用半个堆，为了解决这个问题可以把堆再作细分</p><p>例如：将堆分成10份，其中拿出2份分别作为From和To空间执行GC复制法，对剩下8份空间执行标记-清除法，也就是说将两种算法组合起来使用</p><h2 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h2><p>首先假设份数为4</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes3/GCAlgorithmNotes3_6.png"></p><p>然后执行GC，对heap[0]和heap[1]执行复制法，对heap[2]和heap[3]执行标记-清除法</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes3/GCAlgorithmNotes3_7.png"></p><p>并将To和From分别后移一个位置，设想再次没有了分块需要GC的情况</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes3/GCAlgorithmNotes3_8.png"></p><p>此时再次执行GC</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes3/GCAlgorithmNotes3_9.png"></p><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><p>多空间复制法相比普通复制法能更有效的利用堆空间</p><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>但因为对于其他空间使用了标记-清除法，因此就出现了标记-清除法固有的问题——分配耗时、分块碎片化等</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
          <category> 学习笔记 </category>
          
          <category> 垃圾回收的算法与实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《垃圾回收的算法与实现》2.引用计数法</title>
      <link href="/2022/03/14/gc-algorithm-notes-2/"/>
      <url>/2022/03/14/gc-algorithm-notes-2/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>顾名思义，引用计数法就是通过在对象身上放置一个<strong>“计数器”</strong>来统计此对象被多少其他对象引用了</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes2/GCAlgorithmNotes2_1.png"></p><p>在引用计数法中没有明确启动GC的语句，它是通过计数器的增减来进行内存管理的，而在创建对象和更新指针时会修改计数器</p><h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>和标记-清除法相同，引用计数法在创建对象时回去寻找空闲分块，若找不到会直接认为分配失败了（因为在引用计数法中除了空闲链表外的对象都是活动对象）</p><p>当找到了合适的分块后会初始化其计数器为1</p><h2 id="更新指针"><a href="#更新指针" class="headerlink" title="更新指针"></a>更新指针</h2><p>在将一个对象obj赋值给一个指针*ptr前，会先增加新引用对象obj的计数器，然后减少ptr之前引用对象的计数器（这里的顺序不能变，否则在*ptr和obj是同一对象时会导致obj被错误回收了）</p><p>指针更新的重点在于减少计数器时的处理</p><p>减少计数器后，如果其值为0，就意味着此对象变成了”垃圾“，需要被回收，此时此对象引用的其他对象都会被递归减少计数器，最后会将此对象连接到空闲链表表示它已经被回收了</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes2/GCAlgorithmNotes2_2.png"></p><p>以上图为例，初始化状态下根引用了A和C，A持有唯一指向B的指针，假设现在将A的指针指向C，那么B就会因为计数器为0被回收至空闲链表中，同时C的计数器也变为了2</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><h2 id="可即刻回收垃圾"><a href="#可即刻回收垃圾" class="headerlink" title="可即刻回收垃圾"></a>可即刻回收垃圾</h2><p>在引用计数法中，每个对象都始终知道自己的被引用数，只要计数器变为了0就可以马上将其回收，这就使得内存空间中不会被闲置的垃圾占据，垃圾全部都在变成垃圾的那一刻被连接到了空闲链表等待下一次使用</p><p>而在其他GC算法中，即使对象变成了垃圾也无法立马被识别，只有当分块用尽后需要GC执行才能知道哪些对象已经变成垃圾了</p><p>也就是说在GC执行前始终有一部分内存空间被垃圾占用</p><h2 id="最大暂停时间短"><a href="#最大暂停时间短" class="headerlink" title="最大暂停时间短"></a>最大暂停时间短</h2><p>引用计数法在回收垃圾时不需要遍历整个堆，只要对象不再被引用了就能马上将其回收，因此不会导致主线程长时间暂停</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><h2 id="计数器的增减处理频繁"><a href="#计数器的增减处理频繁" class="headerlink" title="计数器的增减处理频繁"></a>计数器的增减处理频繁</h2><p>大多数情况下指针都会频繁更新，特别是有根的指针，这就导致了对于计数器的增减处理会非常频繁</p><h2 id="计数器需要占用很多位"><a href="#计数器需要占用很多位" class="headerlink" title="计数器需要占用很多位"></a>计数器需要占用很多位</h2><p>用于引用计数的计数器最大必须能数完整个堆的所有对象，也就是说必须能包含整个内存地址（比如32位机器的计数器就得有32位大小），这就使得对象占据的内存空间会变大</p><h2 id="实现麻烦"><a href="#实现麻烦" class="headerlink" title="实现麻烦"></a>实现麻烦</h2><p>虽然引用计数的算法本身简单，但实现起来却很麻烦</p><p>需要在每个赋值指针的地方<code>*ptr = &amp;obj</code>都将其重写为更新指针的函数<code>update_ptr(ptr,obj)</code>，如果其中出现遗漏的地方就会引起内存泄露的Bug</p><h2 id="循环引用无法回收"><a href="#循环引用无法回收" class="headerlink" title="循环引用无法回收"></a>循环引用无法回收</h2><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes2/GCAlgorithmNotes2_3.png"></p><p>如果两个对象互相引用对方会导致两个对象都无法被回收掉，这点可以说是引用计数法的致命缺点了</p><h1 id="改良"><a href="#改良" class="headerlink" title="改良"></a>改良</h1><h2 id="延迟引用计数法"><a href="#延迟引用计数法" class="headerlink" title="延迟引用计数法"></a>延迟引用计数法</h2><p>针对计数器的增减处理频繁这个问题，有人提出了“延迟引用计数法”</p><p>如前所述，计数器值增减处理频繁的原因之一是从根出发的引用会频繁更新，因此，可以让从根引用的指针的变化不反应在计数器上，而是反应到ZCT(zero count table)上</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes2/GCAlgorithmNotes2_4.png"></p><p>ZCT是一个表，记录下所有计数器值被减少为0的对象</p><p>而在分配对象时，如果没在空闲链表中找到合适分块，就会去ZCT表里搜索一遍以再次分配分块（往ZCT里放对象时如果容量爆满了也会进行一次搜索），如果还不行就认为分配失败了</p><p>那么是如何搜索ZCT的呢？</p><p>会先把ZCT中所有通过根直接引用的对象的计数器都+1，这样才算把根引用反应到了计数器的值上，接下来会把ZCT中计数器还是0的对象都回收掉，最后将根引用对象的计数器都-1</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>延迟了根引用的计数，将垃圾一并回收，减少了因根引用频繁发生变化而导致计数器增减带来的额外负担</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>为了延迟计数器增减，垃圾不能马上回收，这就失去了引用计数法的一大优点——可即刻回收垃圾，另外因为要搜索ZCT也导致了最大暂停时间延长了</p><p>要缩减暂停时间，就要缩小ZCT，但是这样搜索频率就会增加，导致压低了吞吐量</p><h2 id="Sticky引用计数法"><a href="#Sticky引用计数法" class="headerlink" title="Sticky引用计数法"></a>Sticky引用计数法</h2><p>此方法是用来减少计数器位宽的，假设用于计数器的位数为5位，那么此计数器最多只能数到2的5次方减1，也就是31个引用数，如果被大于31个对象引用就会使得计数器溢出</p><p>针对计数器溢出，需要暂停对计数器的管理，对付这种对象主要有两种方法</p><h3 id="什么都不做"><a href="#什么都不做" class="headerlink" title="什么都不做"></a>什么都不做</h3><p>对于计数器溢出的对象，可以对其什么也不做，但这样一来，即使它成为了垃圾也不能将其回收，也就是说，白白浪费了内存空间</p><p>然而事实表明，很多对象一生成马上就死了，也就是说很多对象的计数器值只会在0和1之间变化，很少出现计数器溢出的情况</p><p>此外，因为计数器溢出的对象在占有非常重要的地位，可想而知其成为垃圾的可能性也很低，所以放着不管也不会有什么大问题</p><h3 id="使用标记-清除法管理"><a href="#使用标记-清除法管理" class="headerlink" title="使用标记-清除法管理"></a>使用标记-清除法管理</h3><p>另一个方法是在适当时机使用标记-清除法来充当引用计数法的后援，但和通常的标记-清除法不同</p><p>首先，在标记阶段之前，会先把所有对象计数器重置回0</p><p>在标记阶段，会把所有从根出发能引用到的对象的计数器+1</p><p>在清除阶段，会遍历整个堆，回收计数器为0的对象</p><p>这个方法除了能回收计数器溢出的对象，还能处理循环引用，但是因为需要多次查找活动对象，会需要更长的暂停时间</p><h2 id="1位引用计数法"><a href="#1位引用计数法" class="headerlink" title="1位引用计数法"></a>1位引用计数法</h2><p>这是Sticky引用计数法的一个极端例子</p><p>只使用1位来表示对象的被引用数是1个还是多个，因此于其叫它计数器不如叫它“标签”更合适</p><p>此外引用计数法一般让对象持有计数器，此方法不同，是让指针持有计数器的</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes2/GCAlgorithmNotes2_5.png"></p><p>设对象引用数为1时标签位为0，大于1时标签位为1，分别称以上两种状态为Unique和Multiple</p><h3 id="复制指针"><a href="#复制指针" class="headerlink" title="复制指针"></a>复制指针</h3><p>1位引用计数法也是在更新指针的时候进行内存管理的，不过它不是通过指定要引用的对象来更新指针（<code>*ptr = &amp;obj</code>）,而是通过复制某个指针来更新指针（<code>dest_ptr = src_ptr</code>）</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes2/GCAlgorithmNotes2_6.png"></p><p>以上图为例，更新了A，使其从引用D变成了引用C，这里也可以看成是把B到C的指针复制给了A</p><p>具体步骤，就是：</p><ol><li>先尝试回收A指针原来引用的对象(<code>deletePtr(A)</code>)</li><li>将B复制给A(<code>A = B</code>)</li><li>将A设置为Multiple状态（因为这时A指向的对象至少是被A和B同时引用着了）</li><li>如果B是Unique，那么将其改为Multiple</li></ol><h3 id="回收对象"><a href="#回收对象" class="headerlink" title="回收对象"></a>回收对象</h3><p>只有当指针的标签是Unique时才会进行回收，如果是Multiple就意味着还存在其他引用此对象的指针，无法进行回收</p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>1位引用计数法的优点是不容易出现<strong>高速缓存缺失(Cache Miss)</strong></p><p>以往的引用计数法将计数器放在对象上，当A要引用在内存中离它很远的对象B时，需要在读取B然后增减B的计数器值，从而导致高速缓存缺失</p><p>但对于1位引用计数法来说，完全不需要再更新计数器时读取要引用的对象，只需要操作指针即可</p><p>此外因为没必要给计数器留出多余空间，所以节省了内存消耗量，也是此方法的一个优点</p><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>1位引用计数法的缺点和Sticky引用计数法一样，需要考虑如何处理计数器溢出的对象</p><h2 id="部分标记-清除法"><a href="#部分标记-清除法" class="headerlink" title="部分标记-清除法"></a>部分标记-清除法</h2><p>为了处理引用计数法不能回收循环引用的问题，可以采用只对“可能有循环引用的对象群”进行标记清除的方法，这就是“部分标记-清除法</p><p>一般的标记-清除法目的是查找活动对象，而此方法的目标则是查找非活动对象</p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>在部分标记-清除法中，对象会被涂成4种不同的颜色进行管理</p><ol><li>黑：绝对不是垃圾的对象（对象产生时的初始颜色）</li><li>白：绝对是垃圾的对象</li><li>灰：搜索完毕的对象</li><li>阴影：可能是循环垃圾的对象</li></ol><p>为了解释算法，我们先假设一个堆，它里面的对象和引用关系如图</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes2/GCAlgorithmNotes2_7.png"></p><h3 id="计数器减少"><a href="#计数器减少" class="headerlink" title="计数器减少"></a>计数器减少</h3><p>接下来，删除由根到对象A的引用</p><p>在将计数器-1后，如果对象不是阴影的，那么就将其涂上阴影并放入阴影队列中</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes2/GCAlgorithmNotes2_8.png"></p><p>阴影队列的存在是为了存放那些可能是循环引用的一部分的对象，此队列内的对象会作为标记-清除法的对象，是的循环引用的垃圾被回收</p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>当有分块可以进行分配时，会将对象涂回黑色</p><p>若无法分配，会搜索阴影队列寻找分块，然后再次尝试分配</p><h3 id="搜索阴影队列"><a href="#搜索阴影队列" class="headerlink" title="搜索阴影队列"></a>搜索阴影队列</h3><p>搜索阴影队列时，会在找到阴影对象前一直从队列中取出对象</p><p>如果成功找到了阴影对象，会依次对其进行涂抹灰色对象，扫描灰色对象，回收白色对象的操作，最后找出循环引用的垃圾，将其回收</p><h3 id="涂抹灰色对象"><a href="#涂抹灰色对象" class="headerlink" title="涂抹灰色对象"></a>涂抹灰色对象</h3><p>这个操作会把黑色或者阴影对象涂成灰色，对子对象进行计数器-1并对其进行涂抹灰色对象操作，最终有循环引用的对象计数器都被归0了</p><p>把对象涂成灰色是为了防止程序重复搜索</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes2/GCAlgorithmNotes2_9.png"></p><h3 id="扫描灰色对象"><a href="#扫描灰色对象" class="headerlink" title="扫描灰色对象"></a>扫描灰色对象</h3><p>这个操作会搜索灰色对象，把计数器为0的对象涂成白色</p><p>对于计数器大于0的对象，会将其涂成黑色，然后对子对象进行计数器+1并将其涂成黑色的操作，最终从那些可能被涂成了灰色的有循环引用的对象群里，找出不是垃圾的对象</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes2/GCAlgorithmNotes2_10.png"></p><p>不难看出，形成了循环垃圾的对象 A、B、C 被涂成了白色，而有循环引用的非垃圾对象 D、E、F 被涂成了黑色</p><h3 id="回收白色对象"><a href="#回收白色对象" class="headerlink" title="回收白色对象"></a>回收白色对象</h3><p>这个操作只会查找白色对象进行回收，循环垃圾此时也会被回收掉了</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes2/GCAlgorithmNotes2_11.png"></p><h3 id="限定搜索对象"><a href="#限定搜索对象" class="headerlink" title="限定搜索对象"></a>限定搜索对象</h3><p>部分标记-清除法的优点，就是把要搜索的对象限定在阴影对象及其子对象，也就是可能产生循环垃圾的对象群中，那么要怎么发行这样的对象群呢？</p><p>问题的关键在于循环垃圾产生的过程</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes2/GCAlgorithmNotes2_12.png"></p><p>如上图，满足下面2种情况时就会产生循环垃圾</p><ol><li>产生循环引用</li><li>删除从外部到循环引用的引用</li></ol><p>注意在上图第2步时，A的计数器从2变成了1</p><p>这意味着如果对象的计数器值在减少后不为0，就说明它可能是循环引用的一份子，这时会先将其放入阴影队列，方便之后搜索它</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>部分标记-清除法从队列搜索对象付出的成本很大，因为队列里存放的都是候选垃圾，所以要搜索的对象绝对不在少数</p><p>而且总计需要查找3次对象，也就是说需要对从队列里取出的阴影对象分别进行涂抹灰色、扫描灰色和回收白色的操作，这大大增加了内存管理花费的时间</p><p>此外还失去了引用计数法暂停时间短的优点</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
          <category> 学习笔记 </category>
          
          <category> 垃圾回收的算法与实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《垃圾回收的算法与实现》1.标记-清除法</title>
      <link href="/2022/03/13/gc-algorithm-notes-1/"/>
      <url>/2022/03/13/gc-algorithm-notes-1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>垃圾回收（Garbage Collection，后文简称GC）是一种程序运行时的自动内存管理技术</p><p>其作用主要在于防止因手动管理内存导致的诸如<strong>内存泄露</strong>，<strong>悬垂指针</strong>等问题的发生，减少程序员在开发时的心智负担</p><p>GC的基础算法有3种：</p><ol><li>标记-清除法</li><li>引用计数法</li><li>复制法</li></ol><p>后世的诸多GC算法都是在这3种基础算法上衍生而来的</p><h1 id="基本概念说明"><a href="#基本概念说明" class="headerlink" title="基本概念说明"></a>基本概念说明</h1><h2 id="对象-头-域"><a href="#对象-头-域" class="headerlink" title="对象/头/域"></a>对象/头/域</h2><p>在GC的世界中，对象表示的是”数据的集合“，可理解为GC进行回收的基本单位，即GC管理的是一个个对象</p><p>对象由头(header)和域(field)组成</p><h3 id="头"><a href="#头" class="headerlink" title="头"></a>头</h3><p>对象中保存对象本身信息的部分称为头，包括：对象大小，对象种类，此外还会根据GC算法的不同保存不同的额外信息（比如标记-清除法会在对象头部设置1个flag记录此对象是否已标记）</p><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>域可简单理解为对象中的字段，分为指针和非指针</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes1/GCAlgorithmNotes1_1.png"></p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>GC根据指针去搜寻到其他对象，对非指针不进行任何操作</p><p>需要注意2点：</p><ol><li>GC是否能判别指针和非指针</li><li>指针指向对象的哪个部分。如果指向对象首地址以外的部分，GC就会变得非常复杂，因此在大多数语言中指针都默认指向对象首地址</li></ol><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes1/GCAlgorithmNotes1_2.png"></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆(heap)指的是用于动态存放对象的内存空间，GC管理的即是堆中的对象，当堆被对象占满时GC就会启动，从而分配可用空间，如果GC后空间还是不够，就需要扩大堆</p><p>活动对象/非活动对象</p><p>活动对象指的是那些被引用着的对象，反之已经没被引用的对象就是非活动对象，即“垃圾”</p><p>GC会保留活动对象，销毁非活动对象</p><h2 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h2><p>分块(chunk)指事先准备的堆内存空间</p><p>初始状态下，堆被一个大的分块占据，程序会把这个分块分割成合适的大小，作为活动对象使用</p><p>活动对象不久后会变成垃圾被回收，此时这部分被回收的内存空间再次成为分块，为下次被利用做准备</p><p>内存里的各个分块都重复着分块→活动对象→垃圾→分块→……这样的过程</p><h2 id="根"><a href="#根" class="headerlink" title="根"></a>根</h2><p>根(root)指的是指向对象的指针的起点部分</p><p>一般而言，静态变量，局部变量，寄存器都是根对象</p><h2 id="评价标准"><a href="#评价标准" class="headerlink" title="评价标准"></a>评价标准</h2><p>评价GC算法性能时，有以下4个标准</p><ol><li>吞吐量（堆内存大小/总GC耗时）</li><li>最大暂停时间（单次GC最大的耗时）</li><li>堆使用效率（对堆的额外占用与管理范围）</li><li>访问的局部性（缓存命中率）</li></ol><h1 id="标记-清除法"><a href="#标记-清除法" class="headerlink" title="标记-清除法"></a>标记-清除法</h1><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p>标记-清除法由标记阶段和清除阶段组成</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes1/GCAlgorithmNotes1_3.png"></p><p>标记阶段从根从发，将所有活动对象做上标记</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes1/GCAlgorithmNotes1_4.png"></p><p>清除阶段则会遍历堆，将没有标记到的那些非活动对象回收（放入空闲链表）</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes1/GCAlgorithmNotes1_5.png"></p><p>因为需要遍历整个堆，所以标记-清除法花费的时间与堆大小成正比</p><h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>在清除阶段已经将所有非活动对象回收进空闲链表了，那么分配就是搜索空闲链表寻找大小合适的分块</p><p>搜索策略有以下3种：</p><ol><li>First-fit（返回第一个大小等于目标大小的分块，若找到的分块大于目标大小，将其分割为目标大小和剩余大小）</li><li>Best-fit（返回大小等于目标大小的最小分块）</li><li>Worst-fit（找出空闲链表中最大的分块，将其分割为目标大小和剩余大小，目的是将分割后剩余的分块最大化，但是容易生成大量小分块）</li></ol><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>在进行数次的分配与回收后，可能会产生大量小分块，如果它们是连续的，就能把所有小分块连在一起形成大分块，这就是合并，合并是在清除阶段进行的</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><p>标记-清除法的实现简单，只有标记和清除两个阶段，容易与其他GC算法相结合</p><h3 id="与保守式GC算法兼容"><a href="#与保守式GC算法兼容" class="headerlink" title="与保守式GC算法兼容"></a>与保守式GC算法兼容</h3><p>保守式GC算法对象是不能被移动的，因此与需要移动对象的复制法以及标记-压缩法不兼容，但标记-清除法不需要移动对象</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><h3 id="碎片化"><a href="#碎片化" class="headerlink" title="碎片化"></a>碎片化</h3><p>在标记-清除法的使用过程中会产生大量被细化的分块，不久就会导致无数小分块散步在堆的各处，这就是碎片化</p><p>如果发生碎片化，那么即使堆中分块总大小够用，也会因为分块都太小导致内存分配失败</p><p>为了避免碎片化，可以采用<strong>内存压缩</strong>，或者<strong>BiBOP</strong>法</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes1/GCAlgorithmNotes1_6.png"></p><h3 id="分配速度"><a href="#分配速度" class="headerlink" title="分配速度"></a>分配速度</h3><p>因为分块不连续，所以每次分配都要遍历空闲链表，找到足够大的分块，最糟的情况就是每次分配都要遍历链表到最后一个节点</p><p>而在复制法和标记-压缩法中，分块是连续的内存空间，没必要遍历空闲链表，分配就能高速进行，而且能在堆范围内分配很大的对象</p><p>后面会提到的<strong>多个空闲链表</strong>和<strong>BiBOP</strong>法都是为了能在标记-清除法中高速分配而想出的办法</p><h3 id="与写时复制技术不兼容"><a href="#与写时复制技术不兼容" class="headerlink" title="与写时复制技术不兼容"></a>与写时复制技术不兼容</h3><p>写时复制技术(copy on write)简单来说就是在复制数据时不真正的进行复制，而是假装复制了，实际上是用的共享数据，到了需要写入数据时才复制一份数据作为自己的数据然后进行写入操作</p><p>标记-清除法下，即使没有重写对象，也会设置所有活动对象的标志位，这样就会频繁发生本不应该发生的赋值，压迫到内存空间</p><p>为了处理这个问题，需要采用<strong>位图标记</strong>法(bitmap marking)</p><h2 id="多个空闲链表"><a href="#多个空闲链表" class="headerlink" title="多个空闲链表"></a>多个空闲链表</h2><p>标记-清除法在只用一个空闲链表的情况下分配速度太慢，为了提高速度，需要根据分块大小创建多个空闲链表，比如创建只连接大分块的和只连接小分块的</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes1/GCAlgorithmNotes1_7.png"></p><p>这里有一个问题就是到底创建多少个空闲链表比较好？</p><p>通常会给分块大小设定一个上限，超出此上限的统一扔进一个空闲链表里处理（虽然这样会导致对于非常大的分块的搜索效率很低，但因为分配这种大小的情况很罕见，所以也是可以接受的，更重要的是怎么去更快的搜索需要频繁分配的小分块）</p><h2 id="BiBOP法"><a href="#BiBOP法" class="headerlink" title="BiBOP法"></a>BiBOP法</h2><p>BiBOP法(Big Bag Of Pages)用一句话概括就是“将大小相近的对象整理成固定大小的块进行管理的做法”</p><p>因为标记-清除法会产生碎片化，导致堆上杂乱散布着大小各异的对象，对此就可以使用此方法：把堆分割成固定大小的块，让每个块只能配置同样大小的分块</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes1/GCAlgorithmNotes1_8.png"></p><p>这样配置对象能提高内存的使用效率，因为每个块中只能配置同样大小的对象，所以不可能出现大小不均的分块</p><p>但是BiBOP法并不能完全消除碎片化，比如在全部用于2个字的块中，只有1到2个活动对象，就不算是有效利用了堆</p><h2 id="位图标记"><a href="#位图标记" class="headerlink" title="位图标记"></a>位图标记</h2><p>用于标记的位是被分配到各个对象头中的，也就是说是把对象和头一并处理的，这与写时复制技术不兼容</p><p>对此，可以只收集各个对象的标志位并表格化，不与对象一起管理，在标记时不在对象头中置位，而是在表格中的特定场所置位，这样的表格就是“位图表格，利用这个表格进行标记的行为就是”位图标记“</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/GCAlgorithmNotes1/GCAlgorithmNotes1_9.png"></p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>与写时复制技术兼容</p><p>清除操作更高效（可以快速消去标志位）</p><h3 id="要注意的地方"><a href="#要注意的地方" class="headerlink" title="要注意的地方"></a>要注意的地方</h3><p>在进行位图标记时，必须注意对象地址和位图表格的对应，在堆有多个，对象地址不连续的时候，一般会为每个堆都准备一个位图表格</p><h2 id="延迟消除法"><a href="#延迟消除法" class="headerlink" title="延迟消除法"></a>延迟消除法</h2><p>在前面提到过，标记-清除法在清除操作所花费的时间和堆大小成正比，延迟清除法是在标记结束后，不立马进行清除，而是通过延迟防止主线程长时间暂停</p><p>那么什么时候进行清除呢？</p><p>在分配对象内存时会进行延迟清除，以找到一个适合的分块，如果此时找不到会进行一遍标记操作，然后再进行第二次延迟清除，这次如果再找不到适合的分块就意味着内存分配失败了</p><p>因为延迟清除法不是一下遍历整个堆，而只在分配时执行必要的遍历，所以可以压缩因清除操作导致的主线程暂停时间</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
          <category> 学习笔记 </category>
          
          <category> 垃圾回收的算法与实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改LitJson以支持int类型的字典Key</title>
      <link href="/2022/01/17/litjson-support-dict-int-key/"/>
      <url>/2022/01/17/litjson-support-dict-int-key/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前几天因为项目需求，需要使用Json来做某个功能的数据的序列化，但不能引入新的第三方库，所以只能使用项目里已有的LitJson库</p><p>然而后面要用到int类型作为字典Key，但是LitJson又不支持这种做法，所以只能自己想办法对其源码进行修改</p><h1 id="源码修改"><a href="#源码修改" class="headerlink" title="源码修改"></a>源码修改</h1><p>要做到支持字典key为int类型，只需要对JsonMapper.cs文件进行修改即可</p><p>总共需要修改3个方法</p><h2 id="AddObjectMetadata"><a href="#AddObjectMetadata" class="headerlink" title="AddObjectMetadata"></a>AddObjectMetadata</h2><p>在AddObjectMetadata方法中，修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (PropertyInfo p_info <span class="keyword">in</span> type.GetProperties())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p_info.Name == <span class="string">&quot;Item&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//字典key除了是字符串还可以是int</span></span><br><span class="line">        <span class="keyword">if</span> (parameters[<span class="number">0</span>].ParameterType == <span class="keyword">typeof</span>(<span class="built_in">string</span>) || parameters[<span class="number">0</span>].ParameterType == <span class="keyword">typeof</span>(<span class="built_in">int</span>))</span><br><span class="line">            data.ElementType = p_info.PropertyType;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加对Object的Metadata的int类型key的识别判断</p><h2 id="ReadValue"><a href="#ReadValue" class="headerlink" title="ReadValue"></a>ReadValue</h2><p>在ReadValue方法中，修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (reader.Token == JsonToken.ObjectStart)</span><br><span class="line">&#123;</span><br><span class="line">    AddObjectMetadata(value_type);</span><br><span class="line">    ObjectMetadata t_data = object_metadata[value_type];</span><br><span class="line"></span><br><span class="line">    instance = Activator.CreateInstance(value_type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字典key是否为int?</span></span><br><span class="line">    <span class="built_in">bool</span> isIntKey = t_data.IsDictionary &amp;&amp; value_type.GetGenericArguments()[<span class="number">0</span>] == <span class="keyword">typeof</span>(<span class="built_in">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t_data.Properties.ContainsKey(property))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理字典key为int的情况</span></span><br><span class="line">            <span class="keyword">if</span> (isIntKey)</span><br><span class="line">            &#123;</span><br><span class="line">                ((IDictionary)instance).Add(Convert.ToInt32(property), ReadValue(t_data.ElementType, reader));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ((IDictionary)instance).Add(property, ReadValue(t_data.ElementType, reader));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加在读取json文本时对字典int类型key的检查</p><h2 id="WriteValue"><a href="#WriteValue" class="headerlink" title="WriteValue"></a>WriteValue</h2><p>在WriteValue方法中，修改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">is</span> IDictionary)</span><br><span class="line">&#123;</span><br><span class="line">    writer.WriteObjectStart();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="function">DictionaryEntry entry <span class="title">in</span> (<span class="params">IDictionary</span>)obj)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.Key <span class="keyword">is</span> <span class="built_in">string</span> key)</span><br><span class="line">        &#123;</span><br><span class="line">            writer.WritePropertyName(key);</span><br><span class="line">            WriteValue(entry.Value, writer, writer_is_private,</span><br><span class="line">                depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//处理字典key为int的情况</span></span><br><span class="line">            writer.WritePropertyName(entry.Key.ToString());</span><br><span class="line">            WriteValue(entry.Value, writer, writer_is_private,</span><br><span class="line">                depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    writer.WriteObjectEnd();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>增加在写入时对非string类型的key的支持</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
          <category> 踩坑记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年终总结</title>
      <link href="/2021/12/31/2021-year-end-summary/"/>
      <url>/2021/12/31/2021-year-end-summary/</url>
      
        <content type="html"><![CDATA[<p>到了2021年的结尾，该开始年终总结了</p><p>今年的经历大致可以分为上下半年两部分</p><p>上半年主要是在公司一边摸鱼一边看了一遍《C++Primer》和《深入理解计算机系统》，当然只是看了一遍，缺少一定程度的实践（还是要多冻手才行）</p><p>下半年则是在公司一边摸鱼一边进行Cat系列开源项目的开发，同时学习渲染相关的东西，然后被SRP阴影成功劝退，放弃卷渲染了</p><p>这几天则是在看技能系统相关的东西，新的一年打算专心多研究研究GamePlay，不能再局限于拼图仔了</p><p>最后说到2021年做的最成功的事还是成功逃离科韵路，在12月从广州run到了上海，完成了一个阶段性的提升，超额达成了当初刚工作时对自己的薪资变化预期</p><p>2022年，就以更新25篇博客为目标吧，加油！（希望能脱单）</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 年终总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CatJson开发总结</title>
      <link href="/2021/12/05/catjson-dev-summary/"/>
      <url>/2021/12/05/catjson-dev-summary/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在<a href="https://github.com/CatImmortal/CatLua">CatLua</a>的开发结束后，出于对编译原理前端部分的学习兴趣，笔者便以一个适用于Unity的Json序列化库为目标进行开发</p><p>最终在较精简的源码基础上，完成了一个可以说是功能齐全，性能高效的Json序列化库<a href="https://github.com/CatImmortal/CatJson">CatJson</a></p><p>Runtime部分代码结构如下：</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatJsonDevSummary/CatJsonDevSummary_1.png"></p><ul><li>Attributes：包含内置的特性标签，主要用于忽略字段和预生成转换代码</li><li>Lexer：包含用于读取Json词法单元的Json词法分析器</li><li>Parser：包含用于将Json文本与对象进行互相转换的Json解析器</li></ul><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><p>无论是要将Json文本转换为通用Json对象还是自定义数据对象，都需要能够先将Json的Token从字符串中一个接一个的提取出来，这就是Lexer所做的工作</p><p>CatJson中所使用的Lexer基本上与CatLua中的Lexer相同，具体可参看<a href="http://cathole.top/2021/11/09/catlua-dev-summary/">CatLua开发总结</a>中的<strong>10.词法分析</strong>一节</p><p>与Lua不同的是，Json中的词法单元较少</p><p><code>TokenType</code>枚举的定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> Json词法单元的类型</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">enum</span> TokenType</span><br><span class="line">   &#123;</span><br><span class="line">       Eof,</span><br><span class="line">       Null,</span><br><span class="line">       True,</span><br><span class="line">       False,</span><br><span class="line">       Number,</span><br><span class="line">       String,</span><br><span class="line">       LeftBracket,  <span class="comment">//[</span></span><br><span class="line">       RightBracket,  <span class="comment">//]</span></span><br><span class="line">       LeftBrace,  <span class="comment">//&#123;</span></span><br><span class="line">       RightBrace,  <span class="comment">//&#125;</span></span><br><span class="line">       Colon,  <span class="comment">//:</span></span><br><span class="line">       Comma,  <span class="comment">//,</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="通用解析流程"><a href="#通用解析流程" class="headerlink" title="通用解析流程"></a>通用解析流程</h1><p>在整个Json文本解析中，主要解析3类东西：</p><ol><li>Json键值对</li><li>Json对象</li><li>Json数组</li></ol><p>而其中Json对象和Json数组的解析，对于将Json文本转换为<strong>通用Json对象</strong>和<strong>自定义数据对象</strong>来说具有相同流程，所以需要抽象出两个方法来统一这两个流程</p><h2 id="解析Json对象的流程"><a href="#解析Json对象的流程" class="headerlink" title="解析Json对象的流程"></a>解析Json对象的流程</h2><p>解析Json对象的通用流程方法代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 解析Json对象的通用流程</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ParseJsonObjectProcedure</span>(<span class="params"><span class="built_in">object</span> userdata1,<span class="built_in">object</span> userdata2,<span class="built_in">bool</span> isIntKey,Action&lt;<span class="built_in">object</span>,<span class="built_in">object</span>,<span class="built_in">bool</span>,RangeString, TokenType&gt; action</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//跳过 &#123;</span></span><br><span class="line">          Lexer.GetNextTokenByType(TokenType.LeftBrace);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span> (Lexer.LookNextTokenType() != TokenType.RightBrace)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//提取key</span></span><br><span class="line">              RangeString key = Lexer.GetNextTokenByType(TokenType.String);</span><br><span class="line"></span><br><span class="line">              <span class="comment">//跳过 :</span></span><br><span class="line">              Lexer.GetNextTokenByType(TokenType.Colon);</span><br><span class="line"></span><br><span class="line">              <span class="comment">//提取value</span></span><br><span class="line">              <span class="comment">//array和json obj需要完整的[]和&#123;&#125;，所以只能look</span></span><br><span class="line">              TokenType nextTokenType = Lexer.LookNextTokenType();</span><br><span class="line"></span><br><span class="line">              action(userdata1,userdata2,isIntKey,key, nextTokenType);</span><br><span class="line"></span><br><span class="line">              <span class="comment">//有逗号就跳过逗号</span></span><br><span class="line">              <span class="keyword">if</span> (Lexer.LookNextTokenType() == TokenType.Comma)</span><br><span class="line">              &#123;</span><br><span class="line">                  Lexer.GetNextTokenByType(TokenType.Comma);</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (Lexer.LookNextTokenType() == TokenType.RightBracket)</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Json对象不能以逗号结尾&quot;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="comment">//没有逗号就说明结束了</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//跳过 &#125;</span></span><br><span class="line">          Lexer.GetNextTokenByType(TokenType.RightBrace);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>这整个流程所做的就是<strong>将被一对大括号{}所包裹的N个Json键值对识别出来，然后将其传递到回调Action中</strong></p><p>解析流程方法的参数中的回调Action一般以匿名方法的形式传入，为了优化匿名方法的内存消耗，额外设置了userdata1、userdata2、isIntKey这3个参数，具体可参看<a href="http://cathole.top/2021/11/13/delegate-and-lambda-memory-alloc-summary/">C#委托与匿名方法内存分配总结</a>中的<strong>3.5优化建议</strong>一节</p><p>其使用方法以<strong>解析Json对象为字典</strong>为例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 解析json对象为字典，key为string或int类型</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">object</span> <span class="title">ParseJsonObjectByDict</span>(<span class="params">Type dictType, Type valueType</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          IDictionary dict = (IDictionary)Activator.CreateInstance(dictType);</span><br><span class="line">          Type keyType = dictType.GetGenericArguments()[<span class="number">0</span>];</span><br><span class="line">          ParseJsonObjectProcedure(dict, valueType,keyType == <span class="keyword">typeof</span>(<span class="built_in">int</span>), (userdata1, userdata2,isIntKey, key, nextTokenType) =&gt; &#123;</span><br><span class="line">              Type t = (Type)userdata2;</span><br><span class="line">              <span class="built_in">object</span> <span class="keyword">value</span> = ParseJsonValueByType(nextTokenType, t);</span><br><span class="line">              <span class="keyword">if</span> (!isIntKey)</span><br><span class="line">              &#123;</span><br><span class="line">                  ((IDictionary)userdata1).Add(key.ToString(), <span class="keyword">value</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="comment">//处理字典key为int的情况</span></span><br><span class="line">                  ((IDictionary)userdata1).Add(<span class="built_in">int</span>.Parse(key.ToString()), <span class="keyword">value</span>);</span><br><span class="line">              &#125;</span><br><span class="line">             </span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> dict;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>在得到key和value的tokenType后，将value解析出来，然后将key和value设置到字典实例中，最后完成整个字典的解析</p><h2 id="解析Json数组的流程"><a href="#解析Json数组的流程" class="headerlink" title="解析Json数组的流程"></a>解析Json数组的流程</h2><p>解析Json数组的通用流程方法代码与解析Json对象的类似：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 解析Json数组的通用流程</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ParseJsonArrayProcedure</span>(<span class="params"><span class="built_in">object</span> userdata1,<span class="built_in">object</span> userdata2, Action&lt;<span class="built_in">object</span>,<span class="built_in">object</span>,TokenType&gt; action</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//跳过[</span></span><br><span class="line">          Lexer.GetNextTokenByType(TokenType.LeftBracket);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span> (Lexer.LookNextTokenType() != TokenType.RightBracket)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//提取value</span></span><br><span class="line">              <span class="comment">//array和json obj需要完整的[]和&#123;&#125;，所以只能look</span></span><br><span class="line">              TokenType nextTokenType = Lexer.LookNextTokenType();</span><br><span class="line"></span><br><span class="line">              action(userdata1,userdata2,nextTokenType);</span><br><span class="line"></span><br><span class="line">              <span class="comment">//有逗号就跳过</span></span><br><span class="line">              <span class="keyword">if</span> (Lexer.LookNextTokenType() == TokenType.Comma)</span><br><span class="line">              &#123;</span><br><span class="line">                  Lexer.GetNextTokenByType(TokenType.Comma);</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (Lexer.LookNextTokenType() == TokenType.RightBracket)</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;数组不能以逗号结尾&quot;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="comment">//没有逗号就说明结束了</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//跳过]</span></span><br><span class="line">          Lexer.GetNextTokenByType(TokenType.RightBracket);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>用法以解析数组/List为例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> 解析Json数组为指定类型的Array或List<span class="doctag">&lt;T&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">object</span> <span class="title">ParseJsonArrayByType</span>(<span class="params">Type arrayType,Type elementType</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       IList list;</span><br><span class="line">       <span class="keyword">if</span> (arrayType.IsArray)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//数组</span></span><br><span class="line">           list = <span class="keyword">new</span> List&lt;<span class="built_in">object</span>&gt;();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//List&lt;T&gt;</span></span><br><span class="line">           list = (IList)Activator.CreateInstance(arrayType);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ParseJsonArrayProcedure(list, elementType, (userdata1, userdata2, nextTokenType) =&gt;</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">object</span> <span class="keyword">value</span> = ParseJsonValueByType(nextTokenType, (Type)userdata2);</span><br><span class="line">           ((IList)userdata1).Add(<span class="keyword">value</span>);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//返回List&lt;T&gt;</span></span><br><span class="line">       <span class="keyword">if</span> (!arrayType.IsArray)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> list;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//返回数组</span></span><br><span class="line">       Array array = Array.CreateInstance(elementType, list.Count);</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Count; i++)</span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">           <span class="built_in">object</span> element = list[i];</span><br><span class="line">           array.SetValue(element, i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> array;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>得到value的tokenType后将其解析出来，然后放入到一个List中，完成数组/List的解析</p><h1 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h1><p>在准备好通用解析流程方法后便可以开始着手于Json的序列化与反序列化工作</p><h2 id="通用Json对象的序列化与反序列化"><a href="#通用Json对象的序列化与反序列化" class="headerlink" title="通用Json对象的序列化与反序列化"></a>通用Json对象的序列化与反序列化</h2><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>首先定义Json值的类型枚举<strong>ValueType</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> Json值的类型</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">enum</span> ValueType</span><br><span class="line">   &#123;</span><br><span class="line">       Null,</span><br><span class="line">       Boolean,</span><br><span class="line">       Number,</span><br><span class="line">       String,</span><br><span class="line">       Array,</span><br><span class="line">       Object,</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Json值的类型只包含有null，bool，数字，字符串，数组和对象这几种</p><p>定义<strong>JsonValue</strong>来统一存放这几种Json数据：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> Json值</span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JsonValue</span></span><br><span class="line">  &#123;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> ValueType Type;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">bool</span> Boolean;</span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">double</span> Number;</span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">string</span> Str;</span><br><span class="line">      <span class="keyword">public</span> JsonValue[] Array;</span><br><span class="line">      <span class="keyword">public</span> JsonObject Obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>定义<strong>JsonObject</strong>来提供一个可以通过索引器来访问键值对的Json通用对象：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> json对象</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JsonObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;<span class="built_in">string</span>, JsonValue&gt; valueDict;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> JsonValue <span class="keyword">this</span>[<span class="built_in">string</span> key]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (valueDict == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> valueDict[key];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (valueDict == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                valueDict = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, JsonValue&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            valueDict[key] = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于通用Json对象的序列化与反序列而言，处理是非常简单的</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 解析json对象</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> JsonObject <span class="title">ParseJsonObject</span>(<span class="params"></span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         JsonObject obj = <span class="keyword">new</span> JsonObject();</span><br><span class="line"></span><br><span class="line">         ParseJsonObjectProcedure(obj, <span class="literal">null</span>,<span class="literal">false</span>, (userdata1, userdata2,isIntKey, key, nextTokenType) =&gt; &#123;</span><br><span class="line">             JsonValue <span class="keyword">value</span> = ParseJsonValue(nextTokenType);</span><br><span class="line">             JsonObject jo = (JsonObject)userdata1;</span><br><span class="line">             jo[key.ToString()] = <span class="keyword">value</span>;</span><br><span class="line">         &#125;);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>重点在于如何解析Json值：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 解析json值</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JsonValue <span class="title">ParseJsonValue</span>(<span class="params">TokenType nextTokenType</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         JsonValue <span class="keyword">value</span> = <span class="keyword">new</span> JsonValue();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">switch</span> (nextTokenType)</span><br><span class="line">         &#123;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">case</span> TokenType.Null:</span><br><span class="line">                 Lexer.GetNextToken(<span class="keyword">out</span> _);</span><br><span class="line">                 <span class="keyword">value</span>.Type = ValueType.Null;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> TokenType.True:</span><br><span class="line">                 Lexer.GetNextToken(<span class="keyword">out</span> _);</span><br><span class="line">                 <span class="keyword">value</span>.Type = ValueType.Boolean;</span><br><span class="line">                 <span class="keyword">value</span>.Boolean = <span class="literal">true</span>;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> TokenType.False:</span><br><span class="line">                 Lexer.GetNextToken(<span class="keyword">out</span> _);</span><br><span class="line">                 <span class="keyword">value</span>.Type = ValueType.Boolean;</span><br><span class="line">                 <span class="keyword">value</span>.Boolean = <span class="literal">false</span>;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> TokenType.Number:</span><br><span class="line">                 RangeString token = Lexer.GetNextToken(<span class="keyword">out</span> _);</span><br><span class="line">                 <span class="keyword">value</span>.Type = ValueType.Number;</span><br><span class="line">                 <span class="keyword">value</span>.Number = <span class="built_in">double</span>.Parse(token.ToString());</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> TokenType.String:</span><br><span class="line">                 token = Lexer.GetNextToken(<span class="keyword">out</span> _);</span><br><span class="line">                 <span class="keyword">value</span>.Type = ValueType.String;</span><br><span class="line">                 <span class="keyword">value</span>.Str = token.ToString();</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> TokenType.LeftBracket:</span><br><span class="line">                 <span class="keyword">value</span>.Type = ValueType.Array;</span><br><span class="line">                 <span class="keyword">value</span>.Array = ParseJsonArray();</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> TokenType.LeftBrace:</span><br><span class="line">                 <span class="keyword">value</span>.Type = ValueType.Object;</span><br><span class="line">                 <span class="keyword">value</span>.Obj = ParseJsonObject();</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="literal">default</span>:</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;JsonValue解析失败，tokenType == &quot;</span> + nextTokenType);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>只需要根据value的tokenType进行对应解析处理即可</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>通用Json对象的序列化只需要在JsonObject和JsonValue上定义好ToJson方法即可</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> json对象</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JsonObject</span></span><br><span class="line">    &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//省略...</span></span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ToJson</span>(<span class="params"><span class="built_in">int</span> depth</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Util.AppendLine(<span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (valueDict != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">foreach</span> (KeyValuePair&lt;<span class="built_in">string</span>, JsonValue&gt; item <span class="keyword">in</span> valueDict)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    Util.Append(<span class="string">&quot;\&quot;&quot;</span>, depth + <span class="number">1</span>);</span><br><span class="line">                    Util.Append(item.Key);</span><br><span class="line">                    Util.Append(<span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    Util.Append(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    item.Value.ToJson(depth + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (index&lt;valueDict.Count<span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Util.AppendLine(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Util.Append(<span class="string">&quot;&#125;&quot;</span>, depth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> Json值</span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JsonValue</span></span><br><span class="line">  &#123;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="comment">//省略...</span></span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ToJson</span>(<span class="params"><span class="built_in">int</span> depth</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">switch</span> (Type)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">case</span> ValueType.Null:</span><br><span class="line">                  Util.Append(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> ValueType.Boolean:</span><br><span class="line">                  <span class="keyword">if</span> (Boolean == <span class="literal">true</span>)</span><br><span class="line">                  &#123;</span><br><span class="line">                      Util.Append(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                  &#123;</span><br><span class="line">                      Util.Append(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> ValueType.Number:</span><br><span class="line">                  Util.Append(Number.ToString());</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> ValueType.String:</span><br><span class="line">                  Util.Append(<span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">                  Util.Append(Str);</span><br><span class="line">                  Util.Append(<span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> ValueType.Array:</span><br><span class="line">                  Util.AppendLine(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">                  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; Array.Length; i++)</span><br><span class="line">                  &#123;</span><br><span class="line">                      Util.AppendTab(depth + <span class="number">1</span>);</span><br><span class="line">                      JsonValue jv = Array[i];</span><br><span class="line">                      jv.ToJson(depth + <span class="number">1</span>);</span><br><span class="line">                      <span class="keyword">if</span> (i&lt;Array.Length<span class="number">-1</span>)</span><br><span class="line">                      &#123;</span><br><span class="line">                          Util.AppendLine(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  Util.AppendLine(<span class="built_in">string</span>.Empty);</span><br><span class="line">                  Util.Append(<span class="string">&quot;]&quot;</span>,depth);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> ValueType.Object:</span><br><span class="line">                  Obj.ToJson(depth);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="literal">default</span>:</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="自定义数据对象的序列化与反序列化"><a href="#自定义数据对象的序列化与反序列化" class="headerlink" title="自定义数据对象的序列化与反序列化"></a>自定义数据对象的序列化与反序列化</h2><p>对于自定义数据对象，CatJson提供了2种方式进行序列化与反序列化：</p><ol><li>基于反射</li><li>基于预生成代码</li></ol><h3 id="基于反射"><a href="#基于反射" class="headerlink" title="基于反射"></a>基于反射</h3><p>基于反射的实现是大部分Json库的实现思路</p><h4 id="反序列化-1"><a href="#反序列化-1" class="headerlink" title="反序列化"></a>反序列化</h4><p>反序列化的实现在于通过反射获取到自定义类型的字段/属性的类型信息，然后再通过这个字段/属性的类型信息去解析出对应的Json值数据</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 解析json对象为指定类型的数据类实例</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">object</span> <span class="title">ParseJsonObjectByType</span>(<span class="params">Type type</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">object</span> obj = CreateInstance(type);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (!propertyInfoDict.ContainsKey(type) &amp;&amp; !fieldInfoDict.ContainsKey(type))</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">//初始化反射信息</span></span><br><span class="line">               AddToReflectionMap(type);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           ParseJsonObjectProcedure(obj, type,<span class="literal">false</span>, (userdata1, userdata2,isIntKey, key, nextTokenType) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">               Type t = (Type)userdata2;</span><br><span class="line"></span><br><span class="line">               propertyInfoDict.TryGetValue(t, <span class="keyword">out</span> Dictionary&lt;RangeString, PropertyInfo&gt; dict1);</span><br><span class="line">               <span class="keyword">if</span> (dict1 != <span class="literal">null</span> &amp;&amp; dict1.TryGetValue(key, <span class="keyword">out</span> PropertyInfo pi))</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">//先尝试获取名为key的属性</span></span><br><span class="line">                   <span class="built_in">object</span> <span class="keyword">value</span> = ParseJsonValueByType(nextTokenType, pi.PropertyType);</span><br><span class="line">                   pi.SetValue(userdata1, <span class="keyword">value</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">//属性没有 再试试字段</span></span><br><span class="line">                   fieldInfoDict.TryGetValue(t, <span class="keyword">out</span> Dictionary&lt;RangeString, FieldInfo&gt; dict2);</span><br><span class="line">                   <span class="keyword">if</span> (dict2 != <span class="literal">null</span> &amp;&amp; dict2.TryGetValue(key, <span class="keyword">out</span> FieldInfo fi))</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="built_in">object</span> <span class="keyword">value</span> = ParseJsonValueByType(nextTokenType, fi.FieldType);</span><br><span class="line">                       fi.SetValue(userdata1, <span class="keyword">value</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="comment">//这个json key既不是数据类的字段也不是属性，跳过</span></span><br><span class="line">                       ParseJsonValue(nextTokenType);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>在解析Json值上与通用Json对象的解析过程大同小异：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 解析json值为指定类型的实例值</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">object</span> <span class="title">ParseJsonValueByType</span>(<span class="params">TokenType nextTokenType, Type type</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          Type realType = CheckType(type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">switch</span> (nextTokenType)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">case</span> TokenType.Null:</span><br><span class="line">                  Lexer.GetNextToken(<span class="keyword">out</span> _);</span><br><span class="line">                  <span class="keyword">if</span> (!realType.IsValueType)</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">case</span> TokenType.True:</span><br><span class="line">              <span class="keyword">case</span> TokenType.False:</span><br><span class="line">                  Lexer.GetNextToken(<span class="keyword">out</span> _);</span><br><span class="line">                  <span class="keyword">if</span> (realType == <span class="keyword">typeof</span>(<span class="built_in">bool</span>))</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="keyword">return</span> nextTokenType == TokenType.True;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">case</span> TokenType.Number:</span><br><span class="line">                  RangeString token = Lexer.GetNextToken(<span class="keyword">out</span> _);</span><br><span class="line">                  <span class="built_in">string</span> str = token.ToString();</span><br><span class="line">                  <span class="keyword">if</span> (realType == <span class="keyword">typeof</span>(<span class="built_in">byte</span>))</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="keyword">return</span> <span class="built_in">byte</span>.Parse(str);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (realType == <span class="keyword">typeof</span>(<span class="built_in">int</span>))</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="keyword">return</span> <span class="built_in">int</span>.Parse(str);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//省略...</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">case</span> TokenType.String:</span><br><span class="line">                  token = Lexer.GetNextToken(<span class="keyword">out</span> _);</span><br><span class="line">                  <span class="keyword">if</span> (realType == <span class="keyword">typeof</span>(<span class="built_in">string</span>))</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="keyword">return</span> token.ToString();</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (realType == <span class="keyword">typeof</span>(<span class="built_in">char</span>))</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="keyword">return</span> <span class="built_in">char</span>.Parse(token.ToString());</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">case</span> TokenType.LeftBracket:</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (Util.IsArrayOrListType(type))</span><br><span class="line">                  &#123;</span><br><span class="line">                      Type elementType;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">                      <span class="keyword">return</span> ParseJsonArrayByType(type,elementType);</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">case</span> TokenType.LeftBrace:</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (Util.IsDictionaryType(type))</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="comment">//字典</span></span><br><span class="line"></span><br><span class="line">                      Type valueType;</span><br><span class="line"><span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">                      <span class="keyword">return</span> ParseJsonObjectByDict(type, valueType);</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">//类对象</span></span><br><span class="line">                  <span class="keyword">return</span> ParseJsonObjectByType(type);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;ParseJsonValueByType调用失败，tokenType == &quot;</span> + nextTokenType + <span class="string">&quot;,type == &quot;</span> + type.FullName);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h4 id="RangeString优化"><a href="#RangeString优化" class="headerlink" title="RangeString优化"></a>RangeString优化</h4><p>一般而言，在进行JsonKey与字段/属性名对比时，会调用Lexer通过字符串切割的形式将JsonKey提取出来，但是这会造成额外的内存消耗，为了优化这一点，笔者定义了一个表示范围字符串的结构体<code>RangeString</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> 范围字符串</span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> 表示在Source字符串中，从StartIndex到EndIndex范围的字符构成的字符串</span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">struct</span> RangeString : IEquatable&lt;RangeString&gt;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 源字符串</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">private</span> <span class="built_in">string</span> source;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 开始索引</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">private</span> <span class="built_in">int</span> startIndex;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 结束索引</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">private</span> <span class="built_in">int</span> endIndex;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 哈希码</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">private</span> <span class="built_in">int</span> hashCode;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">RangeString</span>(<span class="params"><span class="built_in">string</span> source</span>) : <span class="title">this</span>(<span class="params">source,<span class="number">0</span>,source.Length - <span class="number">1</span></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">RangeString</span>(<span class="params"><span class="built_in">string</span> source, <span class="built_in">int</span> startIndex, <span class="built_in">int</span> endIndex</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">this</span>.source = source;</span><br><span class="line">          <span class="keyword">this</span>.startIndex = startIndex;</span><br><span class="line">          <span class="keyword">this</span>.endIndex = endIndex;</span><br><span class="line">          hashCode = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params">RangeString other</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          </span><br><span class="line">          <span class="built_in">bool</span> isSourceNullOrEmpty = <span class="built_in">string</span>.IsNullOrEmpty(source);</span><br><span class="line">          <span class="built_in">bool</span> isOtherNullOrEmpty = <span class="built_in">string</span>.IsNullOrEmpty(other.source);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (isSourceNullOrEmpty &amp;&amp; isOtherNullOrEmpty)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (isSourceNullOrEmpty || isOtherNullOrEmpty)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">int</span> length = endIndex - startIndex + <span class="number">1</span>;</span><br><span class="line">          <span class="built_in">int</span> otherLength = other.endIndex - other.startIndex + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (length != otherLength)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="built_in">int</span> i = startIndex, j = other.startIndex; i &lt;= endIndex; i++, j++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span> (source[i] != other.source[j])</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//省略...</span></span><br><span class="line">  </span><br><span class="line">     </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>RangeString<strong>通过保存源字符串以及开始索引和结束索引，来表示在源字符串的一段范围内的字符所构成的字符串</strong>，主要作用在于<strong>避免通过字符串切割来进行字符串对比造成的内存开销</strong></p><p>JsonLexer的提取Token方法会返回一个RangeString：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 获取下一个token</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> RangeString <span class="title">GetNextToken</span>(<span class="params"><span class="keyword">out</span> TokenType type</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          type = <span class="literal">default</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//省略...</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">//扫描字面量 分隔符</span></span><br><span class="line">          <span class="keyword">switch</span> (json[curIndex])</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">                  type = TokenType.Null;</span><br><span class="line">                  ScanLiteral(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">default</span>;</span><br><span class="line">             <span class="comment">//省略...</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//扫描数字</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">char</span>.IsDigit(json[curIndex]) || json[curIndex] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">string</span> str = ScanNumber();</span><br><span class="line">              type = TokenType.Number;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> RangeString(str);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//扫描字符串</span></span><br><span class="line">          <span class="keyword">if</span> (json[curIndex] == <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              RangeString rs = ScanString();</span><br><span class="line">              type = TokenType.String;</span><br><span class="line">              <span class="keyword">return</span> rs;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;json解析失败，当前字符:&quot;</span> + json[curIndex]);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>这样在进行JsonKey和字段/属性名的对比时，就会是<strong>RangeString和RangeString的对比</strong>，从而很大程度的避免掉字符串切割带来的额外内存开销</p><h4 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h4><p>序列化过程同样是通过反射得到类型信息来进行整个序列化</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 追加Json数据类对象文本</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AppendJsonObject</span>(<span class="params"><span class="built_in">object</span> obj, Type type, <span class="built_in">int</span> depth</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (!propertyInfoDict.ContainsKey(type) &amp;&amp; !fieldInfoDict.ContainsKey(type))</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//初始化反射信息</span></span><br><span class="line">              AddToReflectionMap(type);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          Util.AppendLine(<span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">          propertyInfoDict.TryGetValue(type, <span class="keyword">out</span> Dictionary&lt;RangeString, PropertyInfo&gt; piDict);</span><br><span class="line">          <span class="keyword">if</span> (piDict != <span class="literal">null</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">foreach</span> (KeyValuePair&lt;RangeString, PropertyInfo&gt; item <span class="keyword">in</span> piDict)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="built_in">object</span> <span class="keyword">value</span> = item.Value.GetValue(obj);</span><br><span class="line">                  Type piType = item.Value.PropertyType;</span><br><span class="line">                  <span class="built_in">string</span> piName = item.Value.Name;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (Util.IsDefaultValue(<span class="keyword">value</span>))</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="comment">//默认值跳过序列化</span></span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  AppendJsonKey(piName, depth+<span class="number">1</span>);</span><br><span class="line">                  AppendJsonValue(piType, <span class="keyword">value</span>, depth+<span class="number">1</span>);</span><br><span class="line">                  <span class="keyword">if</span> (index &lt; piDict.Count<span class="number">-1</span>)</span><br><span class="line">                  &#123;</span><br><span class="line">                      Util.AppendLine(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  index++;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          fieldInfoDict.TryGetValue(type, <span class="keyword">out</span> Dictionary&lt;RangeString, FieldInfo&gt; fiDict);</span><br><span class="line">          <span class="keyword">if</span> (fiDict != <span class="literal">null</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">foreach</span> (KeyValuePair&lt;RangeString, FieldInfo&gt; item <span class="keyword">in</span> fiDict)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="built_in">object</span> <span class="keyword">value</span> = item.Value.GetValue(obj);</span><br><span class="line">                  Type fiType = item.Value.FieldType;</span><br><span class="line">                  <span class="built_in">string</span> fiName = item.Value.Name;</span><br><span class="line">                  <span class="keyword">if</span> (Util.IsDefaultValue(<span class="keyword">value</span>))</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="comment">//默认值跳过序列化</span></span><br><span class="line">                      <span class="keyword">continue</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  AppendJsonKey(fiName, depth+<span class="number">1</span>);</span><br><span class="line">                  AppendJsonValue(fiType, <span class="keyword">value</span>, depth+<span class="number">1</span>);</span><br><span class="line">                  <span class="keyword">if</span> (index &lt; fiDict.Count<span class="number">-1</span>)</span><br><span class="line">                  &#123;</span><br><span class="line">                      Util.AppendLine(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                  index++;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          Util.AppendLine(<span class="built_in">string</span>.Empty);</span><br><span class="line">          Util.Append(<span class="string">&quot;&#125;&quot;</span>,depth);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>重点在于对字段/属性值的序列化：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 追加Json 值文本</span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AppendJsonValue</span>(<span class="params">Type valueType, <span class="built_in">object</span> <span class="keyword">value</span>, <span class="built_in">int</span> depth</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         valueType = CheckType(valueType);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//省略..</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">//根据属性值的不同类型进行序列化</span></span><br><span class="line">         <span class="keyword">if</span> (Util.IsNumber(<span class="keyword">value</span>))</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="comment">//数字</span></span><br><span class="line">             Util.Append(<span class="keyword">value</span>.ToString());</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">value</span> <span class="keyword">is</span> <span class="built_in">string</span> || <span class="keyword">value</span> <span class="keyword">is</span> <span class="built_in">char</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="comment">//字符串</span></span><br><span class="line">             Util.Append(<span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">             Util.Append(<span class="keyword">value</span>.ToString());</span><br><span class="line">             Util.Append(<span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">value</span> <span class="keyword">is</span> <span class="built_in">bool</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="comment">//bool值</span></span><br><span class="line">             <span class="built_in">bool</span> b = (<span class="built_in">bool</span>)<span class="keyword">value</span>;</span><br><span class="line">             <span class="keyword">if</span> (b == <span class="literal">true</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                 Util.Append(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                 Util.Append(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">value</span> <span class="keyword">is</span> Enum)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="comment">//枚举</span></span><br><span class="line">             <span class="built_in">int</span> enumInt = (<span class="built_in">int</span>)<span class="keyword">value</span>;</span><br><span class="line">             Util.Append(enumInt.ToString());</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (Util.IsArrayOrList(<span class="keyword">value</span>))</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="comment">//数组或List</span></span><br><span class="line">             AppendJsonArray(valueType, <span class="keyword">value</span>, depth);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (Util.IsDictionary(<span class="keyword">value</span>))</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="comment">//字典</span></span><br><span class="line">             AppendJsonDict(<span class="keyword">value</span>, depth);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//自定义类对象</span></span><br><span class="line">         AppendJsonObject(<span class="keyword">value</span>, valueType, depth);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="基于预生成代码"><a href="#基于预生成代码" class="headerlink" title="基于预生成代码"></a>基于预生成代码</h3><p>通过预生成代码进行序列化与反序列化，相比基于反射，可以很好的降低CPU耗时以及值类型装箱的内存开销</p><p>其原理主要为通过编辑器下通过反射获取到类型的字符/属性信息，预生成好如同手工编写一般的代码</p><p>例如一个Json数据类定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestJson1_Root</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> b;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> num;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="built_in">int</span>&gt; intList;</span><br><span class="line">    <span class="keyword">public</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; intDict;</span><br><span class="line">    <span class="keyword">public</span> TestJson1_Item item;</span><br><span class="line">    <span class="keyword">public</span> List&lt;TestJson1_Item&gt; itemList;</span><br><span class="line">    <span class="keyword">public</span> Dictionary&lt;<span class="built_in">string</span>, TestJson1_Item&gt; itemDict;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其所生成的反序列化代码便是这样的：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TestJson1_Root <span class="title">ParseJson_TestJson1_Root</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (JsonParser.Lexer.LookNextTokenType() == TokenType.Null)</span><br><span class="line">&#123;</span><br><span class="line">JsonParser.Lexer.GetNextToken(<span class="keyword">out</span> _);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TestJson1_Root obj = <span class="keyword">new</span> TestJson1_Root();</span><br><span class="line"></span><br><span class="line">JsonParser.ParseJsonObjectProcedure(obj, <span class="literal">null</span>, <span class="literal">false</span>, (userdata1, userdata2, isIntKey, key, nextTokenType) =&gt;</span><br><span class="line"> &#123;</span><br><span class="line"> TestJson1_Root temp = (TestJson1_Root)userdata1;</span><br><span class="line"> TokenType tokenType;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (key.Equals(<span class="keyword">new</span> RangeString(<span class="string">&quot;b&quot;</span>)))</span><br><span class="line"> &#123;</span><br><span class="line"> JsonParser.Lexer.GetNextToken(<span class="keyword">out</span> tokenType);</span><br><span class="line"> temp.b = tokenType == TokenType.True;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (key.Equals(<span class="keyword">new</span> RangeString(<span class="string">&quot;num&quot;</span>)))</span><br><span class="line"> &#123;</span><br><span class="line"> temp.num = System.Single.Parse(JsonParser.Lexer.GetNextToken(<span class="keyword">out</span> tokenType).ToString());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (key.Equals(<span class="keyword">new</span> RangeString(<span class="string">&quot;str&quot;</span>)))</span><br><span class="line"> &#123;</span><br><span class="line"> temp.str = JsonParser.Lexer.GetNextToken(<span class="keyword">out</span> tokenType).ToString();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (key.Equals(<span class="keyword">new</span> RangeString(<span class="string">&quot;intList&quot;</span>)))</span><br><span class="line"> &#123;</span><br><span class="line"> List&lt;System.Int32&gt; list = <span class="keyword">new</span> List&lt;System.Int32&gt;();</span><br><span class="line"> JsonParser.ParseJsonArrayProcedure(list, <span class="literal">null</span>, (userdata11, userdata21, nextTokenType1) =&gt;</span><br><span class="line">&#123;</span><br><span class="line"> ((List&lt;System.Int32&gt;)userdata11).Add(System.Int32.Parse(JsonParser.Lexer.GetNextToken(<span class="keyword">out</span> tokenType).ToString()));</span><br><span class="line"> &#125;);</span><br><span class="line"> temp.intList = list;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (key.Equals(<span class="keyword">new</span> RangeString(<span class="string">&quot;intDict&quot;</span>)))</span><br><span class="line"> &#123;</span><br><span class="line"> Dictionary&lt;System.String, System.Int32&gt; dict = <span class="keyword">new</span> Dictionary&lt;System.String, System.Int32&gt;();</span><br><span class="line"> JsonParser.ParseJsonObjectProcedure(dict, <span class="literal">null</span>, <span class="literal">false</span>, (userdata11, userdata21, isIntKey1, key1, nextTokenType1) =&gt;</span><br><span class="line"> &#123;</span><br><span class="line"> ((Dictionary&lt;System.String, System.Int32&gt;)userdata11).Add(key1.ToString(), System.Int32.Parse(JsonParser.Lexer.GetNextToken(<span class="keyword">out</span> _).ToString()));</span><br><span class="line"> &#125;);</span><br><span class="line"> temp.intDict = dict;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (key.Equals(<span class="keyword">new</span> RangeString(<span class="string">&quot;item&quot;</span>)))</span><br><span class="line"> &#123;</span><br><span class="line"> temp.item = ParseJson_TestJson1_Item();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (key.Equals(<span class="keyword">new</span> RangeString(<span class="string">&quot;itemList&quot;</span>)))</span><br><span class="line"> &#123;</span><br><span class="line"> List&lt;TestJson1_Item&gt; list = <span class="keyword">new</span> List&lt;TestJson1_Item&gt;();</span><br><span class="line"> JsonParser.ParseJsonArrayProcedure(list, <span class="literal">null</span>, (userdata11, userdata21, nextTokenType1) =&gt;</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (nextTokenType1 == TokenType.Null)</span><br><span class="line"> &#123;</span><br><span class="line"> JsonParser.Lexer.GetNextToken(<span class="keyword">out</span> _);</span><br><span class="line"> ((List&lt;TestJson1_Item&gt;)userdata11).Add(<span class="literal">null</span>);</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line">((List&lt;TestJson1_Item&gt;)userdata11).Add(ParseJson_TestJson1_Item());</span><br><span class="line"> &#125;);</span><br><span class="line"> temp.itemList = list;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (key.Equals(<span class="keyword">new</span> RangeString(<span class="string">&quot;itemDict&quot;</span>)))</span><br><span class="line"> &#123;</span><br><span class="line"> Dictionary&lt;System.String, TestJson1_Item&gt; dict = <span class="keyword">new</span> Dictionary&lt;System.String, TestJson1_Item&gt;();</span><br><span class="line"> JsonParser.ParseJsonObjectProcedure(dict, <span class="literal">null</span>, <span class="literal">false</span>, (userdata11, userdata21, isIntKey1, key1, nextTokenType1) =&gt;</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span> (nextTokenType1 == TokenType.Null)</span><br><span class="line"> &#123;</span><br><span class="line"> JsonParser.Lexer.GetNextToken(<span class="keyword">out</span> _);</span><br><span class="line"> ((Dictionary&lt;System.String, TestJson1_Item&gt;)userdata11).Add(key1.ToString(), <span class="literal">null</span>);</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> ((Dictionary&lt;System.String, TestJson1_Item&gt;)userdata11).Add(key1.ToString(), ParseJson_TestJson1_Item());</span><br><span class="line"> &#125;);</span><br><span class="line"> temp.itemDict = dict;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> JsonParser.ParseJsonValue(nextTokenType);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是在通用解析流程回调中，<strong>通过if语句去匹配得到的JsonKey与字段/属性名，然后调用Lexer提取Value字符串出来，转换为对应的字段/属性类型并直接赋值</strong>，不会像基于反射的一样所有数据都作为object类型去操作</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
          <category> 开发总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Json </tag>
            
            <tag> 序列化 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#委托与匿名方法内存分配总结</title>
      <link href="/2021/11/13/delegate-and-lambda-memory-alloc-summary/"/>
      <url>/2021/11/13/delegate-and-lambda-memory-alloc-summary/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用委托与匿名方法在C#编程中是一件很常见的事</p><p>但在使用不当的情况下会造成大量的额外内存分配，因此笔者便试图以分类讨论的形式，总结以不同的方式去使用委托与匿名方法会造成的内存分配情况</p><h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><p>考虑一个在循环中对委托赋值的场景：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Action act = ???</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有3种可能的赋值方式：</p><ol><li>使用Action对象赋值</li><li>使用方法名赋值</li><li>使用匿名方法赋值</li></ol><h2 id="使用Action对象赋值"><a href="#使用Action对象赋值" class="headerlink" title="使用Action对象赋值"></a>使用Action对象赋值</h2><p>通过将一个方法赋值给一个Action对象a，然后再将a赋值给act</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Action a = ActionMethod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Action act = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ActionMethod</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过SharpLab查看编译后的C#代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       Action action = <span class="keyword">new</span> Action(ActionMethod);</span><br><span class="line">       <span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (num &lt; <span class="number">100</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           Action action2 = action;</span><br><span class="line">           num++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ActionMethod</span>(<span class="params"></span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到本质上是通过调用Action的构造方法，使用ActionMethod构造了一个Action对象然后在循环进行赋值</p><p><strong>整个过程产生了1次内存分配</strong></p><h2 id="使用方法名赋值"><a href="#使用方法名赋值" class="headerlink" title="使用方法名赋值"></a>使用方法名赋值</h2><p>直接用ActionMethod赋值给act</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           Action act = ActionMethod;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ActionMethod</span>(<span class="params"></span>)</span></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后通过SharpLab查看编译后的C#代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (num &lt; <span class="number">100</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           Action action = <span class="keyword">new</span> Action(ActionMethod);</span><br><span class="line">           num++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ActionMethod</span>(<span class="params"></span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在循环中每一次赋值时都构造了新的Action对象</p><p><strong>整个过程产生了100次内存分配</strong></p><h2 id="使用匿名方法赋值"><a href="#使用匿名方法赋值" class="headerlink" title="使用匿名方法赋值"></a>使用匿名方法赋值</h2><p>通过使用Lambda表达式产生出一个匿名方法赋值给act</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Action act = () =&gt; &#123; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过SharpLab查看编译后的C#代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line">   [<span class="meta">CompilerGenerated</span>]</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> &lt;&gt;<span class="title">c</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> &lt;&gt;c &lt;&gt;<span class="number">9</span> = <span class="keyword">new</span> &lt;&gt;c();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> Action &lt;&gt;<span class="number">9</span>__0_0;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">internal</span> <span class="keyword">void</span> &lt;Test&gt;b__0_0()</span><br><span class="line">       &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (num &lt; <span class="number">100</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           Action action = &lt;&gt;c.&lt;&gt;<span class="number">9</span>__0_0 ?? (&lt;&gt;c.&lt;&gt;<span class="number">9</span>__0_0 = <span class="keyword">new</span> Action(&lt;&gt;c.&lt;&gt;<span class="number">9.</span>&lt;Test&gt;b__0_0));</span><br><span class="line">           num++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>编译器会生成一个匿名类，将匿名方法保存到其中的静态Action字段中</p><p><strong>整个过程产生了1次内存分配</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因此在对于需要重复赋值Action变量的情况</p><p><strong>Action对象赋值(1)=匿名方法赋值(1)&gt;方法名赋值(100)</strong></p><h1 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h1><p>以上的讨论中涉及的匿名方法没有捕获到外部变量（无闭包）</p><p>但一般在使用匿名方法时都会对外部变量进行捕获（有闭包）</p><p>而被捕获的外部变量有3种可能的情况：</p><ol><li>捕获到静态字段</li><li>捕获到实例字段</li><li>捕获到外部方法的局部变量</li></ol><h2 id="捕获到静态字段"><a href="#捕获到静态字段" class="headerlink" title="捕获到静态字段"></a>捕获到静态字段</h2><p>在匿名方法中声明一个int变量x，去捕获静态字段staticInt</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> staticInt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Action act = () =&gt; &#123;</span><br><span class="line">                <span class="built_in">int</span> x = staticInt;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后通过SharpLab查看编译后的C#代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Serializable</span>]</span><br><span class="line">    [<span class="meta">CompilerGenerated</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> &lt;&gt;<span class="title">c</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> &lt;&gt;c &lt;&gt;<span class="number">9</span> = <span class="keyword">new</span> &lt;&gt;c();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Action &lt;&gt;<span class="number">9</span>__1_0;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">void</span> &lt;Test&gt;b__1_0()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> staticInt = TestClass.staticInt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> staticInt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &lt; <span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Action action = &lt;&gt;c.&lt;&gt;<span class="number">9</span>__1_0 ?? (&lt;&gt;c.&lt;&gt;<span class="number">9</span>__1_0 = <span class="keyword">new</span> Action(&lt;&gt;c.&lt;&gt;<span class="number">9.</span>&lt;Test&gt;b__1_0));</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当捕获到的是静态字段时，编译器的处理就和无闭包时差不多，会直接在匿名方法中去访问静态字段</p><p><strong>整个过程产生了1次内存分配</strong></p><h2 id="捕获到实例字段"><a href="#捕获到实例字段" class="headerlink" title="捕获到实例字段"></a>捕获到实例字段</h2><p>在匿名方法中声明一个int变量x，去捕获实例字段instanceInt</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="built_in">int</span> instanceInt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Action act = () =&gt; &#123;</span><br><span class="line">                <span class="built_in">int</span> x = instanceInt;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过SharpLab查看编译后的C#代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> instanceInt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &lt; <span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Action action = <span class="keyword">new</span> Action(&lt;Test&gt;b__1_0);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">CompilerGenerated</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> &lt;Test&gt;b__1_0()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> num = instanceInt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>捕获的是实例字段时，编译器将不会生成匿名类，而是直接用匿名方法构造临时Action</p><p><strong>整个过程产生了100次内存分配</strong></p><h2 id="捕获到外部方法的局部变量"><a href="#捕获到外部方法的局部变量" class="headerlink" title="捕获到外部方法的局部变量"></a>捕获到外部方法的局部变量</h2><p>在匿名方法中声明一个int变量x，去捕获循环中声明的局部变量instanceInt</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> localInt = <span class="number">0</span>;</span><br><span class="line">            Action act = () =&gt; &#123;</span><br><span class="line">                <span class="built_in">int</span> x = localInt;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后通过SharpLab查看编译后的C#代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">CompilerGenerated</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> &lt;&gt;<span class="title">c__DisplayClass0_0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> localInt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">void</span> &lt;Test&gt;b__0()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> num = localInt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &lt; <span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            &lt;&gt;c__DisplayClass0_0 &lt;&gt;c__DisplayClass0_ = <span class="keyword">new</span> &lt;&gt;c__DisplayClass0_0();</span><br><span class="line">            &lt;&gt;c__DisplayClass0_.localInt = <span class="number">0</span>;</span><br><span class="line">            Action action = <span class="keyword">new</span> Action(&lt;&gt;c__DisplayClass0_.&lt;Test&gt;b__0);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会为每一次捕获的局部变量创建匿名类对象来保存该局部变量，然后使用匿名方法去创建Action对象并赋值给act</p><p><strong>整个过程产生了200次内存分配</strong></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>在使用匿名方法时</p><p><strong>无闭包(1)=捕获静态字段(1)&gt;捕获实例字段(100)&gt;捕获局部变量(200)</strong></p><h2 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h2><p>但在实际开发中使用匿名方法捕获循环中的局部变量可以说是非常常见的情况了，那么应该如何优化？</p><p>笔者给出的建议是：<strong>通过增加参数数量，使用方法参数去传递要捕获的变量，避免掉对外部变量的捕获</strong></p><p>原本的写法，直接捕获局部变量：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> localInt = <span class="number">0</span>;</span><br><span class="line">            CallAction(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> x = localInt;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CallAction</span>(<span class="params">Action action</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Action act = action;</span><br><span class="line">        act();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化的写法，将局部变量作为方法参数传递：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> localInt = <span class="number">0</span>;</span><br><span class="line">            CallAction(localInt,(param) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> x = param;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CallAction</span>(<span class="params"><span class="built_in">int</span> param, Action&lt;<span class="built_in">int</span>&gt; action</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Action&lt;<span class="built_in">int</span>&gt; act = action;</span><br><span class="line">        act(param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过SharpLab查看优化的写法编译后的C#代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Serializable</span>]</span><br><span class="line">    [<span class="meta">CompilerGenerated</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">sealed</span> <span class="keyword">class</span> &lt;&gt;<span class="title">c</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> &lt;&gt;c &lt;&gt;<span class="number">9</span> = <span class="keyword">new</span> &lt;&gt;c();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Action&lt;<span class="built_in">int</span>&gt; &lt;&gt;<span class="number">9</span>__0_0;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">void</span> &lt;Test&gt;b__0_0(<span class="built_in">int</span> param)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &lt; <span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> param = <span class="number">0</span>;</span><br><span class="line">            CallAction(param, &lt;&gt;c.&lt;&gt;<span class="number">9</span>__0_0 ?? (&lt;&gt;c.&lt;&gt;<span class="number">9</span>__0_0 = <span class="keyword">new</span> Action&lt;<span class="built_in">int</span>&gt;(&lt;&gt;c.&lt;&gt;<span class="number">9.</span>&lt;Test&gt;b__0_0)));</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CallAction</span>(<span class="params"><span class="built_in">int</span> param, Action&lt;<span class="built_in">int</span>&gt; action</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        action(param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到优化后就和无闭包一样了</p><p><strong>整个过程产生的内存分配从200次降低到了1次</strong></p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试记录</title>
      <link href="/2021/11/12/Interview-record/"/>
      <url>/2021/11/12/Interview-record/</url>
      
        <content type="html"><![CDATA[<h1 id="叠纸一面（2021-11-12）"><a href="#叠纸一面（2021-11-12）" class="headerlink" title="叠纸一面（2021.11.12）"></a>叠纸一面（2021.11.12）</h1><ol><li>自我介绍</li><li>看你有用C#实现过Lua，那你有去看C语言版本的Lua源码吗？</li><li>对Lua优化，按照你对源码的了解有什么理解吗？</li><li>为什么对LuaTable做预填充能起到优化作用？</li><li>你自己实现Table预填充优化是大概怎么实现的？</li><li>有什么办法能够检查出Lua代码中全局变量的使用？</li><li>在Lua代码中使用Env的情况下如何检查全局变量的使用？</li><li>你对Lua的使用情况是怎么样的？</li><li>热更新方案Lua和ILRuntime的差异与优劣</li><li>你认为Lua维护起来很痛苦，那有没有想过做什么工具或其他方式来改善？</li><li>ILRuntime如果查出内存问题有什么优化方案或者工具？</li><li>简单介绍下你写的Json库</li><li>你是怎么提高你的Json库性能的？</li><li>讲下你在工作中对代码内存分配和性能优化的见解</li><li>对匿名函数的内存分配理解？</li><li>简单介绍下你的资源管理框架</li><li>卸载Bundle时使用Unload(true)还是Unload(false)，这两个区别是什么？</li><li>简单介绍下你写的红点系统</li><li>怎么处理一个节点的子节点被取消激活，父节点依然需要显示的问题？</li><li>一旦有红点变化，你会把整个红点树都刷新一遍吗？</li><li>红点树的构建过程是按照路径构建的吗？</li><li>按照路径构建的过程，路径字符串的比较之类的你是怎么优化的？</li><li>介绍下你做的组件自动绑定工具</li><li>介绍下你现在项目的换装是怎么做的</li><li>骨骼动画的原理</li><li>如果让你用数据结构来表示AnimationCurve，这个数据结构应该包含哪些内容？</li><li>具体说下动画关键帧包含哪些信息？</li><li>怎么表示曲线呢？</li><li>简单介绍下你在Lua层实现的简易Timeline</li><li>策划怎么编辑你这个Timeline？</li><li>如果要做一个编辑器工具让策划可以预览你有办法做吗？</li><li>用自定义track跑Lua的数据是吗？</li><li>平常你自己工作内容以外会有什么渠道去学习新知识吗？</li><li>网络同步可以讲下你最近了解的东西吗？</li><li>Socket底层有了解过吗，能介绍下三次握手和四次挥手吗？</li><li>为什么会有三次握手？</li><li>介绍下UDP的特点</li></ol><p><strong>通过</strong>，全程基本都是我在说，属实累死</p><h1 id="腾讯一面（2021-11-13）"><a href="#腾讯一面（2021-11-13）" class="headerlink" title="腾讯一面（2021.11.13）"></a>腾讯一面（2021.11.13）</h1><ol><li>自我介绍</li><li>你工作主要负责哪一块？业务还是偏底层的引擎</li><li>C#值类型与引用类型的区别</li><li>说下值类型装箱过程</li><li>反射用过吗？一般用在哪一块？反射的原理是什么？</li><li>类的元数据在哪个阶段生成？</li><li>接口和抽象类有什么区别？</li><li>C#弱引用有用过吗？</li><li>密封类和密封方法知道吗？</li><li>C#的容器List和字典知道实现原理吗？</li><li>Lua面向对象怎么实现？</li><li>说下MonoBehaviour脚本的生命周期</li><li>说下协程和线程的区别</li><li>组件隐藏掉协程会停止吗</li><li>说下渲染管线的基本流程</li><li>说下UGUI的遮罩组件</li><li>普通的Mask组件有哪些缺陷？</li><li>你做UGUI优化的时候有哪些常见的优化</li><li>用过哪些常见的设计模式？</li></ol><p><strong>通过</strong>，这问题问的感觉像是在面外包</p><h1 id="叠纸二面（2021-11-15）"><a href="#叠纸二面（2021-11-15）" class="headerlink" title="叠纸二面（2021.11.15）"></a>叠纸二面（2021.11.15）</h1><ol><li>职业规划</li><li>你对框架的理解</li><li>你自己做过比较值得说的框架的思路</li><li>你在写Json库的时候怎么优化内存分配的？</li><li>你是怎么通过生成Json解析代码避免值类型装箱开销的？</li><li>你这个组件绑定工具的意义是什么？</li><li>你在GamePlay上做过什么值得说的吗？</li><li>有做过UI相关的组件或框架的东西？</li><li>Mono内存的特点可以简单说下吗？</li><li>你在实现框架时会怎么去避免Mono的内存问题？</li><li>为什么栈上内存申请比堆上内存申请快？</li><li>你平时一般在哪里学习技术？</li><li>Lua虚拟机基于栈还是基于寄存器？</li><li>如何在Lua源码层面加一个类似Vector3的新内置类型？对Lua源码改动量有多大？</li></ol><p><strong>通过，给了个很不错的待遇</strong>，比一面轻松很多，面试官也会就问题展开讨论，遇到自己出错的地方也会说自己会下去研究一下</p><h1 id="腾讯二面（2021-11-15）"><a href="#腾讯二面（2021-11-15）" class="headerlink" title="腾讯二面（2021.11.15）"></a>腾讯二面（2021.11.15）</h1><ol><li>自我介绍</li><li>最近工作上的内容</li><li>介绍下你做的UI优化工作</li><li>对比过Mask和RectMask2D的CPU开销的不同吗？</li><li>说下这两种Mask的实现原理</li><li>你知道有哪些UIRebuild的Dirty类型？</li><li>你的UIRebuildLogger怎么处理UI名字相同的情况？</li><li>为什么不考虑直接在UGUI源码层做修改，直接在Dirty的时候记录整个堆栈？</li><li>技能CD变化导致的Rebuild应该怎么优化？</li><li>UI合批判断是否重叠是以什么为标准？</li><li>假设现在需要你做个工具在编辑器下显示UI深度，你会怎么做？</li><li>这个工具假设现在已经有N个UI了，现在来了个新UI，要判断和N个UI是否重叠，你觉得它是个什么过程？算法时间复杂度是多少？</li><li>角色头顶血条Hud如何优化？</li><li>血条中的文字和图片能合成一个drawcall吗？</li><li>介绍下你做的资源管理框架</li><li>你的资源管理框架需要手动调用卸载接口吗？</li><li>怎么查出漏卸载的情况？</li><li>有做过一些资源层面的优化吗？比如图集的优化</li><li>向量a和向量b叉乘，得到的新向量是怎样的？</li><li>写C#时怎么样优化GC？</li><li>说下堆内存和栈内存的区别</li><li>你对自己职业规划是怎么样的？</li><li>最近有了解什么方向的技术吗？</li><li>了解哪些网络同步的方式？</li><li>平时会玩哪些游戏？</li><li>C++有使用过吗？</li></ol><p><strong>通过</strong>，问的问题比tx一面好很多，会根据你的回答延伸出新问题出来</p><h1 id="腾讯三面（2021-11-18）"><a href="#腾讯三面（2021-11-18）" class="headerlink" title="腾讯三面（2021.11.18）"></a>腾讯三面（2021.11.18）</h1><ol><li><p>讲下现在所做的工作</p></li><li><p>你在现在维护的项目主要做哪些东西？</p></li><li><p>你最擅长的部分都有哪些？</p></li><li><p>你觉得你本身的技术最适合哪些？</p></li><li><p>你做过哪些框架？</p></li><li><p>资源更新时是怎么做对比的？</p></li><li><p>资源清单信息里有些什么内容？</p></li><li><p>为什么对比的时候要用字节长度？</p></li><li><p>如果字节长度相同或者不同，你是怎么处理的？</p></li><li><p>资源清单通过什么去请求？</p></li><li><p>资源清单没请求下来你怎么处理？</p></li><li><p>不会做下载失败后的额外措施吗？</p></li><li><p>重试也失败怎么处理？</p></li><li><p>怎么保证资源清单文件下载下来是对的？</p></li><li><p>如何处理强更资源和非强更资源？</p></li><li><p>资源下载到一半退出游戏你怎么处理？</p></li><li><p>了解UnityWebRequest以外的其他断点续传的手段吗</p></li><li><p>你怎么确保Asset和Bundle已经卸载掉？</p></li><li><p>你只记录了资源和资源间的引用关系吗？</p></li><li><p>所有资源的引用计数是框架在维护？</p></li><li><p>在正确的成对调用了Load和Unload，有没有可能还出现了泄露的情况？</p></li><li><p>出现资源泄露了怎么去检测？</p></li><li><p>出现异常导致资源卸载失败怎么去检测？</p></li><li><p>还有做过其他框架吗？</p></li><li><p>最近业余有在学什么吗？</p></li><li><p>网络同步分哪几种？</p></li></ol><p><strong>未通过</strong>，感觉面试官并没有认真看简历，挺会挖细节的，不过提的有些问题并不适合电话面试，需要面对面画图和看代码才能讲明白</p><h1 id="欢乐互娱一面（2022-09-13）"><a href="#欢乐互娱一面（2022-09-13）" class="headerlink" title="欢乐互娱一面（2022.09.13）"></a>欢乐互娱一面（2022.09.13）</h1><ol><li>在每个项目组里承担的责任和做的东西</li><li>做了哪些UI优化？</li><li>为什么UI网格穿插会导致合批失败？</li><li>简历里的个人项目是开源项目吗？是空余时间自己写的吗？</li><li>讲一下CatLua大概是怎么实现的</li><li>讲一下Lua字节码指令那部分</li><li>除了UI方面和资源管理还有没有其他接触过的东西？比如渲染之类的？</li><li>讲一下你接触的渲染管线方面的东西</li></ol><p><strong>通过</strong>，整体流程比较短，感觉面试官也不太懂要问什么</p><h1 id="无端一面（2022-09-14）"><a href="#无端一面（2022-09-14）" class="headerlink" title="无端一面（2022.09.14）"></a>无端一面（2022.09.14）</h1><ol><li>对项目代码的架构设计有了解吗？</li><li>换装方案里的部件有几个？</li><li>换装不同部位出现模型穿插是如何解决的？</li><li>项目的UI优化前后的性能指标有量化对比过吗？、</li><li>ScrollView的Item你是怎么优化它的？</li><li>捏脸这块有了解吗？</li><li>CatAsset有放到项目里验证过吗？</li><li>能整合到类似jenkins这样的集中工具里吗？</li><li>Unity的Addressable有了解吗？</li><li>哪些地方觉得Addressable不好呢？</li><li>基于什么原因去做的CatJson？</li><li>有没有在实际项目中使用过？</li><li>有比较过和其他Json库在序列化后的大小区别吗？</li><li>Json解析部分是怎么研究出来的？</li><li>Unity上比较新的技术，比如dots,ecs,jobsystem有了解过吗？</li><li>ecs的概念有了解过吗？比如e是什么，c是什么，s是什么？</li><li>ecs依靠什么结构来降低cache miss？</li><li>紧密内存排布为什么能让cpu的cache miss降低？</li><li>了解常见的网络同步方式吗？</li><li>TCP和UDP的区别了解吗？</li><li>TCP和UDP的优缺点是什么？</li><li>渲染这一块有了解吗？有自己写过效果吗？</li><li>消融效果的实现思路是什么？</li><li>你做的项目里有印象比较深，让你觉得技术上有挑战的点吗？</li><li>GPU Skin有了解过吗？</li><li>GPU Instance有了解过吗？</li><li>做过AI吗？</li><li>行为树和状态机适合用在哪些地方？</li><li>C#里的字典查找时间复杂度是多少？</li></ol><p><strong>通过</strong>，问的方向感觉还是比较广的</p><h1 id="冰川一面（2022-09-14）"><a href="#冰川一面（2022-09-14）" class="headerlink" title="冰川一面（2022.09.14）"></a>冰川一面（2022.09.14）</h1><ol><li>主要对哪一块比较熟悉？</li><li>最近项目主要负责内容是什么？</li><li>最近几年你觉得做的最复杂的功能是什么？</li><li>复杂点通过什么方式去细化和整理的呢？</li><li>能讲一下你的几个开源项目分别做了什么事情吗？</li><li>你的资源管理库有对比过同类型的库吗？</li><li>算法这一块有专门做练习吗？</li><li>动态规划了解过吗？</li><li>渲染这一块有了解过吗？</li><li>阴影是怎么生成的能讲一下吗？</li><li>编辑器有做过哪些？</li><li>性能优化做过什么？</li><li>UI一般要做哪些性能排查？</li><li>有做过模型、场景、动画相关的东西吗？</li><li>业务这块有做过任务这种东西吗？</li><li>移动平台这块有负责过相关的东西吗？</li><li>有做过真机调试相关的吗？</li><li>真机崩溃的话一般怎么去做排查？</li><li>如果崩溃信息并不能提供给你太多信息的话，怎么去推进这个问题呢？</li><li>对于代码稳定性和开发效率这块有什么总结吗？</li></ol><p><strong>未通过</strong>，有几个问题问的太宽泛了，像个HR在问一样</p><h1 id="勇仕一面（2022-09-15）"><a href="#勇仕一面（2022-09-15）" class="headerlink" title="勇仕一面（2022.09.15）"></a>勇仕一面（2022.09.15）</h1><ol><li>简单介绍下换装的机制</li><li>UI性能优化做过哪些工作？</li><li>UI的和Mask和Mask2D的原理是什么？</li><li>将Mask替换为Mask2D提升了什么？</li><li>移动端纹理压缩格式有几种？</li><li>sRGB是什么意思？</li><li>mipmap知道是什么意思？</li><li>UI适合开mipmap吗？</li><li>mipmap等级是怎么确定的？</li><li>分帧实例化会在表现上突兀吗？</li><li>怎么平衡图集和内存的关系？</li><li>在C#中将一个非常大的结构体作为参数传递，不使用ref，会发生什么？</li><li>装箱拆箱知道吗？</li><li>字典的key为结构体时要注意什么？</li><li>字典查找效率一定会很高吗？</li><li>简单介绍下Unity一帧所经过的流程</li><li>FixedUpdate和Update的关系是什么？</li><li>动画的Update在什么时机执行？</li><li>你的资源管理库优势在哪里？</li><li>介绍下你这个的资源半自动卸载机制</li><li>用你的这套资源框架，如果把我加载的prefab的实例化物体全部销毁，然后调用UnloadUnusedAsset，会把prefab释放掉吗？</li><li>半自动卸载如果想要进一步升级为全自动卸载，你要怎么做？</li><li>介绍下AB的压缩格式有几种</li><li>为什么不能把所有资源打进一个AB里？</li><li>场景AB和普通AB为什么会被Unity区分开来？</li><li>资源冗余如何解决？</li></ol><p><strong>通过</strong>，待遇给的一般，而且加班严重，大概只有厦门本地人会去吧</p><h1 id="DAN一面（2022-09-15）"><a href="#DAN一面（2022-09-15）" class="headerlink" title="DAN一面（2022.09.15）"></a>DAN一面（2022.09.15）</h1><ol><li>讲讲你的CatLua</li><li>词法分析如何实现的？</li><li>词法分析后下一步做了什么？</li><li>如何处理嵌套语句？</li><li>如何保证解析下来是正确的？</li><li>编译阶段是如何处理的？</li><li>你在实现过Lua解释器后，认为Lua平常要注意哪些问题？</li><li>能讲下你实现了Lua的哪些高级特性吗？</li><li>你的Lua调用栈总大小会不断扩大吗？</li><li>你的Lua调用栈大小会受什么的影响变大？</li><li>你在公司里主要负责什么内容？</li><li>讲下你对性能优化的理解</li><li>讲讲你的编辑器工具开发</li><li>你这个组件绑定工具优势在哪里？</li><li>讲讲你对框架的理解</li><li>物理、渲染这些有涉及吗？</li><li>讲讲你的资源管理框架</li><li>你的资源包粒度是怎么划分？</li></ol><p><strong>通过</strong>，和HR聊入职时间的时候好像还挺急的</p><h1 id="无端二面（2022-09-19）"><a href="#无端二面（2022-09-19）" class="headerlink" title="无端二面（2022.09.19）"></a>无端二面（2022.09.19）</h1><ol><li>为什么在游戏开发中需要使用到Lua？</li><li>基于Mono打出的APK可以通过替换DLL文件进行热更新，那么为什么还要用Lua？</li><li>为什么IOS平台只能用IL2CPP打包？</li><li>C#方法参数中的ref和out关键字的作用是什么？</li><li>讲讲C#中引用类型和值类型之间的区别</li><li>讲讲Native内存和Managed内存间的区别</li><li>Managed在进行垃圾回收后会马上还给操作系统吗？</li><li>在Managed内存和Native内存上可以做哪方面的优化？</li><li>讲讲Unity的垃圾回收算法的特点</li><li>如何在ScrollView中裁剪Item上用到的粒子特效？</li><li>模板缓存的运行机制是什么样的？</li><li>有写过一些Shader效果应用到项目中吗？</li><li>讲讲前向渲染和延迟渲染的区别</li><li>如果要你实现一个可靠的UDP，你会从哪些角度去考虑这个实现？</li><li>讲讲你对网络同步的了解</li><li>讲讲git和svn之间的区别</li><li>git为什么切换分支很快？</li><li>在玩家数量很多的情况下如何维护一个前1000名玩家的排行榜？</li><li>哪些排序算法是基于分治思想的？</li><li>了解哪些寻路算法？</li><li>什么样的数据结构适合进行UI跳转/返回的管理？</li></ol><p><strong>未通过</strong>，整体难度感觉一般，HR反馈和岗位需求有点出入</p><h1 id="欢乐互娱二面（2022-09-19）"><a href="#欢乐互娱二面（2022-09-19）" class="headerlink" title="欢乐互娱二面（2022.09.19）"></a>欢乐互娱二面（2022.09.19）</h1><p>介绍下你们项目Lua那边的UI框架是怎么样的？</p><ol><li>讲讲你在UI优化中遇到的问题和解决方案</li><li>你们项目的UI的DrawCall上限定的多少？</li><li>整个游戏的DrawCall上限是多少？</li><li>捏脸系统你主要负责哪方面？</li><li>介绍下你那个GIF动图组件</li><li>你觉得自己优势主要在哪？</li><li>你对自己未来的职业发展方向是主要往哪个方向规划？</li></ol><p><strong>未通过</strong>，HR无反馈，面试流程和一面一样短</p><h1 id="游卡一面（2022-09-20）"><a href="#游卡一面（2022-09-20）" class="headerlink" title="游卡一面（2022.09.20）"></a>游卡一面（2022.09.20）</h1><ol><li>红点系统你的实现思路是什么？</li><li>红点的结构你是根据Transform层级结构来的，还是自己定义了数据结构维护？</li><li>你在Lua层实现的Timeline有涉及到对战斗的开发吗？</li><li>你在第一家公司学习到了哪些好的代码习惯或性能优化规范？</li><li>你在做换装项目时，觉得对你技术提升或了解最多的是哪部分？</li><li>换装项目里渲染技术或一些优化有学到的地方吗？</li><li>你有做过战斗相关的东西吗？</li><li>有做过什么样的工具？</li><li>你的GIF动图组件是如何实现的？</li><li>图集压缩算法有思路吗？</li><li>捏脸系统是改变Mesh的还是渲染出来的？</li><li>在工作经验中有没有对自己成长帮助最大的？</li><li>MMO中的位置同步是怎么做的？</li><li>技能系统有设计过吗？</li><li>有做过带战斗的个人小游戏吗？</li><li>你的音游中下落的音符是录制的还是通过音乐去识别的？</li><li>歌词解析这块你是怎么实现的？</li></ol><p><strong>未通过</strong>，HR无反馈，感觉对方比较想招做过战斗的</p><h1 id="英澈一面（2022-09-20）"><a href="#英澈一面（2022-09-20）" class="headerlink" title="英澈一面（2022.09.20）"></a>英澈一面（2022.09.20）</h1><ol><li>做过哪些编辑器工具？</li><li>你的UI组件自动绑定工具是怎么去进行绑定的？</li><li>代码中要使用这个组件自动绑定工具所绑定UI组件是需要UI命名去遵守这个规则是吗？</li><li>你这个组件自动绑定工具生成的代码是C#文件还是Lua文件？</li><li>代码生成后程序去使用这个组件，是直接用另外命名的key还是这个组件对应对象的名称？</li><li>说说你做的资源管理库</li><li>你这个资源库的引用计数规则是怎样的？</li><li>你的引用计数能区别被依赖加载的资源和被程序直接用代码加载的资源吗？</li><li>能查到是哪个对象引用的吗？</li><li>被用代码加载的能查到吗？</li><li>你用Lua实现的Timeline支持了些什么东西？</li><li>接触过哪些Lua框架？</li><li>ToLua的底层有看过吗？</li><li>有监控过Lua的内存泄露吗？</li><li>UGUI的优化有了解吗？</li><li>职业规划是什么？</li></ol><p><strong>通过</strong>，面试官说话挺慢条斯理的，当天给的offer，效率挺高</p><h1 id="米哈游一面（2022-09-22）"><a href="#米哈游一面（2022-09-22）" class="headerlink" title="米哈游一面（2022.09.22）"></a>米哈游一面（2022.09.22）</h1><ol><li>讲下C++的虚函数</li><li>虚函数的重定向是怎么实现的？</li><li>虚表在什么时候被创建的？</li><li>是每个对象创建的时候都有一份虚表吗？</li><li>是怎么在虚表中找到对应函数实现的？</li><li>在C++和C#中，struct和class的区别是什么？</li><li>struct和class对应的存储空间是栈和堆吗？</li><li>在struct中定义class成员，struct的存储空间有什么变化吗？</li><li>栈和堆的区别是什么？</li><li>为什么栈用来存放生命周期短的数据？</li><li>为什么堆有垃圾回收机制，而栈没有？</li><li>堆为什么需要有垃圾回收来管理内存？</li><li>堆内存的GC是什么时候触发的？</li><li>GC触发的时候做了哪些操作？</li><li>.net C#的GC和Unity C#的GC有哪些不一样？</li><li>struct的装箱和拆箱的性能消耗点在哪？</li><li>拆箱既然没有额外堆内存分配，那它可能的性能消耗点在哪？</li><li>讲一下Unity资源加载的方式</li><li>打一个Bundle一般需要经过哪些步骤？</li><li>资源的相互依赖关系如何处理？</li><li>冗余资源如何处理？</li><li>资源热更是怎么做的？</li><li>已经下载了一部分资源然后重新启动游戏后，是怎么让它只下载还没下载的另一部分资源？</li><li>在异步加载过程中，如果又发起了一个同步加载，此时如何处理？</li><li>资源的卸载怎么管理？</li><li>mono和il2cpp的区别是什么？</li><li>aot和jit的区别是什么？</li><li>怎么在IOS平台进行代码热更？</li><li>一个场景里有角色，有怪物，有可破坏物，角色可以丢炸弹炸怪物，你会怎么去设计？</li><li>对于怪物和可破坏物，你会抽象哪几种组件去实现它们？</li><li>怎么从UI层去控制角色的移动？</li></ol><p><strong>暂时未反馈</strong>，大概率是未通过，整体难度一般，不过一上来问C++虚函数倒是给我整懵了，感觉面试官是不看简历在问一些通用的基础问题</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 面试记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CatLua开发总结</title>
      <link href="/2021/11/09/catlua-dev-summary/"/>
      <url>/2021/11/09/catlua-dev-summary/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间出于对Lua底层机制与编译原理的学习，笔者尝试写了个简易的Lua解释器<a href="https://github.com/CatImmortal/CatLua">CatLua</a>，主要参考《自己动手实现Lua》（原书是Go语言实现，笔者选择了自己熟悉的C#语言，并且对原书很多地方的代码进行了符合自身审美的重构），其余则参考了《Lua设计与实现》、《Lua源码欣赏》</p><p>最终代码结构如下：</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatLuaDevSummary/CatLuaDevSummary_1.png"></p><ul><li>Chunk：包含保存读取到的Lua字节码信息的数据结构</li><li>Compiler：包含词法分析器（Lexer）、语法分析器（Parser）与函数原型编译器（Compiler）</li><li>Instruction：包含所有Lua虚拟机可执行的指令的定义与实现</li><li>LuaStack：包含用于Lua虚拟机进行数据操作、指令逻辑执行的Lua虚拟栈，以及Lua数据类型在C#层的对应实现</li><li>LuaState：包含核心Lua虚拟机，封装了大量对LuaStack的操作</li><li>Operator：包含运算符的定义与实现，包括数学运算、位运算、逻辑运算</li><li>StdLib：包含标准库的实现</li><li>Util：包含各类辅助代码</li></ul><p>此文主要用于对CatLua的总结以及各部分实现思路的梳理，因此不会对每一处细节都进行讲解，若欲详细了解可自行到Github下载源码</p><h1 id="Lua字节码读取"><a href="#Lua字节码读取" class="headerlink" title="Lua字节码读取"></a>Lua字节码读取</h1><p>在借助Lua官方的编译器的情况下，可以先跳过比较麻烦的编译器实现，而直接从字节码读取开始</p><h2 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h2><p>一般而言，一个Lua文件就被视为一个Chunk（严格意义上来说，任何一段可被Lua解释器执行的代码就是一个Chunk）</p><p>Chunk定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> lua的二进制字节码chunk</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Chunk</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 头信息</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">public</span> ChunkHeader Header;</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 主函数的upvalue数量</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">byte</span> UpvaluesSize;</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 主函数</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">public</span> FuncPrototype MainFunc;</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 从字节流解码trunk</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Chunk <span class="title">Undump</span>(<span class="params"><span class="built_in">byte</span>[] data</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           Chunk chunk = <span class="keyword">new</span> Chunk();</span><br><span class="line">           ChunkReader reader = <span class="keyword">new</span> ChunkReader(data);</span><br><span class="line">           chunk.Header = reader.CheckHeader();</span><br><span class="line">           chunk.UpvaluesSize = reader.ReadByte();</span><br><span class="line">           chunk.MainFunc = reader.ReadProto(<span class="built_in">string</span>.Empty);</span><br><span class="line">           <span class="keyword">return</span> chunk;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Chunk被视为自动拥有一个主函数，而在其中定义的任何变量与函数都会被处理为这个主函数内部定义的变量与子函数，因此执行一段Chunk总是从该Chunk的主函数开始执行的，</p><p><strong>这也就是为什么在Lua文件里不用定义“Main”函数，就可以直接执行里面的代码</strong></p><p>函数定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> 函数原型</span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FuncPrototype</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 源文件名</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">string</span> Source;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 起始行号</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">uint</span> LineDefined;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 结束行号</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">uint</span> LastLineDefined;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 固定参数个数</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">byte</span> NumParams;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 是否有变长参数</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">byte</span> IsVararg;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 寄存器数量</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">byte</span> MaxStackSize;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 指令表</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">uint</span>[] Code;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 常量表</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> LuaConstantUnion[] Constants;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> upvalue表</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> UpvalueInfo[] UpvalueInfos;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 子函数原型表</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> FuncPrototype[] Protos;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 行号表（每条指令对应的行号）</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">uint</span>[] LineInfo;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 局部变量表</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> LocalVarInfo[] Locvars;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> upvalue名列表</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">string</span>[] UpvalueNames;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看出函数的本质就是一系列的“<strong>指令</strong>”，此外FuncPrototype还记录了与此函数相关的信息，如参数个数，局部变量信息等</p><h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><p>Lua是一种<strong>面向虚拟机的编程语言</strong>（与此相对立的则是<strong>面向硬件的编程语言</strong>，如C/C++），依靠同一套指令集规范在不同实现的虚拟机上运行，达到<strong>跨平台与嵌入宿主语言作为脚本存在</strong>的效果</p><p>Lua在5.0前是基于栈的虚拟机，而在5.0开始改为了基于寄存器的虚拟机，二者的主要区别在于：</p><ul><li>基于栈的虚拟机只能使用push、pop来操作栈顶，因此需要的指令集较大，相同逻辑需要执行的指令较多，但是指令长度较短</li><li>基于寄存器的虚拟机可以直接对栈进行寻址（比如直接从栈底获取值，把栈顶倒数第n个值复制到栈顶等），所以需要的指令集较小，相同逻辑需要执行的指令较少，但由于需要把地址编码进指令中所以指令长度较长</li></ul><p>一般而言，虚拟机在执行指令时，采用的都是将一个巨大的对指令的Switch Case包裹在循环中来不断执行指令，比如Lua官方C版虚拟机：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaV_execute</span> <span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//.....省略</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* main loop of interpreter */</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Instruction i;</span><br><span class="line">    StkId ra;</span><br><span class="line">    vmfetch();</span><br><span class="line">    vmdispatch (GET_OPCODE(i)) &#123;</span><br><span class="line">      vmcase(OP_MOVE) &#123;</span><br><span class="line">        setobjs2s(L, ra, RB(i));</span><br><span class="line">        vmbreak;</span><br><span class="line">      &#125;</span><br><span class="line">      vmcase(OP_LOADK) &#123;</span><br><span class="line">        TValue *rb = k + GETARG_Bx(i);</span><br><span class="line">        setobj2s(L, ra, rb);</span><br><span class="line">        vmbreak;</span><br><span class="line">      &#125;</span><br><span class="line">      vmcase(OP_LOADKX) &#123;</span><br><span class="line">        TValue *rb;</span><br><span class="line">        lua_assert(GET_OPCODE(*ci-&gt;u.l.savedpc) == OP_EXTRAARG);</span><br><span class="line">        rb = k + GETARG_Ax(*ci-&gt;u.l.savedpc++);</span><br><span class="line">        setobj2s(L, ra, rb);</span><br><span class="line">        vmbreak;</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">//省略...</span></span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CatLua则是采用<strong>表驱动</strong>的写法，将Lua指令与其相关参数及其对应实现逻辑封装为一个InstructionConfig类，并放入数组里，根据指令码ID进行索引（运算符实现也与此类似，后续便不重复了）</p><p>Instruction定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> 指令</span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Instructoin</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Instructoin</span>(<span class="params"><span class="built_in">uint</span> code</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">this</span>.code = code;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 执行指令</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">LuaState vm</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          Action&lt;Instructoin, LuaState&gt; function = InstructionConfig.Configs[OpCode].Func;</span><br><span class="line">          <span class="keyword">if</span> (function != <span class="literal">null</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              function(<span class="keyword">this</span>, vm);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;指令没有对应的函数实现：&quot;</span> + OpType.ToString());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>InstructionConfig定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> 指令配置</span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InstructionConfig</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">InstructionConfig</span>(<span class="params"><span class="built_in">byte</span> testFlag, <span class="built_in">byte</span> setAFlag, OpArgType argBType, OpArgType argCType, OpMode opMode, OpCodeType type, Action&lt;Instructoin, LuaState&gt; func = <span class="literal">null</span></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          TestFlag = testFlag;</span><br><span class="line">          SetAFlag = setAFlag;</span><br><span class="line">          ArgBType = argBType;</span><br><span class="line">          ArgCType = argCType;</span><br><span class="line">          OpMode = opMode;</span><br><span class="line">          Type = type;</span><br><span class="line">          Func = func;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 操作码类型</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> OpCodeType Type;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 指令的函数实现</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> Action&lt;Instructoin, LuaState&gt; Func;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 所有指令的指令配置</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> InstructionConfig[] Configs =</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">new</span> InstructionConfig(<span class="number">0</span>,<span class="number">1</span>,OpArgType.R,OpArgType.N,OpMode.IABC,OpCodeType.Move,InstructionFuncs.MoveFunc),</span><br><span class="line">          <span class="keyword">new</span> InstructionConfig(<span class="number">0</span>,<span class="number">1</span>,OpArgType.K,OpArgType.N,OpMode.IABx,OpCodeType.LoadK,InstructionFuncs.LoadKFunc),</span><br><span class="line">          <span class="keyword">new</span> InstructionConfig(<span class="number">0</span>,<span class="number">1</span>,OpArgType.N,OpArgType.N,OpMode.IABx,OpCodeType.LoadKX,InstructionFuncs.LoadKXFunc),</span><br><span class="line">          <span class="keyword">new</span> InstructionConfig(<span class="number">0</span>,<span class="number">1</span>,OpArgType.U,OpArgType.U,OpMode.IABC,OpCodeType.LoadBool,InstructionFuncs.LoadBoolFunc),</span><br><span class="line"><span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这样对指令的执行就变成了在循环中查表</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//不断取出指令执行</span></span><br><span class="line">Instructoin i = <span class="keyword">new</span> Instructoin(Fetch());</span><br><span class="line">i.Execute(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h3><p>尽量用局部变量缓存全局变量，避免对全局变量的频繁使用</p><p>因为对全局变量的访问相比对局部变量的访问需要更多的指令</p><h1 id="Lua数据类型"><a href="#Lua数据类型" class="headerlink" title="Lua数据类型"></a>Lua数据类型</h1><p>在整个虚拟机运行过程中，都是基于对Lua虚拟栈的操作来实现的，而栈中所保存的则是Lua内置的数据类型</p><p>Lua中有多种数据类型，如nil、布尔、数字、Table、函数等，这些数据类型在CatLua中都被统一封装为LuaDataUnion，其定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Lua数据的模拟Union</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> LuaDataUnion : IEqualityComparer&lt;LuaDataUnion&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> LuaDataType Type</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> Boolean</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Integer</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Number</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Str</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LuaTable Table</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Closure Closure</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中比较重要的有Table和Closure（闭包），接下来将着重讲解这两者</p><h2 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h2><p>Table作为Lua中唯一的数据容器，可以说是十分万能的存在，其既能表现出数组的特性，又能表现出字典的特性，因此在CatLua中便直接使用了C#自带的数组和字典来实现Table，同时嵌套了一个Table来表示元表</p><p>LuaTable定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> Lua中的Table数据结构</span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LuaTable</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LuaTable</span>(<span class="params"><span class="built_in">int</span> arrSize = <span class="number">0</span>,<span class="built_in">int</span> dictSize = <span class="number">0</span></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">          arr = <span class="keyword">new</span> List&lt;LuaDataUnion&gt;(arrSize);</span><br><span class="line">          <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arrSize; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              arr.Add(<span class="literal">default</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          dict = <span class="keyword">new</span> Dictionary&lt;LuaDataUnion, LuaDataUnion&gt;(dictSize);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 数组部分</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">private</span> List&lt;LuaDataUnion&gt; arr;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 字典部分</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">private</span> Dictionary&lt;LuaDataUnion, LuaDataUnion&gt; dict;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 元表</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">public</span> LuaTable MetaTable;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//省略...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="元表与元方法"><a href="#元表与元方法" class="headerlink" title="元表与元方法"></a>元表与元方法</h3><p>元表，即<strong>MetaTable</strong>，在Lua中起到的作用相当于其他语言中运算符重载功能，通过设置与之对应的元方法，开发者可以自定义对Table的一些操作，比如赋值（Index）、取值(newindex)、调用(call)等</p><p>虚拟机会在执行相关操作时检测元表中是否有对应元方法，若有则进行元方法的调用，而不再继续进行原本的处理了</p><h3 id="面向对象的实现"><a href="#面向对象的实现" class="headerlink" title="面向对象的实现"></a>面向对象的实现</h3><p>Lua OOP的实现思路有2种：</p><ol><li>通过设置子类index元方法为其父类，使得在子类中查找不到的成员会上溯至父类查找</li><li>直接将父类成员深拷贝给子类</li></ol><p>方法1在查找时需要一层层的网上找，有一定的性能损耗</p><p>方法2虽然查找快，但是在对象创建时会消耗更多内存</p><h3 id="插入与扩容"><a href="#插入与扩容" class="headerlink" title="插入与扩容"></a>插入与扩容</h3><p>CatLua在插入一个正整数key时，会先判断是否在数组长度内，若是，则放入数组中</p><p>否则继续检测是否只是刚好超出数组长度1位，若是，则放入数组触发扩容，扩容会导致将之前字典里存放的某些符合要求的正整数key的value值移动到数组部分</p><p>若上面的检测都不通过，则直接放入数组部分</p><p>详细源码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (TryConvertToArrIndex(key, <span class="keyword">out</span> <span class="built_in">long</span> index) &amp;&amp; index &gt;= <span class="number">1</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">//key是整数或者是可以转换为整数索引的浮点数 </span></span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (index &lt;= arr.Count)</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="comment">//在数组长度内 放入数组</span></span><br><span class="line">                       arr[(<span class="built_in">int</span>)index - <span class="number">1</span>] = <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">if</span> (index == arr.Count &amp;&amp; <span class="keyword">value</span>.Type == LuaDataType.Nil)</span><br><span class="line">                       &#123;</span><br><span class="line">                           <span class="comment">//value是个nil值 并且被放在数组的末尾 需要清理掉末尾的nil值</span></span><br><span class="line">                           RemoveArrTailNil();</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (index == arr.Count + <span class="number">1</span> &amp;&amp; <span class="keyword">value</span>.Type != LuaDataType.Nil)</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="comment">//不在数组长度内 但只是刚刚超出1位 并且不是nil值</span></span><br><span class="line"></span><br><span class="line">                       <span class="comment">//可能之前存在字典里 先删掉</span></span><br><span class="line">                       <span class="keyword">if</span> (dict != <span class="literal">null</span>)</span><br><span class="line">                       &#123;</span><br><span class="line">                           dict.Remove(key);</span><br><span class="line">                       &#125;</span><br><span class="line">                       </span><br><span class="line"></span><br><span class="line">                       <span class="comment">//放入数组 触发扩容</span></span><br><span class="line">                       arr.Add(<span class="keyword">value</span>);</span><br><span class="line"></span><br><span class="line">                       <span class="comment">//将字典里的符合条件的整数key的value移动到扩容后的数组</span></span><br><span class="line">                       MoveDictToArr();</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   </span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//不能放进数组里 只能试试字典了</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">value</span>.Type != LuaDataType.Nil)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">//value不是nil值 放入字典里</span></span><br><span class="line"></span><br><span class="line">                   dict[key] = <span class="keyword">value</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">//value是个nil 删掉key</span></span><br><span class="line">                   dict.Remove(key);</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 数组部分扩容后，将字典部分的某些值移动到数组里</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MoveDictToArr</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dict == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将dict中从当前数组长度+1的连续整数key的value移动到数组部分</span></span><br><span class="line">            <span class="comment">//比如数组长度为3 就将字典里key分别为4,5,6,7....的value移动到数组</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> index = arr.Count + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                LuaDataUnion key = Factory.NewInteger(index);</span><br><span class="line">                <span class="keyword">if</span> (dict.TryGetValue(key, <span class="keyword">out</span> LuaDataUnion data))</span><br><span class="line">                &#123;</span><br><span class="line">                    arr.Add(data);</span><br><span class="line">                    dict.Remove(key);</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>原版Lua虚拟机则是根据正整数Key是否落在当前数组可容纳范围内决定是否放入数组，并在hash部分满后进行rehash来对数组和hash表进行空间调整，最终目标是数组部分利用率超过50%</p><h3 id="优化建议-1"><a href="#优化建议-1" class="headerlink" title="优化建议"></a>优化建议</h3><p>长度小的table在新增元素时会触发多次rehash，在预先知道table元素数量时，应当进行预填充避免不必要的扩容与rehash操作</p><h2 id="Closure（闭包）与Upvalue"><a href="#Closure（闭包）与Upvalue" class="headerlink" title="Closure（闭包）与Upvalue"></a>Closure（闭包）与Upvalue</h2><p>闭包一般指的是使用了其外层函数局部变量的内部函数，而Upvalue则是这个被引用的局部变量</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">local</span> func1 = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> func2 = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">        a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面的func2就是一个闭包，而变量a就是一个Upvalue</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包的定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 闭包</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Closure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Closure</span>(<span class="params">FuncPrototype proto</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Proto = proto;</span><br><span class="line">        CSFunc = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Proto.UpvalueInfos.Length &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Upvalues = <span class="keyword">new</span> Upvalue[Proto.UpvalueInfos.Length];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Closure</span>(<span class="params">Func&lt;LuaState, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; csFunc,<span class="built_in">int</span> upvalueNum = <span class="number">0</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Proto = <span class="literal">null</span>;</span><br><span class="line">        CSFunc = csFunc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (upvalueNum &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Upvalues = <span class="keyword">new</span> Upvalue[upvalueNum];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Lua函数闭包</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> FuncPrototype Proto;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> C#函数闭包</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> Func&lt;LuaState, <span class="built_in">int</span>,<span class="built_in">int</span>&gt; CSFunc;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 捕获到的Upvalue列表</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> Upvalue[] Upvalues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到闭包内部还被分为了两种：Lua函数闭包与C#函数闭包</p><p>因为在虚拟机实现上<strong>所有函数都是以闭包的形式存在的</strong>（即便是Chunk主函数也捕获到了名为”_Env”的Upvalue），所以如果要在Lua代码中调用C#层定义的函数，就需要将其封装为<strong>可供虚拟机调用的函数形式</strong>，然后以闭包的方式传入</p><p>如print函数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Print</span>(<span class="params">LuaState vm, <span class="built_in">int</span> argsNum</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">string</span> s = <span class="built_in">string</span>.Empty;</span><br><span class="line">           s += <span class="string">&quot;Lua Print:&quot;</span>;</span><br><span class="line">           LuaDataUnion[] datas = vm.PopN(argsNum);</span><br><span class="line">           <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; argsNum; i++)</span><br><span class="line">           &#123;</span><br><span class="line">               s += datas[i].ToString();</span><br><span class="line">               s += <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           Debug.Log(s);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>C#闭包其固定参数为<strong>LuaState对象和参数数量</strong>，返回值则为该函数的<strong>返回值数量</strong>，如print函数无返回值则其C#闭包返回0</p><h3 id="Upvalue"><a href="#Upvalue" class="headerlink" title="Upvalue"></a>Upvalue</h3><p>之所以会将被使用的局部变量称为Upvalue，是因为闭包会延长这个局部变量的生命周期，使其即便离开作用域仍然有可能存活</p><p>Upvalue的定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Upvalue</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Upvalue</span>(<span class="params">LuaDataUnion <span class="keyword">value</span>,<span class="built_in">bool</span> isOpen = <span class="literal">false</span>,<span class="built_in">int</span> globalStackIndex = <span class="number">0</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Value = <span class="keyword">value</span>;</span><br><span class="line">            IsOpen = isOpen;</span><br><span class="line">            GlobalStackIndex = globalStackIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 是否为开放状态（引用到的Lua值是否在栈中）</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span> IsOpen;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> LuaDataUnion Value</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span>;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">set</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 引用到的Lua值在栈中的全局索引</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> GlobalStackIndex</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span>;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">set</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 修改引用到的Lua值</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetValue</span>(<span class="params">LuaDataUnion <span class="keyword">value</span>,LuaState vm</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            Value = <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (IsOpen)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//upvalue处于开放状态 意味着引用的Lua值在栈中，需要一并更新栈</span></span><br><span class="line">                vm.Push(Value);</span><br><span class="line">                vm.PopAndCopy(GlobalStackIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在Lua中Upvalue是被区分为<strong>开放状态</strong>与<strong>闭合状态</strong>的</p><ul><li>开放状态意味着此时此Upvalue所代表的局部变量仍然存活在栈中，修改Upvalue也需要修改栈中的局部变量</li><li>闭合状态意味着那个局部变量已经离开作用域了</li></ul><p>在原版Lua的实现中，若Upvalue处于开放状态则使用指针v来引用那个局部变量，这样可以做到对Upvalue的修改会同时影响到栈中局部变量。而一旦闭合了，就将局部变量复制到value中并让v指向value，这样局部变量就成为了此Upvalue所独有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">UpVal</span> &#123;</span></span><br><span class="line">CommonHeader;</span><br><span class="line">TValue *v; <span class="comment">/* points to stack or to its own value */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">TValue value; <span class="comment">/* the value (when closed) */</span></span><br><span class="line"><span class="comment">//省略...</span></span><br><span class="line">&#125; u;</span><br><span class="line">&#125; UpVal;</span><br></pre></td></tr></table></figure><p>由于C#通常情况下没有指针，所以只能记录开放状态下的局部变量的栈中索引，然后在被修改时一并对栈中数据进行修改</p><h1 id="Lua虚拟栈"><a href="#Lua虚拟栈" class="headerlink" title="Lua虚拟栈"></a>Lua虚拟栈</h1><p>有了对Lua数据类型的定义就可以着手于Lua虚拟栈了</p><p>其定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Lua虚拟栈</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LuaStack</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LuaStack</span> (<span class="params"><span class="built_in">int</span> size</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            stack = <span class="keyword">new</span> LuaDataUnion[size];</span><br><span class="line">            Top = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 存放Lua数据的可索引的栈</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">private</span> LuaDataUnion[] stack;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 栈顶索引</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Top;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 往栈顶压入值</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span>(<span class="params">LuaDataUnion data</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//省略...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 从栈顶弹出值</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> LuaDataUnion <span class="title">Pop</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//省略...</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 根据索引从栈中获取值</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> LuaDataUnion <span class="title">Get</span>(<span class="params"><span class="built_in">int</span> index</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//省略...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 根据索引在栈中设置值</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Set</span>(<span class="params"><span class="built_in">int</span> index, LuaDataUnion <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//省略...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//省略...</span></span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lua虚拟栈的本质就是使用LuaDataUnion数组来模拟栈，并记录栈顶位置，然后封装了对栈的基本操作</p><h1 id="LuaState"><a href="#LuaState" class="headerlink" title="LuaState"></a>LuaState</h1><p>LuaState可理解为Lua虚拟机对象，其主要持有一个LuaStack作为全局虚拟栈，以及一个LuaTable作为全局注册表，定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> Lua解释器核心</span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">LuaState</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">LuaState</span>(<span class="params"><span class="built_in">int</span> size</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          globalStack = <span class="keyword">new</span> LuaStack(size);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//将全局环境表放入注册表</span></span><br><span class="line">          registry[Constants.GlobalEnvKey] = Factory.NewTable(<span class="keyword">new</span> LuaTable());</span><br><span class="line"></span><br><span class="line">          <span class="comment">//省略...</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 全局Lua虚拟栈</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">private</span> LuaStack globalStack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 全局Lua注册表</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">private</span> LuaTable registry = <span class="keyword">new</span> LuaTable();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 加载Lua字节码</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">LoadChunk</span>(<span class="params"><span class="built_in">byte</span>[] bytes, <span class="built_in">string</span> chunkName</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          Chunk chunk = Chunk.Undump(bytes);</span><br><span class="line">          LoadMainFunc(chunk.MainFunc);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 加载主函数原型,将其实例化为闭包，压入栈顶</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LoadMainFunc</span>(<span class="params">FuncPrototype mainFunc</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          Closure c = <span class="keyword">new</span> Closure(mainFunc);</span><br><span class="line">          Push(c);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (c.Proto.UpvalueInfos.Length &gt; <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//设置全局环境表到入口函数的upvalue中</span></span><br><span class="line">              LuaDataUnion g = registry[Constants.GlobalEnvKey];</span><br><span class="line">              c.Upvalues[<span class="number">0</span>] = <span class="keyword">new</span> Upvalue(g);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此外还封装了大量的对LuaStack的操作，如调用函数，设置元表，开启标准库等</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatLuaDevSummary/CatLuaDevSummary_2.png"></p><h1 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h1><p>函数调用部分可谓是整个CatLua中相当麻烦的一部分，笔者在反复测试重构后，采取了基于栈帧的函数调用流程</p><p>所谓栈帧，指的是<strong>对栈的一部分切片的抽象</strong>，每次函数调用都会产生一个栈帧来处理此函数中对栈数据的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">local func1 = function()</span><br><span class="line">    func2()</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local func2 = function()</span><br><span class="line">    func3()</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local func3 = function()</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">func1()  </span><br></pre></td></tr></table></figure><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatLuaDevSummary/CatLuaDevSummary_3.png"></p><p>同时，在调用函数时还会区分主调栈帧和被调栈帧，比如在func1中调用func2时，func1的栈帧就是主调栈帧，func2的栈帧就是被调栈帧</p><p>栈帧的定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> 函数调用栈帧</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FuncCallFrame</span></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">FuncCallFrame</span>(<span class="params">Closure closure = <span class="literal">null</span>, <span class="built_in">int</span> bottom = <span class="number">0</span></span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           Closure = closure;</span><br><span class="line">           Bottom = bottom;</span><br><span class="line"></span><br><span class="line">           <span class="built_in">int</span> size = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">if</span> (Closure != <span class="literal">null</span> &amp;&amp; Closure.Proto != <span class="literal">null</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               size = Closure.Proto.MaxStackSize;</span><br><span class="line">           &#125;</span><br><span class="line">           ReserveRegisterMaxIndex = (Bottom - <span class="number">1</span>) + size; </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 变长参数</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">public</span> LuaDataUnion[] VarArgs;</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 指令索引</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">int</span> PC;</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 前一个函数的调用栈帧</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">public</span> FuncCallFrame Prev;</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 闭包</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">public</span> Closure Closure</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">get</span>;</span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">set</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 栈帧的预留寄存器区域最大索引</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">int</span> ReserveRegisterMaxIndex</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">get</span>;</span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">set</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 栈帧的栈底索引</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">int</span> Bottom</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">get</span>;</span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">set</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>因为一个LuaState只有一个全局的LuaStack，因为每个栈帧就需要记录下当前栈帧的栈底，方便弹出栈帧时正确恢复栈顶，同时还要记录下前一个函数调用栈帧，方便进行恢复操作</p><p>此外还需要注意的是ReserveRegisterMaxIndex这个值，每个栈帧都有N个为寄存器预留的位置，因此<strong>在压入新栈帧时就不能占用这些预留的位置</strong></p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatLuaDevSummary/CatLuaDevSummary_4.png"></p><p>同时可能该栈帧因为操作的数据过多导致栈顶范围溢出了ReserveRegisterMaxIndex，所以<strong>在压入新栈帧时也不能占用这些溢出的位置</strong></p><p>在考虑上面两个限制后，就需要通过<code>Max(ReserveRegisterMaxIndex + 1,Top +1)</code>来计算出新栈帧的栈底位置，然后调整栈顶到新栈帧的栈底（保证后续压入的函数参数从新栈帧的Bottom开始）</p><p>以Lua函数调用为例（C#函数调用流程则是Lua函数调用流程的简化版本），在CatLua中将整个调用流程分为了3个阶段：</p><ol><li><strong>调用Lua函数前</strong></li><li><strong>执行Lua函数调用</strong></li><li><strong>Lua函数调用后</strong></li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PreLuaFuncCall(argsNum);</span><br><span class="line">ExcuteLuaFuncCall();</span><br><span class="line">PostLuaFuncCall(resultNum);</span><br></pre></td></tr></table></figure><p>其中argsNum为调用函数的参数数量，resultNum为返回值数量</p><p>接下来会以下述代码中func1调用func2的流程来进行讲解</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    func2(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func2</span><span class="params">(num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func1()</span><br></pre></td></tr></table></figure><h2 id="PreLuaFuncCall"><a href="#PreLuaFuncCall" class="headerlink" title="PreLuaFuncCall"></a>PreLuaFuncCall</h2><p>在PreLuaFuncCall前，会先将要调用的函数和参数从指定位置复制并压入到主调栈帧的栈顶，并根据Call指令的指令参数和栈顶位置计算出函数参数的数量（如果有变长参数，那么实际参数数量也是在此时被计算出）</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatLuaDevSummary/CatLuaDevSummary_5.png"></p><p>进入PreLuaFuncCal后，要从主调栈帧的栈顶弹出函数与参数，并为被调函数创建新栈帧，压入新栈帧和参数</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatLuaDevSummary/CatLuaDevSummary_6.png"></p><p>接下来再次修改Top，将其指向ReserveRegisterMaxIndex后的位置，<strong>保证后续压入新值不会占用预留的寄存器</strong></p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatLuaDevSummary/CatLuaDevSummary_7.png"></p><p>接下来如果还有变长参数，就会将变长参数收集到栈帧中</p><p>PreLuaFuncCall完整代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 为Lua函数调用作准备，将被调函数和参数压入新栈帧内</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PreLuaFuncCall</span>(<span class="params"><span class="built_in">int</span> argsNum</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//从主调栈帧的栈顶弹出函数与参数</span></span><br><span class="line">    LuaDataUnion[] FuncAndParams = globalStack.PopN(argsNum + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Closure c = FuncAndParams[<span class="number">0</span>].Closure;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">int</span> paramsNum = c.Proto.NumParams;</span><br><span class="line">    <span class="built_in">bool</span> isVarArg = c.Proto.IsVararg != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为被调函数创建栈帧</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置被调栈帧的栈底 需要保证在之前的栈帧之上 不会和之前的栈帧数据重叠</span></span><br><span class="line">    <span class="comment">//如果之前的栈帧里保存的数据没超过预留寄存器数量，就设为curFrame.ReserveRegisterMaxIndex + 1，否则设为Top + 1</span></span><br><span class="line">    <span class="built_in">int</span> bottom = Math.Max(curFrame.ReserveRegisterMaxIndex + <span class="number">1</span>, Top + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    FuncCallFrame newFrame = <span class="keyword">new</span> FuncCallFrame(c,bottom);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//压入被调栈帧 并修改栈顶</span></span><br><span class="line">    PushFuncCallFrameAndSetTop(newFrame);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将固定参数压入被调栈帧</span></span><br><span class="line">    globalStack.PushN(FuncAndParams, <span class="number">1</span>, paramsNum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再次修改栈顶 指向最后一个预留寄存器</span></span><br><span class="line">    <span class="comment">//这样后续push任意新值都不会占用到栈帧自己预留的寄存器位置</span></span><br><span class="line">    SetTop(newFrame.ReserveRegisterMaxIndex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argsNum &gt; paramsNum &amp;&amp; isVarArg)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//实际参数多于固定参数 并且这个函数有变长参数</span></span><br><span class="line">        <span class="comment">//就把多出来的参数收集到变长参数里处理</span></span><br><span class="line">        LuaDataUnion[] varArgs = <span class="keyword">new</span> LuaDataUnion[argsNum - paramsNum];</span><br><span class="line">        Array.Copy(FuncAndParams, paramsNum + <span class="number">1</span>, varArgs, <span class="number">0</span>, varArgs.Length);</span><br><span class="line">        newFrame.VarArgs = varArgs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ExcuteLuaFuncCall"><a href="#ExcuteLuaFuncCall" class="headerlink" title="ExcuteLuaFuncCall"></a>ExcuteLuaFuncCall</h2><p>执行函数调用部分处理，就是通过一个while true循环不断取出指令执行，然后在碰到Return指令的时候结束循环就可以了</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 执行Lua函数调用</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ExcuteLuaFuncCall</span>(<span class="params"></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//不断取出指令执行 直到遇到return指令</span></span><br><span class="line">              Instructoin i = <span class="keyword">new</span> Instructoin(Fetch());</span><br><span class="line">              i.Execute(<span class="keyword">this</span>);</span><br><span class="line">              <span class="keyword">if</span> (i.OpType == OpCodeType.Return)</span><br><span class="line">              &#123;</span><br><span class="line">                 <span class="comment">//此时已经将返回值准备在栈顶上了</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，在处理Return指令的时候，会将返回值都压入栈顶，并记录返回值数量（如果有变长返回值，那么实际返回值数量也是在此时被计算出并记录）</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatLuaDevSummary/CatLuaDevSummary_8.png"></p><h2 id="PostLuaFuncCall"><a href="#PostLuaFuncCall" class="headerlink" title="PostLuaFuncCall"></a>PostLuaFuncCall</h2><p>函数调用结束后，所有返回值都被Return指令放到了栈顶，那么接下来就需要取出返回值，恢复栈顶到Buttom-1，弹出被调栈帧，闭合Upvalue</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatLuaDevSummary/CatLuaDevSummary_9.png"></p><p>最后将resultNum个返回值压入到主调栈帧上，不足的部分用nil补齐即可</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatLuaDevSummary/CatLuaDevSummary_10.png"></p><p>如此便完成了整个函数调用流程</p><p>PostLuaFuncCall完整代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Lua函数调用完成后，将被调函数栈帧的栈顶返回值压入主调函数栈帧的栈顶</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PostLuaFuncCall</span>(<span class="params"><span class="built_in">int</span> resultNum</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (resultNum == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//没返回值 直接弹出被调栈帧 并闭合upvalue以及恢复栈顶</span></span><br><span class="line">        PopFuncCallFrameAndSetTop();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出所有返回值</span></span><br><span class="line">    LuaDataUnion[] results = globalStack.PopN(CallFrameReturnResultNum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//弹出被调栈帧 并闭合upvalue以及恢复栈顶</span></span><br><span class="line">    PopFuncCallFrameAndSetTop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//压入resultNum个返回值到主调栈帧上，不足的部分用nil补</span></span><br><span class="line">    <span class="comment">//resultNum为-1时就全部压入</span></span><br><span class="line">    globalStack.PushN(results, <span class="number">0</span>, resultNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="PCall"><a href="#PCall" class="headerlink" title="PCall"></a>PCall</h1><p>Lua中的PCall相当于其他语言中的try catch的作用，能够在调用一个函数报错后中断调用流程并将异常信息返回</p><p>因此可以直接在C#中使用try catch来实现PCall，并且有了栈帧的概念下，只要在调用前记录下当前栈帧，如果进入了catch块就不断弹出栈帧，直到回到了初始的调用栈帧，最后将异常信息压入栈顶即可</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FuncCallState <span class="title">PCall</span>(<span class="params"><span class="built_in">int</span> argsNum,<span class="built_in">int</span> resultsNum,<span class="built_in">int</span> msg</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            FuncCallFrame frame = curFrame;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                CallFunc(argsNum, resultsNum);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//不断弹出栈帧 直到到了初始的调用栈帧</span></span><br><span class="line">                <span class="keyword">while</span> (curFrame != frame)</span><br><span class="line">                &#123;</span><br><span class="line">                    PopFuncCallFrameAndSetTop();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将异常信息作为pcall的返回值压入调用栈帧的栈顶</span></span><br><span class="line">                CallFrameReturnResultNum = <span class="number">1</span>;</span><br><span class="line">                Push(e.Message);</span><br><span class="line">                <span class="keyword">return</span> FuncCallState.ErrRun;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> FuncCallState.Ok;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h1><p>因为C#是自带GC的语言，所以并未给CatLua实现一套GC算法</p><p>不过在这里仍然简单阐述下原版Lua的GC算法</p><h2 id="双色标记"><a href="#双色标记" class="headerlink" title="双色标记"></a>双色标记</h2><p>Lua和C#一样，采用的是引用追踪式GC，每次GC时会从根对象出发（全局变量，栈，寄存器）遍历所有对象，被标记的就是可达对象，否则是不可达的，不可达对象被视为内存垃圾</p><p>5.0前采用<strong>双色标记</strong>，每个对象非黑即白（扫描过的是黑色，未扫描过的是白色）</p><p>双色标记GC算法过程：</p><ol><li>初始化阶段：遍历root引用的对象，将其加入对象链表</li><li>标记阶段：从对象链表中取出未扫描元素，将其标记为黑色，并遍历该元素关联的所有对象，也标记为黑色</li><li>回收阶段：遍历所有对象，如果是白色就回收，如果是黑色不回收</li></ol><p>这种方法要求<strong>一次性完成GC不能打断</strong>，会造成较长时间的卡顿</p><p><strong>为什么不能被打断？</strong></p><p>因为在标记阶段后创建的新对象在本轮GC中将无法继续被标记，这样就会导致可能会用到的新对象被GC清理掉了从而导致出Bug</p><h2 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h2><p>Lua5.1开始采用三色标记法，实现了增量的回收，3种颜色分别是：</p><p><strong>白色</strong>：待访问状态，对象未被GC访问过，如果在结束GC扫描后仍然是白色，就说明其是内存垃圾</p><p><strong>灰色</strong>：待扫描状态，对象未被GC访问过，但已经准备进行访问</p><p><strong>黑色</strong>：已扫描状态，对象已被GC访问过</p><p>三色标记GC算法过程：</p><ol><li>初始化阶段，遍历root引用的对象，从白色改为灰色，放入灰色节点链表（灰色节点链表相当于记录了当前GC的进度）</li><li>标记阶段：不断从灰色链表取出元素，标记为黑色，然后遍历其关联的所有对象，标记为灰色，加入灰色链表，此阶段可打断</li><li>原子标记阶段：不可打断的阶段，用于处理第二灰色链表的标记</li><li>回收阶段：灰色链表为空后，遍历所有对象，如果为白色就回收</li></ol><p>虽然多数对象是从白到灰，但是像string这种不可能引用其他对象的数据类型是直接从白到黑的</p><p>但即便是增量回收，在回收前依然有一个不可打断的<strong>原子标记阶段</strong>存在：</p><p>首先，因为标记阶段可以被打断，这样在期间可能会有新对象创建，并且被一个黑色对象引用了，但这是不允许的，因为黑色已经标记过了，本轮GC不会再扫描它，这样其引用的的白色对象也不会被标记，到了回收阶段就会被误回收</p><p>这时就需要两种不同的处理：</p><ol><li><strong>前向barrier</strong>：将新创建的对象直接设置为灰色，适用于引用新对象的黑色对象不会频繁改变引用关系的数据类型，如lua的proto</li><li><strong>后向barrier</strong>：将引用新对象的黑色对象设置为灰色，放入第二灰色链表，在原子标记阶段一次性进行标记，适用于黑色对象可能频繁改变引用关系的数据类型，如table。而如果直接把从黑色变灰色的table对象放入灰色链表，因为table的key和value引用关系变化频繁，就可能在黑色和灰色间反复横跳，进行很多重复的扫描，所以需要将table放入第二灰色链表中，在原子标记阶段一次性处理完</li></ol><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><p>词法分析所做的即是不断地将源代码字符串中的<strong>词法单元</strong>(Token)给识别出来，形成一个Token流供语法分析进行提取</p><p>Lua中的Token主要分为以下几类：</p><ol><li><strong>分隔符</strong></li><li><strong>运算符</strong></li><li><strong>字符串字面量</strong></li><li><strong>数字字面量</strong></li><li><strong>标识符</strong></li><li><strong>关键字</strong></li></ol><p>CatLua中对词法分析的实现比较简单，通过对首字符的内容switch case加上正则表达式进行Token识别</p><p>例如：当前字符指向一个”=”，此字符可能构成了“=”，也可能构成了”==”，那么就判断剩余字符是否以”==”开头，若是，则返回token为”==”，否则返回”=”</p><p>具体代码如下：</p><p>首先定义TokenType枚举</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> Token类型</span></span><br><span class="line">  <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">enum</span> TokenType</span><br><span class="line">  &#123;</span><br><span class="line">      Eof,  <span class="comment">//end-of-file</span></span><br><span class="line">      Vararg,  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">      SepSemi,  <span class="comment">//;</span></span><br><span class="line">      SepComma,  <span class="comment">//,</span></span><br><span class="line">      SepDot,  <span class="comment">//.</span></span><br><span class="line">      SepColon,  <span class="comment">//:</span></span><br><span class="line">      SepLable,  <span class="comment">//::</span></span><br><span class="line">      SepLparen,  <span class="comment">//(</span></span><br><span class="line">      SepRparen,  <span class="comment">//)</span></span><br><span class="line">      SepLbrack,  <span class="comment">//[</span></span><br><span class="line">      SepRbrack,  <span class="comment">//]</span></span><br><span class="line">      SepLcurly,  <span class="comment">//&#123;</span></span><br><span class="line">      SepRcurly,  <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      OpAsssign,  <span class="comment">//=</span></span><br><span class="line">      OpMinus,  <span class="comment">//-</span></span><br><span class="line">      OpWave,  <span class="comment">//~</span></span><br><span class="line">      OpAdd,  <span class="comment">//+</span></span><br><span class="line">      OpMul,  <span class="comment">//*</span></span><br><span class="line">      OpDiv,  <span class="comment">// /</span></span><br><span class="line">      OpIDiv,  <span class="comment">// //</span></span><br><span class="line">      OpPow,  <span class="comment">//^</span></span><br><span class="line">      OpMod,  <span class="comment">//%</span></span><br><span class="line">      OpBAnd,  <span class="comment">//&amp;</span></span><br><span class="line">      OpBOr,  <span class="comment">//|</span></span><br><span class="line">      OpShR,  <span class="comment">//&gt;&gt;</span></span><br><span class="line">      OpShL,  <span class="comment">//&lt;&lt;</span></span><br><span class="line">      OpConcat,  <span class="comment">//..</span></span><br><span class="line">      OpLt,  <span class="comment">//&lt;</span></span><br><span class="line">      OpLe,  <span class="comment">//&lt;=</span></span><br><span class="line">      OpGt,  <span class="comment">//&gt;</span></span><br><span class="line">      OpGe,  <span class="comment">//&gt;=</span></span><br><span class="line">      OpEq,  <span class="comment">//==</span></span><br><span class="line">      OpNe,  <span class="comment">//~=</span></span><br><span class="line">      OpLen,  <span class="comment">//#</span></span><br><span class="line">      OpAnd,  <span class="comment">//and</span></span><br><span class="line">      OpOr,  <span class="comment">//or</span></span><br><span class="line">      OpNot,  <span class="comment">//not</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      KwBreak,  <span class="comment">//break</span></span><br><span class="line">      KwDo,  <span class="comment">//do</span></span><br><span class="line">      KwElse,  <span class="comment">//else</span></span><br><span class="line">      KwElseif,  <span class="comment">//elseif</span></span><br><span class="line">      KwEnd,  <span class="comment">//end</span></span><br><span class="line">      KwFalse,  <span class="comment">//false</span></span><br><span class="line">      KwFor,  <span class="comment">//for</span></span><br><span class="line">      KwFunction,  <span class="comment">//function</span></span><br><span class="line">      KwGoto,  <span class="comment">//goto</span></span><br><span class="line">      KwIf,  <span class="comment">//if</span></span><br><span class="line">      KwIn,  <span class="comment">//in</span></span><br><span class="line">      KwLocal,  <span class="comment">//local</span></span><br><span class="line">      KwNil,  <span class="comment">//nil</span></span><br><span class="line">      KwRepeat,  <span class="comment">//repeat</span></span><br><span class="line">      KwReturn,  <span class="comment">//return</span></span><br><span class="line">      KwThen,  <span class="comment">//then</span></span><br><span class="line">      KwTrue,  <span class="comment">//true</span></span><br><span class="line">      KwUntil,  <span class="comment">//until</span></span><br><span class="line">      KwWhile,  <span class="comment">//while</span></span><br><span class="line"></span><br><span class="line">      Identifier,  <span class="comment">//identifier</span></span><br><span class="line">      Number,  <span class="comment">//number literal</span></span><br><span class="line">      String,   <span class="comment">//string literal</span></span><br><span class="line"></span><br><span class="line">      OpUnm = OpMinus,</span><br><span class="line">      OpSub = OpMinus,</span><br><span class="line">      OpBNot = OpWave,</span><br><span class="line">      OpBXor = OpWave,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后定义词法分析器Lexer</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> 词法分析器</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Lexer</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Lexer</span>(<span class="params"><span class="built_in">string</span> chunk, <span class="built_in">string</span> chunkName</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">this</span>.chunk = chunk;</span><br><span class="line">           <span class="keyword">this</span>.chunkName = chunkName;</span><br><span class="line">           Line = <span class="number">1</span>;</span><br><span class="line">           curIndex = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 匹配十进制整数或浮点数的正则表达式</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> Regex numberRegex = <span class="keyword">new</span> Regex(<span class="string">@&quot;^-?\d+$|^(-?\d+)(\.\d+)?&quot;</span>, RegexOptions.Compiled);</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 匹配标识符和关键字的正则表达式</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> Regex identifierRegex = <span class="keyword">new</span> Regex(<span class="string">@&quot;^[_\d\w]+&quot;</span>, RegexOptions.Compiled);</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 匹配短字符串的正则表达式（不支持转义字符</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> Regex shortStrRegex = <span class="keyword">new</span> Regex(<span class="string">&quot;^\&quot;[^\&quot;]*\&quot;&quot;</span>, RegexOptions.Compiled);</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 源代码</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">private</span> <span class="built_in">string</span> chunk;</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 源文件名</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">private</span> <span class="built_in">string</span> chunkName;</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 当前索引</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">private</span> <span class="built_in">int</span> curIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 返回下一个token，对应行号和token类型，并将其跳过</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetNextToken</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> line, <span class="keyword">out</span> <span class="built_in">string</span> token, <span class="keyword">out</span> TokenType type</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//省略...</span></span><br><span class="line">           </span><br><span class="line">           <span class="comment">//跳过空白字符，回车，换行与注释</span></span><br><span class="line">           SkipWhiteSpaces();</span><br><span class="line"></span><br><span class="line">           line = Line;</span><br><span class="line"></span><br><span class="line">           token = <span class="literal">default</span>;</span><br><span class="line">           type = <span class="literal">default</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (curIndex &gt;= chunk.Length)</span><br><span class="line">           &#123;</span><br><span class="line">               type = TokenType.Eof;</span><br><span class="line">               token = <span class="string">&quot;Eof&quot;</span>;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="built_in">char</span> c = chunk[curIndex];</span><br><span class="line"></span><br><span class="line">           <span class="comment">//分隔符,运算符和字符串</span></span><br><span class="line">           <span class="keyword">switch</span> (c)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;;&#x27;</span>:</span><br><span class="line">                   Next(<span class="number">1</span>);</span><br><span class="line">                   type = TokenType.SepSemi;</span><br><span class="line">                   token = <span class="string">&quot;;&quot;</span>;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;,&#x27;</span>:</span><br><span class="line">                   Next(<span class="number">1</span>);</span><br><span class="line">                   type = TokenType.SepComma;</span><br><span class="line">                   token = <span class="string">&quot;,&quot;</span>;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                   Next(<span class="number">1</span>);</span><br><span class="line">                   type = TokenType.SepLparen;</span><br><span class="line">                   token = <span class="string">&quot;(&quot;</span>;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">                   </span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                   Next(<span class="number">1</span>);</span><br><span class="line">                   type = TokenType.SepRparen;</span><br><span class="line">                   token = <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">                   </span><br><span class="line">               <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">                   <span class="keyword">if</span> (Test(<span class="string">&quot;==&quot;</span>))</span><br><span class="line">                   &#123;</span><br><span class="line">                       Next(<span class="number">2</span>);</span><br><span class="line">                       type = TokenType.OpEq;</span><br><span class="line">                       token = <span class="string">&quot;==&quot;</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                   &#123;</span><br><span class="line">                       Next(<span class="number">1</span>);</span><br><span class="line">                       type = TokenType.OpAsssign;</span><br><span class="line">                       token = <span class="string">&quot;=&quot;</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//省略...</span></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//数字字面量</span></span><br><span class="line">           <span class="keyword">if</span> (c == <span class="string">&#x27;.&#x27;</span> || <span class="built_in">char</span>.IsDigit(c))</span><br><span class="line">           &#123;</span><br><span class="line">               token = ScanNumber();</span><br><span class="line">               type = TokenType.Number;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//标识符或关键字</span></span><br><span class="line">           <span class="keyword">if</span> (c == <span class="string">&#x27;_&#x27;</span> || <span class="built_in">char</span>.IsLetter(c))</span><br><span class="line">           &#123;</span><br><span class="line">               token = ScanIdentifier();</span><br><span class="line">               <span class="keyword">if</span> (KeyWordTokenMap.TryGetValue(token,<span class="keyword">out</span> type))</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">//关键字</span></span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//标识符</span></span><br><span class="line">               type = TokenType.Identifier;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           Error(<span class="string">&quot;语法错误，当前字符为:&quot;</span> + c);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 跳过n个字符</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Next</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           curIndex += n;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 剩余的源代码是否以s开头</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">Test</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> chunk.Substring(curIndex).StartsWith(s);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"><span class="comment">//省略...</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这样就完成了词法分析的过程</p><h1 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h1><p>语法分析的作用即是根据编程语言的文法规则，将token序列转换为抽象语法树（AST）</p><p>如<code>a * ( b + c )</code>的AST如下：</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/CatLuaDevSummary/CatLuaDevSummary_11.png"></p><p>Lua的文法规则采用了一种上下文无关文法EBNF（扩展的巴科斯范式）</p><p>该文法定义了编程语言中每种合法语句/表达式由一些什么东西构成</p><p>语句和表达式的区别主要在于：<strong>语句可执行，表达式可求值</strong>（因此函数即是表达式也是语句）</p><p>同时Lua采用的是<strong>递归下降</strong>法进行语法分析，遇到关键字就检查是否匹配，遇到语句/表达式就调用相应的解析方法进行解析</p><h2 id="一个示例：解析do语句"><a href="#一个示例：解析do语句" class="headerlink" title="一个示例：解析do语句"></a>一个示例：解析do语句</h2><p>do语句在Lua中表现为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment">--do something</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>do语句的EBNF文法定义为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dostat -&gt; DO block END</span><br></pre></td></tr></table></figure><p>该定义表达了Lua中的do语句由1个关键字do，1个代码块block，最后再来1个关键字End构成</p><p>而在进行具体的do语句解析中，逻辑就是这样的：</p><ol><li><strong>提取并丢弃do关键字</strong></li><li><strong>ParseBlock解析1个block对象</strong></li><li><strong>提取并丢弃end关键字</strong></li><li><strong>用block对象创建Dostat对象中并返回</strong></li></ol><p>解析do语句的代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 解析do语句</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DoStat <span class="title">ParseDoStat</span>(<span class="params">Lexer lexer</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//跳过do</span></span><br><span class="line">    lexer.GetNextTokenOfType(TokenType.KwDo, <span class="keyword">out</span> _, <span class="keyword">out</span> _);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析block</span></span><br><span class="line">    Block block = ParseBlock(lexer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跳过end</span></span><br><span class="line">    lexer.GetNextTokenOfType(TokenType.KwEnd, <span class="keyword">out</span> _, <span class="keyword">out</span> _);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DoStat(block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数原型编译"><a href="#函数原型编译" class="headerlink" title="函数原型编译"></a>函数原型编译</h1><p>在得到了AST后，就需要根据这个AST生成函数原型</p><p>编译过程和语法分析过程类似，也是采取一种<strong>递归下降</strong>的方法，根据遇到的语句/表达式调用不同的编译方法生成对应的指令</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> 编译语句</span></span><br><span class="line">      <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CompileStat</span>(<span class="params">GenFuncInfo fi, BaseStat stat</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//根据语句类型调用不同的编译方法</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (stat <span class="keyword">is</span> FuncCallStat)</span><br><span class="line">          &#123;</span><br><span class="line">              CompileFuncCallStat(fi, (FuncCallStat)stat);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (stat <span class="keyword">is</span> BreakStat)</span><br><span class="line">          &#123;</span><br><span class="line">              CompileBreakStat(fi, (BreakStat)stat);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (stat <span class="keyword">is</span> DoStat)</span><br><span class="line">          &#123;</span><br><span class="line">              CompileDoStat(fi, (DoStat)stat);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;不支持编译的语句：&quot;</span> + stat.GetType());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> 编译表达式 </span></span><br><span class="line">     <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CompileExp</span>(<span class="params">GenFuncInfo fi, BaseExp exp, <span class="built_in">int</span> reg, <span class="built_in">int</span> num</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span> (exp <span class="keyword">is</span> NilExp)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">int</span> b = reg + num - <span class="number">1</span>;</span><br><span class="line">             fi.EmitLoadNil(reg, b);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (exp <span class="keyword">is</span> FalseExp)</span><br><span class="line">         &#123;</span><br><span class="line">             fi.EmitLoadBool(reg, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (exp <span class="keyword">is</span> TrueExp)</span><br><span class="line">         &#123;</span><br><span class="line">             fi.EmitLoadBool(reg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//省略...</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;不支持编译的表达式：&quot;</span> + exp.GetType());</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>当然这里只是简要的展示了一下编译流程，实际过程中是有非常多的细节要处理的，包括但不限于：</p><ol><li><strong>计算寄存器位置</strong></li><li><strong>作用域层级管理</strong></li><li><strong>处理变长参数</strong></li><li><strong>处理变长返回值</strong></li><li><strong>处理Upvalue</strong></li><li><strong>处理跳转类指令的参数回填</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
          <category> 开发总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手游MMO项目的UI优化实践</title>
      <link href="/2021/11/02/ui-optimization-of-mmo/"/>
      <url>/2021/11/02/ui-optimization-of-mmo/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要记录笔者去年在一个处于开发后期的UnityMMO项目中，根据UWA性能分析报告进行UI优化的实践经验</p><p>对UI优化的实践主要分为以下几方面：</p><ul><li>Drawcall</li><li>Rebuild</li><li>Rebatch</li><li>Overdraw</li><li>Instance</li></ul><p>本文将从这几个方面出发，回顾在项目中进行UI优化的实践经验</p><h1 id="Drawcall"><a href="#Drawcall" class="headerlink" title="Drawcall"></a>Drawcall</h1><p>Drawcall，即绘制调用命令</p><p>CPU在准备好渲染数据后会通过Drawcall命令通知GPU进行渲染</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/UIOptimizatioOfMMO/UIOptimizatioOfMMO_1.png"></p><p>CPU每次调用Drawcall前准备渲染数据时都会产生不少的性能消耗，而GPU的渲染速度是非常快的，常常出现CPU喂不饱GPU的情况，因此可以通过合批的形式一次性发送大量渲染数据到GPU中，以减少Drawcall调用次数</p><p>UI的合批规则主要根据UI网格覆盖范围计算：</p><ol><li>如果一个UI底下没有其他UI，那么此UI深度为0</li><li>如果一个UI底下有其他UI，并且此UI可以与底下深度最大的UI合批（材质相同），那么此UI深度和那个UI相同</li><li>如果一个UI底下有其他UI，并且不能与底下深度最大的UI合批，那么此UI深度为底下最大深度+1</li><li>计算出深度后，Unity会根据深度排序然后将深度相同的UI用1个Drawcall画出来</li></ol><p>UI的合批主要依靠图集来进行，项目中当然也做了这样的处理，而笔者所做的工作主要在于通过FrameDebugger来进行逐步调试，以查出是什么地方应该合批而没有合批，无法合批的原因是什么</p><h2 id="网格穿插"><a href="#网格穿插" class="headerlink" title="网格穿插"></a>网格穿插</h2><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/UIOptimizatioOfMMO/UIOptimizatioOfMMO_2.png"></p><p>MMO项目中主界面右上角一般有大量的活动Icon，这些Icon的合批失败会造成许多的额外Drawcall</p><p>项目中活动Icon合批失败的原因，在于红点的网格穿插到了旁边活动Icon的背景图，以致于无法按照期望的那样第1个Drawcall画完所有背景图，第2个Drwacall画完所有红点</p><p>举个简单的例子，在下图中，经过UI深度规则计算，所有白图的深度为0，红图深度为1，所以只需要2个Drawcall</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/UIOptimizatioOfMMO/UIOptimizatioOfMMO_3.png"></p><p>而像下图这样，因为红图位置偏了点，导致第二个白图被覆盖到了红图上，最终深度计算结果就是：白图1的深度为0，红图1的深度为1，白图2的深度为2，红图2的深度为3，只能使用4个Drawcall才能画完</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/UIOptimizatioOfMMO/UIOptimizatioOfMMO_4.png"></p><p>对于这种情况解决方案当然就是调整活动Icon预制，使红点处于正确位置</p><h2 id="Mask组件"><a href="#Mask组件" class="headerlink" title="Mask组件"></a>Mask组件</h2><p>在使用UI的滚动列表时，通常默认的遮罩组件是Mask</p><p>Mask遮罩的实现原理是模板缓存，其坑点在于自身就会造成额外Drawcall，并且被Mask隐藏掉的物体并不是真正的被裁剪了</p><p>通过将Scene界面的Shading Mode设置为Wireframe，会看到这些物体的网格信息仍然存在，仍然被视为渲染中的物体，这也就意味着如果这些item是无法合批的，那么会造成大量的额外Drawcall，事实上笔者就曾经遇到过这样一个Drawcall高达数百的item列表</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/UIOptimizatioOfMMO/UIOptimizatioOfMMO_5.png"></p><p>解决方案主要是将Mask替换为RectMask2D，其实现原理为调用了Shader中的Clip函数，实现了对遮罩隐藏物体的真正裁剪，并且该组件本身也不会造成额外Drawcall</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/UIOptimizatioOfMMO/UIOptimizatioOfMMO_6.png"></p><h2 id="Z值不为0"><a href="#Z值不为0" class="headerlink" title="Z值不为0"></a>Z值不为0</h2><p>曾经有一次拿FrameDebugger死活没看出来为啥UI合批失败，最后还是主程提醒了一下才发现是有UI的PosZ值不为0导致的</p><h1 id="Rebuild"><a href="#Rebuild" class="headerlink" title="Rebuild"></a>Rebuild</h1><p>Rebuild是指当UI自身发生变化时，从C#层发出的UI重建（比如缩放UI，切换图片，开关UI），一般都会造成不小的性能开销</p><p>其在Profiler中为Canvas.SendWillRenderCanvases项，其中CanvasUpdateRegistry.LayoutRebuild为重建布局信息，CanvasUpdateRegistry.GraphicRebuild为重建网格与材质信息</p><p>这一项主要依靠通过脚本反射两个Rebuild队列进行监控，找出高频触发Rebuild的UI然后进行针对性优化</p><p>脚本代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIRebuildLogger</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 是否开启帧模式，</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 帧模式下关心每一帧有哪些UI元素触发了Rebuild，</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 非帧模式下则关心UI元素触发了多少次Rebuild（建议开启Console的Collapse）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">Tooltip(<span class="meta-string">&quot;是否开启帧模式，\n帧模式下关心每一帧有哪些UI元素触发了Rebuild，\n非帧模式下则关心UI元素触发了多少次Rebuild（建议开启Console的Collapse）&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="built_in">bool</span> m_FrameMode;</span><br><span class="line"></span><br><span class="line">    IList&lt;ICanvasElement&gt; m_LayoutRebuildQueue;</span><br><span class="line">    IList&lt;ICanvasElement&gt; m_GraphicRebuildQueue;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Type type = <span class="keyword">typeof</span>(CanvasUpdateRegistry);</span><br><span class="line">        FieldInfo field = type.GetField(<span class="string">&quot;m_LayoutRebuildQueue&quot;</span>, BindingFlags.NonPublic | BindingFlags.Instance);</span><br><span class="line">        m_LayoutRebuildQueue = (IList&lt;ICanvasElement&gt;)field.GetValue(CanvasUpdateRegistry.instance);</span><br><span class="line">        field = type.GetField(<span class="string">&quot;m_GraphicRebuildQueue&quot;</span>, BindingFlags.NonPublic | BindingFlags.Instance);</span><br><span class="line">        m_GraphicRebuildQueue = (IList&lt;ICanvasElement&gt;)field.GetValue(CanvasUpdateRegistry.instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; m_LayoutRebuildQueue.Count; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ICanvasElement element = m_LayoutRebuildQueue[j];</span><br><span class="line">            <span class="keyword">if</span> (!ObjectValidForUpdata(element))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Graphic graphic = element.transform.GetComponent&lt;Graphic&gt;();</span><br><span class="line">            <span class="keyword">if</span> (graphic == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Canvas canvas = graphic.canvas;</span><br><span class="line">            <span class="keyword">if</span> (canvas == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span> str = <span class="string">$&quot;&lt;color=#ff0000&gt;<span class="subst">&#123;element.transform.name&#125;</span>&lt;/color&gt;的LayoutRebuild引起&lt;color=#ff0000&gt;<span class="subst">&#123;canvas.name&#125;</span>&lt;/color&gt;网格重建&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m_FrameMode)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.AppendLine(str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogError(str);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; m_GraphicRebuildQueue.Count; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ICanvasElement element = m_GraphicRebuildQueue[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!ObjectValidForUpdata(element))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Graphic graphic = element.transform.GetComponent&lt;Graphic&gt;();</span><br><span class="line">            <span class="keyword">if</span> (graphic == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Canvas canvas = graphic.canvas;</span><br><span class="line">            <span class="keyword">if</span> (canvas == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span> canvansName = canvas.name;</span><br><span class="line">            <span class="keyword">if</span> (canvansName == <span class="string">&quot;DebugFps&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span> str = <span class="string">$&quot;&lt;color=#ff0000&gt;<span class="subst">&#123;element.transform.name&#125;</span>&lt;/color&gt;的LayoutRebuild引起&lt;color=#ff0000&gt;<span class="subst">&#123;canvas.name&#125;</span>&lt;/color&gt;网格重建&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m_FrameMode)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.AppendLine(str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogError(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sb.Length != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">$&quot;当前帧&lt;color=#66ccff&gt;<span class="subst">&#123;Time.frameCount&#125;</span>&lt;/color&gt;:\n<span class="subst">&#123;sb.ToString()&#125;</span>&quot;</span>);</span><br><span class="line">            sb.Clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">ObjectValidForUpdata</span>(<span class="params">ICanvasElement element</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> valid = element != <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">bool</span> isUnityObject = element <span class="keyword">is</span> UnityEngine.Object;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isUnityObject)</span><br><span class="line">        &#123;</span><br><span class="line">            valid  = (element <span class="keyword">as</span> UnityEngine.Object) != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Rebatch"><a href="#Rebatch" class="headerlink" title="Rebatch"></a>Rebatch</h1><p>Rebatch指以Canvas为单位的UI网格合并，其在Profiler中体现为Canvas.BuildBatch项，Rebuild通常都会引发Rebatch，UI的位置移动也会触发Rebatch</p><p>因此对于需要频繁改变的UI，就需要通过子Canvas与不变的UI分开，以降低改变每次改变UI导致的Rebatch开销，这也被称之为动静分离</p><p>但是不同Canvas下的UI是不能合批的，按照Unity官方的说法，在开启了<strong>多线程渲染</strong>的情况下，已经不建议再做动静分离了</p><h1 id="Overdraw"><a href="#Overdraw" class="headerlink" title="Overdraw"></a>Overdraw</h1><p>在渲染管线中，对于不透明物体，其绘制顺序都是从前往后绘制，这样被挡住的物体就不会再被绘制，继而节省了GPU渲染开销</p><p>而半透明物体则是从后往前渲染，因为半透明物体需要进行颜色混合，从前往后渲染会导致在一个半透明物体遮挡另一个半透明物体时，颜色混合结果不正确</p><p>Overdraw即过度绘制，意为一个像素被反复绘制了多次，这种情况通常发生在半透明物体的渲染中</p><p>在实际开发中，为了实现一个点击弹窗空白区域关闭弹窗UI的效果，往往会使用一个完全透明的Image放在弹窗底下，而由于Unity中所有UI都是作为半透明物体进行渲染的，这样做就会造成Overdraw现象</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/UIOptimizatioOfMMO/UIOptimizatioOfMMO_7.png"></p><p>解决方案是通过继承Image组件重写OnPopulateMesh方法，将顶点信息清空</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UnityEngine.UI</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Empty4Raycast</span> : <span class="title">MaskableGraphic</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">Empty4Raycast</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            useLegacyMeshGeneration = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPopulateMesh</span>(<span class="params">VertexHelper toFill</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            toFill.Clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Instance"><a href="#Instance" class="headerlink" title="Instance"></a>Instance</h1><p>在打开一个诸如背包这样有很多Item的界面时，通常会感觉到明显的卡顿</p><p>其原因主要在于一次性实例化了过多GameObject，而Unity中GameObject的实例化只能在主线程进行，一次性实例化太多就会卡住主线程的执行</p><p>解决方案就是通过定时器实现分帧加载与实例化，这样可以做到对背包之类的多Item界面打开时玩家会有很丝滑的体验</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity资源框架设计中不同级别依赖管理的对比</title>
      <link href="/2021/10/29/dependency-manage-compare/"/>
      <url>/2021/10/29/dependency-manage-compare/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Unity资源框架的设计中，资源的依赖管理可谓是重中之重，框架设计者往往会使用一张资源清单来记录资源间的依赖关系，而依赖管理的粒度可以分为2个级别：</p><ol><li><strong>Bundle与Bundle间的依赖</strong></li><li><strong>Asset与Asset间的依赖</strong></li></ol><p>本文将对这两个不同级别的依赖管理粒度进行比较分析，最终给出一个较好的可行方案</p><h1 id="Bundle级的依赖管理"><a href="#Bundle级的依赖管理" class="headerlink" title="Bundle级的依赖管理"></a>Bundle级的依赖管理</h1><p>Bundle级的依赖管理是Unity构建管线中所默认使用的依赖管理，在调用<code>BuildPipeline.BuildAssetBundles</code>后会返回一个 <code>AssetBundleManifest</code>对象，调用它的<code>GetAllDependencies(string assetBundleName)</code>会返回指定名称的AssetBundle所依赖的所有AssetBundle名称。</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/DependencyManageCompare/DependencyManageCompare_1.png"></p><p>如上图所示，A包的资源a1依赖B包的资源b1，a2依赖c2，那么在Bundle级别的依赖管理中，就会记录A包的依赖资源为B包与C包，在加载A包前会首先加载好B包与C包并增加B与C的引用计数，在卸载A包时会减少B和C的引用计数</p><p>许多现有的Unity资源框架都采用这一方式进行资源依赖管理，然而这一方式存在3个明显的缺陷：</p><ol><li><strong>依赖文件过度加载</strong></li><li><strong>对Asset的依赖资源状态无知</strong></li><li><strong>更容易出现的循环依赖</strong></li></ol><h2 id="依赖文件过度加载"><a href="#依赖文件过度加载" class="headerlink" title="依赖文件过度加载"></a>依赖文件过度加载</h2><p>Bundle级别的依赖管理要求在加载一个Bundle前首先准备好其所依赖的所有Bundle</p><p>但在实践中，一个Bundle会包含许多Asset，而这些Asset又会分别依赖其他Asset，这些被依赖的Asset又会被打包在不同的Bundle中，这就导致了一个Bundle会依赖大量其他Bundle的现象出现</p><p>我们可以考虑一个比较极端但直白的例子：</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/DependencyManageCompare/DependencyManageCompare_2.png"></p><p>如上图，A包的资源a1到a100分别依赖b1到b100，此时资源清单会将A包的依赖资源记录为B1到B100</p><p>而如果此时只是想加载a1到内存中，Bundle级别的依赖管理都会要求首先将B1到B100这100个Bundle都加载到内存中，从而导致极大的IO开销和内存浪费</p><p>想要避免这种情况就要求在构建Bundle时就得做好Asset的划分，避免Bundle依赖到过多的其他Bundle</p><h2 id="对Asset的依赖资源状态无知"><a href="#对Asset的依赖资源状态无知" class="headerlink" title="对Asset的依赖资源状态无知"></a>对Asset的依赖资源状态无知</h2><p>Bundle级别的依赖管理之所以能运转，完全得益于Unity底层的对依赖加载的自动处理：在加载一个Asset前，只需要准备好它所依赖的其他Asset的Bundle，那么Unity底层便会对依赖的Asset进行自动依赖加载</p><p>但把依赖加载完全交给Unity底层的代价便是使用者对被依赖加载的Asset的使用状态一无所知，导致对可能出现的资源不卸载Bug难以排查</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/DependencyManageCompare/DependencyManageCompare_3.png"></p><p>如上图，如果出现了C包应该被卸载但无法被卸载的情况，那么Bundle级的依赖管理最多只能知道C无法卸载是因为C中的某个Asset被A或B中的某个使用中的Asset依赖着，而无法知道究竟是C中的哪个Asset被A或B中的哪个Asset依赖，由此加大了对资源不卸载Bug的排查难度</p><h2 id="更容易出现的循环依赖"><a href="#更容易出现的循环依赖" class="headerlink" title="更容易出现的循环依赖"></a>更容易出现的循环依赖</h2><p>在前文中提到过，Bundle级别的依赖管理要求在加载一个Bundle前准备好它所依赖的其他Bundle</p><p>但由于一个Bundle中可以包含多个Asset，而一个Bundle的依赖又是根据Asset依赖的其他Asset所在的Bundle决定的，这也就导致了十分容易出现Bundle间的循环依赖</p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/DependencyManageCompare/DependencyManageCompare_4.png"></p><p>在上图的情况中，哪怕Asset间并没有产生循环依赖，依然会在Bundle间产生循环依赖，最终导致加载时爆栈</p><p>同样的，想避免这种情况就要求必须在构建Bundle时就得做好对Asset的划分</p><h1 id="Asset级的依赖管理"><a href="#Asset级的依赖管理" class="headerlink" title="Asset级的依赖管理"></a>Asset级的依赖管理</h1><p>想要进行Asset级别的依赖管理，就需要抛弃Unity提供的AssetBundleManifest那一套，使用自定义的资源清单，以<a href="https://github.com/CatImmortal/CatAsset">CatAsset</a>为例，其资源清单结构如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> CatAsset资源清单</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CatAssetManifest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 游戏版本号</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> GameVersion;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 清单版本号</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ManifestVersion;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 所有AssetBundle清单信息</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> AssetBundleManifestInfo[] AssetBundles;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> AssetBundle清单信息</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AssetBundleManifestInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> AssetBundle名</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> AssetBundleName;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 文件长度</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Length;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 文件Hash</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> Hash128 Hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 是否为场景的AssetBundle包</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsScene;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 资源组</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Group;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 所有Asset清单信息</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> AssetManifestInfo[] Assets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Asset清单信息</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AssetManifestInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Asset名</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> AssetName;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 依赖的所有Asset</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>[] Dependencies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在构建Bundle时调用<code>AssetDatabase.GetDependencies</code>即可获取指定Asset所依赖的其他Asset，然后便可以根据获得的依赖信息自行构建资源清单进行依赖管理</p><p>Asset级别的依赖管理可以很好的避免Bundle级别的依赖管理所容易出现的3个问题：</p><p><strong>首先，Asset级别的依赖管理只要求在加载Asset前准备好其所依赖的所有Asset，因此不会出现过度依赖加载的情况</strong></p><p><strong>其次，由于所有依赖资源都将通过资源框架进行加载而不再完全交给Unity底层，因此可以对依赖资源也进行显式的引用计数，这样如果有Bundle无法卸载便可以很直观的排查到是哪个Asset被引用着，被谁引用着</strong></p><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/DependencyManageCompare/DependencyManageCompare_4.png"></p><p><strong>最后，只有在Asset间出现循环依赖时才会导致加载爆栈，而像上图中的情况则不会对加载有任何影响</strong></p><p>但是Asset级别的依赖管理中存在一个较严重的问题——<strong>卸载依赖Bundle后重新加载Asset会导致对依赖资源的引用丢失（Missing）</strong></p><h2 id="依赖资源引用丢失"><a href="#依赖资源引用丢失" class="headerlink" title="依赖资源引用丢失"></a>依赖资源引用丢失</h2><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/DependencyManageCompare/DependencyManageCompare_5.png"></p><p>由于Asset级别的依赖管理不会考虑Bundle之间的依赖，在上图所示的情况中，如果依次进行：</p><ol><li>加载a1</li><li>加载a2</li><li>卸载a1</li><li>加载a1</li></ol><p>就会发现a1对b1的资源引用是处于Missing状态的</p><p>那么为什么会出现这种情况呢？</p><p>因为在第3步中，当我们卸载了a1后，b1也会被作为依赖卸载，此时B包处于没有Asset在被使用中的状态，因此也就进行了对B包的卸载，<strong>因为卸载了B包，b1已不在内存中，但A包还没被卸载，a1仍然在内存中存在，只是不处于被使用中的状态(注意：<em>只有AssetBundle.Unload(true)和Resources.UnloadUnusedAssets才能将AssetBundle中的已加载Asset从内存中销毁</em>)，所以a1对b1的引用就是Missing的</strong></p><p>到了第4步，我们重新加载a1，由于a1对b1的引用已经Missing，所以<strong>即便我们再次把b1依赖加载到内存中，也不会重新恢复丢失的引用</strong></p><h1 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h1><p>要处理Asset级别的依赖管理中可能出现的依赖资源引用丢失问题，就需要在加载Asset时，对被依赖加载的Asset所属的Bundle进行记录，并对其增加引用计数，然后在卸载Bundle时根据记录减少对应Bundle的引用计数</p><p>同样的，在判定一个Bundle是否可以卸载时，需要不仅仅只是根据其是否有Asset处于使用中状态（即Asset引用计数&gt;0）来判断，还需要结合此Bundle的引用计数来进行判断（也就是一个Bundle除了没有Asset在使用外，还必须没有被其他Bundle引用才能进行卸载）</p><p>通过Bundle间的引用计数虽然可以避免依赖资源引用丢失问题，但也引入了一个新的问题：</p><p><strong>如果产生了Bundle间的循环依赖，那么会导致Bundle间互相等待对方卸载，结果都无法卸载自身</strong></p><p>这个问题类似于多线程编程中的死锁问题，要处理这个问题，只能通过在构建Bundle时加入Bundle间循环依赖的检测，力图在Editor阶段就查出问题，以避免Runtime时的错误</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
          <category> 踩坑记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ILRuntime类型系统概述</title>
      <link href="/2021/10/25/ilruntime-type-system-summary/"/>
      <url>/2021/10/25/ilruntime-type-system-summary/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔者在前段时间为<a href="https://github.com/CatImmortal/CatJson">CatJson</a>进行ILRuntime适配时，因为涉及到反射与泛型的跨域使用，故而进行了一番对ILRuntime类型系统的研究。</p><p>本文将从三个方面对ILRuntime类型系统进行讨论：</p><ol><li>热更层往主工程传递实例</li><li>热更层调用主工程泛型方法</li><li>热更层往主工程传递Type对象</li></ol><h1 id="热更层往主工程传递实例"><a href="#热更层往主工程传递实例" class="headerlink" title="热更层往主工程传递实例"></a>热更层往主工程传递实例</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 主工程类型</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MainClass</span> &#123; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 主工程工具类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Util</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//打印出obj的类型</span></span><br><span class="line">        Debug.Log(obj.GetType());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 热更层类型</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HotfixClass</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//热更层调用</span></span><br><span class="line">MainClass mc = <span class="keyword">new</span> MainClass();</span><br><span class="line">HotfixClass hc = <span class="keyword">new</span> HotfixClass();</span><br><span class="line"></span><br><span class="line">Util.Test(mc);  <span class="comment">//输出MainClass</span></span><br><span class="line">Util.Test(hc);  <span class="comment">//输出ILTypeInstance</span></span><br></pre></td></tr></table></figure><p>在从热更层往主工程传递对象时</p><ul><li>如果此对象类型定义在主工程，那么就是通常情况，obj.GetType将得到一个正确的Type对象</li><li>如果此对象类型定义在热更层，那么此对象就会统一处理为ILTypeInstance类型的对象，ILTypeInstance包装了热更层类型实例对象</li></ul><h1 id="热更层调用主工程泛型方法"><a href="#热更层调用主工程泛型方法" class="headerlink" title="热更层调用主工程泛型方法"></a>热更层调用主工程泛型方法</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 主工程工具类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Util</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//打印出T的类型</span></span><br><span class="line">        Debug.Log(<span class="keyword">typeof</span>(T));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//热更层调用</span></span><br><span class="line">Util.Test&lt;MainClass&gt;();  <span class="comment">//输出MainClass</span></span><br><span class="line">Util.Test&lt;HotfixClass&gt;();  <span class="comment">//输出ILTypeInstance</span></span><br></pre></td></tr></table></figure><p>在热更层调用主工程泛型方法的情况与传递对象实例类似</p><ul><li>如果此泛型类型定义在主工程，那么就是通常情况</li><li>如果此泛型类型定义在热更层，那么该泛型就会统一变成ILTypeInstance</li></ul><h1 id="热更层往主工程传递Type对象"><a href="#热更层往主工程传递Type对象" class="headerlink" title="热更层往主工程传递Type对象"></a>热更层往主工程传递Type对象</h1><p>先对ILRuntime类型系统主要涉及到的类进行说明：</p><ul><li>System.Type：Type基类</li><li>System.RuntimeType：一般情况下，使用typeof和GetType得到的Type对象都是此类型</li><li>ILRuntimeType：主要包装了ILType</li><li>ILRuntimeWrapperType：主要包装了CLRType</li><li>IType：热更层Type接口</li><li>ILType：热更层类型的Type</li><li>CLRType：热更层中的主工程类型的Type</li></ul><p><img src="https://cathole-1307936347.cos.ap-guangzhou.myqcloud.com/ILRuntimeTypeSystem/ilruntime-type-sysytem.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 主工程工具类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Util</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params">Type type</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//打印出Type的类型</span></span><br><span class="line">        Debug.Log(type.GetType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//热更层调用</span></span><br><span class="line">MainClass mc = <span class="keyword">new</span> MainClass();</span><br><span class="line">HotfixClass hc = <span class="keyword">new</span> HotfixClass();</span><br><span class="line"></span><br><span class="line">Util.Test(mc.GetType());  <span class="comment">//输出System.RuntimeType</span></span><br><span class="line">Util.Test(hc.GetType());  <span class="comment">//输出ILRuntime.Reflection.ILRuntimeType</span></span><br></pre></td></tr></table></figure><ul><li><p>如果此Type是主工程类型的Type，那么就是通常情况</p></li><li><p>如果此Type是热更层类型的Type，那么此Type的类型就是ILRuntimeType</p></li></ul><h2 id="对于ILRuntimeType的说明"><a href="#对于ILRuntimeType的说明" class="headerlink" title="对于ILRuntimeType的说明"></a>对于ILRuntimeType的说明</h2><p>在反射编程中，往往需要使用得到的Type对象进行一系列反射操作来读取类型元数据，比如获取字段信息、获取属性信息、获取方法信息等</p><p>ILRuntimeType都对相关操作进行了对应的重写，以返回ILRuntimeFieldInfo、ILRuntimePropertyInfo、ILRuntimeMethodInfo</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ILRuntimeType</span> : <span class="title">Type</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    ILRuntimeFieldInfo[] fields;</span><br><span class="line">    ILRuntimePropertyInfo[] properties;</span><br><span class="line">    ILRuntimeMethodInfo[] methods;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，这些ILRuntime****Info所提供的Type是与通常情况不同的，以ILRuntimeFieldInfo的FieldType获取到的结果为例：</p><ul><li>如果此字段是热更层类型，那么Type就是ILRuntimeType</li><li>如果此字段是主工程类型，那么Type就是ILRuntimeWrapperType</li></ul><h2 id="对于ILRuntimeWrapperType的说明"><a href="#对于ILRuntimeWrapperType的说明" class="headerlink" title="对于ILRuntimeWrapperType的说明"></a>对于ILRuntimeWrapperType的说明</h2><p>ILRuntimeWrapperType包装了CLRType，CLRType表示的是主工程类型的Type</p><p>ILRuntimeWrapperTypeObj.RealType可以获取到主工程类型对应的 System.RuntimeType对象，这和ILRuntimeWrapperTypeObj.CLRType.TypeForCLR等价</p><p>如果ILRuntimeWrapperType包装的是如List<T>这样的主工程泛型类，可以通过ILRuntimeWrapperTypeObj.CLRType.GenericArguments[0].Value.ReflectionType获取到T的Type对象，它可能是ILRuntimeType，也可能是ILRuntimeWrapperType，具体根据T的定义位置决定</p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
          <category> 踩坑记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ILRuntime </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
